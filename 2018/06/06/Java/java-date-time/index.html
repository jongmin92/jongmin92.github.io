<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>날짜와 시간 &amp; 형식화 - 92Hz</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="92Hz"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="92Hz"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="해당 포스팅의 내용은 Java의 정석 2권 - Chapter 10 날짜와 시간 &amp;amp; 형식화에 있는 내용을 요약한 것입니다. 해당 책으로 복습하며 정리한 내용이고 문제가 된다면 바로 해당 포스팅을 삭제하도록 하겠습니다.  날짜와 시간 &amp;amp; 형식화타임존 포함 ISO 8601 문자열의 표현날짜&amp;#x2F;시간 및 타임존을 다루는 국제적인 규약은 다양하다. RF"><meta property="og:type" content="article"><meta property="og:title" content="날짜와 시간 &amp; 형식화"><meta property="og:url" content="https://jongmin92.github.io/2018/06/06/Java/java-date-time/"><meta property="og:site_name" content="92Hz"><meta property="og:description" content="해당 포스팅의 내용은 Java의 정석 2권 - Chapter 10 날짜와 시간 &amp;amp; 형식화에 있는 내용을 요약한 것입니다. 해당 책으로 복습하며 정리한 내용이고 문제가 된다면 바로 해당 포스팅을 삭제하도록 하겠습니다.  날짜와 시간 &amp;amp; 형식화타임존 포함 ISO 8601 문자열의 표현날짜&amp;#x2F;시간 및 타임존을 다루는 국제적인 규약은 다양하다. RF"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jongmin92.github.io/img/og_image.png"><meta property="article:published_time" content="2018-06-06T13:35:00.000Z"><meta property="article:modified_time" content="2021-03-21T11:04:37.929Z"><meta property="article:author" content="KimJongMin"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jongmin92.github.io/2018/06/06/Java/java-date-time/"},"headline":"날짜와 시간 & 형식화","image":["https://jongmin92.github.io/img/og_image.png"],"datePublished":"2018-06-06T13:35:00.000Z","dateModified":"2021-03-21T11:04:37.929Z","author":{"@type":"Person","name":"KimJongMin"},"description":"해당 포스팅의 내용은 Java의 정석 2권 - Chapter 10 날짜와 시간 &amp; 형식화에 있는 내용을 요약한 것입니다. 해당 책으로 복습하며 정리한 내용이고 문제가 된다면 바로 해당 포스팅을 삭제하도록 하겠습니다.  날짜와 시간 &amp; 형식화타임존 포함 ISO 8601 문자열의 표현날짜&#x2F;시간 및 타임존을 다루는 국제적인 규약은 다양하다. RF"}</script><link rel="canonical" href="https://jongmin92.github.io/2018/06/06/Java/java-date-time/"><link rel="alternate" href="/rss2.xml" title="92Hz" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-90389042-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-90389042-1');</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="92Hz" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="카탈로그" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-06-06T13:35:00.000Z" title="6/6/2018, 10:35:00 PM">2018-06-06</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-21T11:04:37.929Z" title="3/21/2021, 8:04:37 PM">2021-03-21</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/Java/">Java</a></span><span class="level-item">30분안에 읽기 (약 4569 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile">날짜와 시간 &amp; 형식화</h1><div class="content"><blockquote>
<p><strong>해당 포스팅의 내용은 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788995379431">Java의 정석 2권 - Chapter 10 날짜와 시간 &amp; 형식화</a>에 있는 내용을 요약한 것입니다. 해당 책으로 복습하며 정리한 내용이고 문제가 된다면 바로 해당 포스팅을 삭제하도록 하겠습니다.</strong></p>
</blockquote>
<h1 id="날짜와-시간-amp-형식화"><a href="#날짜와-시간-amp-형식화" class="headerlink" title="날짜와 시간 &amp; 형식화"></a>날짜와 시간 &amp; 형식화</h1><h2 id="타임존-포함-ISO-8601-문자열의-표현"><a href="#타임존-포함-ISO-8601-문자열의-표현" class="headerlink" title="타임존 포함 ISO 8601 문자열의 표현"></a>타임존 포함 ISO 8601 문자열의 표현</h2><p>날짜/시간 및 타임존을 다루는 국제적인 규약은 다양하다. <strong>RFC 822, 1036, 1123, 2822, 3339, ISO 8601</strong> 등이 있다. 여기서는 <code>ISO 8601</code>과 <code>RFC 3339</code>와 관련된 표기법을 알아본다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 로컬 시간을 의미하는 ISO 8601 문자열</span><br><span class="line">2017-11-06T15:00:00.000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; UTC(GMT) 시간을 의미하는 ISO 8601 문자열</span><br><span class="line">2017-11-06T06:00:00.000Z</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 로컬 시간을 의미하면서 UTC(GMT) 대비 +09:00 임을 의미하는 ISO 8601 문자열</span><br><span class="line">2017-11-06T15:00:00.000+09:00</span><br></pre></td></tr></table></figure>

<ul>
<li><code>2017-11-06T15:00:00.000</code>은 <strong>ISO 8601</strong>의 기본 형식이다. 해당 시간이 로컬 시간 임을 의미한다.</li>
<li><code>2017-11-06T06:00:00.000Z</code>와 같이 뒤에 <code>Z</code> 식별자를 추가하면 해당 시간이 <strong>UTC(GMT)</strong> 시간 임을 의미한다.</li>
<li><code>2017-11-06T15:00:00.000+09:00</code>와 같이 뒤에 <strong>Z</strong> 대신 <code>+HH:mm</code> 식별자를 추가하면 해당 시간이 로컬 시간이면서 **UTC(GMT)**와 <strong>09:00</strong> 만큼 차이가 남을 의미한다. 이 형식의 장점은 인간이 손쉽게 추가적인 계산 없이 로컬 시간을 인지하면서 추가적으로 타임존 정보까지 제공하기 때문에 가장 인간친화적이라고 할 수 있다.</li>
</ul>
<h2 id="날짜와-시간"><a href="#날짜와-시간" class="headerlink" title="날짜와 시간"></a>날짜와 시간</h2><p><code>Date</code>는 날짜와 시간을 다룰 목적으로 JDK 1.0부터 제공되어온 클래스이다. Date 클래스는 기능이 부족했기 때문에, <code>Calendar</code>라는 새로운 클래스를 그 다음 버젼인 JDK 1.1부터 제공하기 시작했다. Calendar는 Date보다는 훨씬 나았지만 몇 가지 단점들이 있었고, JDK 1.8부터 <code>java.time 패키지</code>로 기존의 단점들을 개선한 새로운 클래스들이 추가되었다.</p>
<blockquote>
<p>Date 클래스는 java.util 패키지에 속해있다.</p>
</blockquote>
<p><strong>Date와 Calendar간의 변환</strong></p>
<p>Calendar가 새로 추가되면서 Date는 대부분의 메서드가 ‘deprecated’되었으므로 잘 사용되지 않는다. 그럼에도 불구하고 여전히 Date를 필요로 하는 메서드들이 존재하기 때문에 Calendar를 Date로 또는 그 반대로 변환할 일이 생긴다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Calendar를 Date로 변환</span><br><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line">Date d1 = <span class="keyword">new</span> Date(cal.getTimeInMillis()); <span class="comment">// Date(long date)</span></span><br><span class="line">Date d2 = cal.getTime();</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Date를 Calendar로 변환</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line">cal.setTime(d);</span><br></pre></td></tr></table></figure>

<p>Calendar.getInstance()를 통해서 얻은 인스턴스는 기본적으로 현재 시스템의 날짜와 시간에 대한 정보를 담고 있다. (GregorianCalendar, BuddhistCalendar)</p>
<h2 id="형식화-클래스"><a href="#형식화-클래스" class="headerlink" title="형식화 클래스"></a>형식화 클래스</h2><p>자바의 형식화 클래스는 java.text 패키지에 포함되어 있으며 숫자, 날짜, 텍스트 데이터를 일정한 형식에 맞게 표현할 수 있는 방법을 객체지향적으로 설계하여 표준화하였다. 형식화 클래스는 형식화에 사용될 패턴을 정의하는데, 데이터를 정의된 패턴에 맞춰 형식화할 수 있을 뿐만 아니라 역으로 형식화된 데이터에서 원래의 데이터를 얻어낼 수도 있다. 즉, 형식화된 데이터의 패턴만 정의해주면 복잡한 문자열에서도 substring()을 사용하지 않고도 쉽게 원하는 값을 얻어낼 수 있다는 것이다.</p>
<h3 id="DecimalFormat"><a href="#DecimalFormat" class="headerlink" title="DecimalFormat"></a>DecimalFormat</h3><p>형식화 클래스 중에서 숫자를 형식화 하는데 사용되는 것이 DecimalFormat이다. DecimalFormat을 이용하면 숫자 데이터를 정수, 부동소수점, 금액 등의 다양한 형식으로 표현할 수 있으며, 반대로 일정한 형식의 테스트 데이터를 숫자로 쉽게 변환하는 것도 가능하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> number = <span class="number">1234567.89</span>;</span><br><span class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;#.#E0&quot;</span>);</span><br><span class="line">String result = df.format(number);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Number 클래스는 Integer, Double과 같은 숫자를 저장하는 래퍼 클래스의 조상이며, doubleValue()는 Number에 저장된 값을 double형의 값으로 변환하여 반환한다. 이 외에도 intValue(), floatValue()등의 메서드가 Number클래스에 정의되어 있다.</p>
</blockquote>
<h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><p>Date와 Calendar만으로는 날짜 데이터를 원하는 형태로 다양하게 출력하는 것은 불편하고 복잡하다. 그러나 SimpleDateFormat을 사용하면 이러한 문제들이 간단하게 해결된다.</p>
<blockquote>
<p>DateFormat은 추상클래스로 SimpleDateFormat의 조상이다. DateFormat는 추상클래스이므로 인스턴스를 생성하기 위해서는 getDateInstance()와 같은 static 메서드를 이용해야 한다. getDateInstance()에 의해서 반환되는 것은 DateFormat을 상속받아 완전하게 구현한 SimpleDateFormat 인스턴스이다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date today = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat dt = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 오늘 날짜를 yyyy-MM-dd 형태로 변환하여 반환한다.</span></span><br><span class="line">String result = df.format(today);</span><br></pre></td></tr></table></figure>

<p>Date 인스턴스만 format 메서드에 사용될 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy년 MM월 dd일&quot;</span>);</span><br><span class="line">Date d = df.parse(<span class="string">&quot;2018년 6월 6일&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>parse(String source)를 사용하여 날짜 데이터의 출력형식을 변환하는 방법을 보여주는 예제이다. Integer의 parseInt()가 문자열을 정수로 변환하는 것처럼 SimpleDateFormat의 parse(String source)는 문자열(source)을 날짜(Date인스턴스)로 변환해주기 때문에 매우 유용하게 쓰일 수 있다.</p>
<h3 id="ChoiceFormat"><a href="#ChoiceFormat" class="headerlink" title="ChoiceFormat"></a>ChoiceFormat</h3><p>ChoiceFormat은 특정 범위에 속하는 값을 문자열로 변환해준다. 연속적 또는 불연속적인 범위의 값들을 처리하는 데 있어서 if문이나 switch문은 적절하지 못한 경우가 많다. 이럴때 ChoiceFormat을 잘 사용하면 복잡하게 처리될 수밖에 없었던 코드를 간단하고 직관적으로 만들 수 있다.</p>
<h3 id="MessageFormat"><a href="#MessageFormat" class="headerlink" title="MessageFormat"></a>MessageFormat</h3><p>MessageFormat은 데이터를 정해진 양식에 맞게 출력할 수 있도록 도와준다. 데이터가 들어갈 자리를 마련해 놓은 양식을 미리 작성하고 프로그램을 이용해서 다수의 데이터를 같은 양식으로 출력할 때 사용하면 좋다. 하나의 데이터를 다양한 양식으로 출력할 때 사용한다.</p>
<p>그리고 SimpleDateFormat의 parse처럼 MessageFormat의 parse를 이용하면 지정된 양식에서 필요한 데이터만을 손쉽게 추출해 낼 수도 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String msg = <span class="string">&quot;Name: &#123;0&#125; \nTel: &#123;1&#125; \nnAge:&#123;2&#125; \nBirthday:&#123;3&#125;&quot;</span>;</span><br><span class="line">Object[] arguments = &#123;<span class="string">&quot;이름&quot;</span>, <span class="string">&quot;01-234-5678&quot;</span>, <span class="string">&quot;27&quot;</span>, <span class="string">&quot;04-27&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">String result = MessageFormat.format(msg, arguments);</span><br></pre></td></tr></table></figure>

<p>MessageFormat에 사용될 양식인 문자열 msg를 작성할 때 ‘{숫자}’로 표시된 부분이 데이터가 출력될 자리이다.</p>
<p>데이터를 양식에 넣어서 출려하는것 뿐만 아니라, parse(String source)를 이용해서 출력된 데이터로부터 필요한 데이터만을 뽑아낼 수 있다.</p>
<h2 id="Java-time-패키지"><a href="#Java-time-패키지" class="headerlink" title="Java.time 패키지"></a>Java.time 패키지</h2><p>java의 탄생부터 지금까지 날짜와 시간을 다루는데 사용해왔던, Date와 Calendar가 가지고 있던 단점들을 해소하기 위해 JDK1.8부터 ‘java.time 패키지’가 추가되었다. 이 패키지는 다음과 같이 4개의 하위 패키지를 가지고 있다.</p>
<ul>
<li>java.time : 날짜와 시간을 다루는데 필요한 핵심 클래스들을 제공<ul>
<li>java.time.chrono : 표준(ISO)이 아닌 달력 시스템을 위한 클래스들을 제공</li>
<li>java.time.format : 날짜와 시간을 파싱하고, 형식화하기 위한 클래스들을 제공</li>
<li>java.time.temporal : 날짜와 시간의 필드(field)와 단위(unit)를 위한 클래스들을 제공</li>
<li>java.time.zone : 시간대(time-zone)와 관련된 클래스들을 제공</li>
</ul>
</li>
</ul>
<p>위의 패키지들에 속한 클래스들의 가장 큰 특징은 String 클래스처럼 **불변(immutable)**이라는 것이다. 그래서 날짜나 시간을 변경하는 메서드들은 기존의 객체를 변경하는 대신 항상 변경된 새로운 객체를 반환한다. 기존 Calendar 클래스는 변경 가능하므로, 멀티 쓰레드 환경에서 안전하지 못하다.</p>
<blockquote>
<p>멀티 쓰레드 환경에서는 동시에 여러 쓰레드가 같은 개겣에 접근할 수 있기 때문에, 변경 가능한 객체는 데이터가 잘못될 가능성이 있으며, 이를 쓰레드에 안전(thread-safe)하지 않다고 한다.</p>
</blockquote>
<h3 id="java-time-패키지의-핵심-클래스"><a href="#java-time-패키지의-핵심-클래스" class="headerlink" title="java.time 패키지의 핵심 클래스"></a>java.time 패키지의 핵심 클래스</h3><p><strong>날짜와 시간을 하나로 표현하는 Calendar 클래스와 달리, java.time 패키지에서는 날짜와 시간을 별도의 클래스로 분리해 놓았다.</strong> 시간을 표현할 때는 <code>LocalTime</code> 클래스를 사용하고, 날짜를 표현할 때는 <code>LocalDate</code> 클래스를 사용한다. 그리고 날짜와 시간이 모두 필요할 때는 <code>LocalDateTime</code> 클래스를 사용하면 된다.</p>
<blockquote>
<p>LocalDate + LocalTime -&gt; LocalDateTime<br>     날짜                시간               날짜 &amp; 시간</p>
</blockquote>
<p>여기에 시간대(time-zone)까지 다뤄야 한다면, <code>ZonedDateTime</code> 클래스를 사용한다.</p>
<blockquote>
<p>LocalDateTime + 시간대 -&gt; ZonedDateTime</p>
</blockquote>
<p>Calendar는 ZonedDateTime처럼, 날짜와 시간 그리고 시간대까지 모두 가지고 있다. Date와 유사한 클래스로는 <code>Instant</code>가 있는데, 이 클래스는 날짜와 시간을 초 단위(정확히는 나노초)로 표현한다. <strong>날짜와 시간을 초단위로 표현한 값을 <code>타임스탬프(time-stamp)</code> 라고 부르는데, 이 값은 날짜와 시간을 하나의 정수로 표현할 수 있으므로 날짜와 시간의 차이를 계산하거나 순서를 비교하는데 유리해서 데이터베이스에 많이 사용한다.</strong></p>
<p><strong>객체 생성하기 - now(), of()</strong></p>
<p>java.time 패키지에 속한 클래스의 객체를 생성하는 가장 기본적인 방법은 now()와 of()를 사용하는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.now(); <span class="comment">// 2018-06-06</span></span><br><span class="line">LocalTime time = LocalTime.now(); <span class="comment">// 02:34:50.223</span></span><br><span class="line">LocalDateTime dateTime = LocalDateTime.now(); <span class="comment">// 2018-06-06T02:34:50.223</span></span><br><span class="line">ZonedDateTime dateTimeInKr = ZonedDateTime.now(); <span class="comment">// 2018-06-06T02:34:50.223+09:00[Asia/Seoul]</span></span><br></pre></td></tr></table></figure>



<h3 id="LocalDate와-LocalTime"><a href="#LocalDate와-LocalTime" class="headerlink" title="LocalDate와 LocalTime"></a>LocalDate와 LocalTime</h3><p><code>LocalDate</code>와 <code>LocalTime</code>은 java.time 패키지의 가장 기본이 되는 클래스이며, 나머지 클래스들은 이들의 확장이므로 이 두 클래스만 잘 이해하고 나면 나머지는 아주 쉬워진다.</p>
<p>객체를 생성하는 방법은 현재의 날짜와 시간을 LocalDate와 LocalTime으로 각각 반환하는 now()와 지정된 날짜와 시간으로 LocalDate와 LocalTime 객체를 생성하는 of()가 있다.</p>
<ul>
<li>특정 필드의 값 가져오기 - get(), getXXX()</li>
<li>필드의 값 변경하기 - with(), plus(), minus()</li>
<li>날짜와 시간의 비교 - isAfter(), isBefore(), isEqual()</li>
</ul>
<h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><p><code>Instant</code>는 에포크 타임(EPOCH TIME, 1970-01-01 00:00:00 UTC)부터 경과된 시간을 나노초 단위로 표현한다. 사람이 보기에는 불편하지만, 단일 진법으로 다루기 때문에 계산에는 편리하다. 사람이 사용하는 날짜와 시간에는 여러 진법이 섞여있어서 계산하기 어렵다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Instant now = Instant.now();</span><br><span class="line">Instant now2 = Instant.ofEpochSecond(now.getEpochSecond());</span><br><span class="line">Instant now3 = Instant.ofEpochSecond(now.getEpochSecond(), now.getNano());</span><br></pre></td></tr></table></figure>

<p>Instant를 생성할 때는 위와 같이 now()와 ofEpochSecond()를 사용한다. 그리고 필드에 저장된 값을 가져올 때는 다음과 같이 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long epochSec &#x3D; now.getEpochSecond();</span><br><span class="line">int nano &#x3D; now.getNano();</span><br></pre></td></tr></table></figure>

<p>위의 코드처럼, Instant는 시간을 초 단위와 나노초 단위로 나누어 저장한다. 오라클 데이터베이스의 타임스탬프(timestamp)처럼 밀리초 단위의 EPOCH TIME을 필요로 하는 경우를 위해 toEpochMilli()가 정의되어 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">toEpochMilli</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Instant는 항상 UTC(+00:00)를 기준으로 하기 때문에, LocalTime과 차이가 있을 수 있다.</strong> 예를 들어 한국은 시간대가 ‘+09:00’이므로 Instant와 LocalTime간에는 9시간의 차이가 있다. 시간대를 고려해야하는 경우 OffsetDateTime을 사용하는 것이 더 나은 선택일 수 있다.</p>
<blockquote>
<p>UTC는 ‘Coordinated Universal Time’의 약어로 ‘세계 협정시’이라고 하며, 1972년 1월 1일부터 시행된 국제 표준시이다. 이전에 사용되던 GMT(Greenwich Mean Time)와 UTC는 거의 같지만, UTC가 좀 더 정확하다.</p>
</blockquote>
<h3 id="LocalDateTime과-ZonedDateTime"><a href="#LocalDateTime과-ZonedDateTime" class="headerlink" title="LocalDateTime과 ZonedDateTime"></a>LocalDateTime과 ZonedDateTime</h3><p>LocalDateTime에 시간대(time-zone)를 추가하면, ZonedDateTime이 된다. 기존에는 TimeZone클래스로 시간대를 다뤘지만 새로운 시간 패키지에서는 ZoneId라는 클래스를 사용한다. ZoneId는 일광 절약시간(DST, Daylight Saving Time)을 자동적으로 처리해주므로 더 편리하다.</p>
<p>LocalDate에 시간 정보를 추가하는 atTime()을 쓰면 LocalDateTime을 얻을 수 있는 것처럼, LocalDateTime에 atZone()으로 시간대 정보를 추가하면, ZonedDateTime을 얻을 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZoneId zid = ZoneId.of(<span class="string">&quot;Asia/Seoul&quot;</span>);</span><br><span class="line">zonedDateTime zdt = dateTime.atZone(zid);</span><br><span class="line">Syste.out.println(zdt); <span class="comment">// 2018-06-06T14:23:50.235+09:00[Asia/Seoul]</span></span><br></pre></td></tr></table></figure>



<p>만일 현재 특정 시간대의 시간, 예를 들어 뉴욕을 알고 싶다면 다음과 같이 하면 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZoneId nyId = ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line">ZonedDateTime nyTime = ZonedDateTime.now().withZoneSameInstant(nyId);</span><br></pre></td></tr></table></figure>



<p><strong>ZoneOffSet</strong></p>
<p>UTC로부터 얼마만큼 떨어져 있는지를 ZoneOffSet으로 표현한다. 위의 결과에서 알 수 있듯이 서울은 ‘+9’이다. 즉, UTC보다 9시간(32400초=60*60*9)이 빠르다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZoneOffset krOffset = ZonedDateTime.now().getOffset();</span><br><span class="line"><span class="keyword">int</span> krOffsetInSec = KrOffset.get(ChronoField.OFFSET_SECONDS); <span class="comment">// 32400초</span></span><br></pre></td></tr></table></figure>



<p><strong>OffsetDateTime</strong></p>
<p>ZonedDateTime은 ZoneId로 구역을 표현하는데, ZoneId가 아닌 ZoneOffset을 사용하는 것이 OffSetDateTime이다. ZoneId는 일광절약시간처럼 시간대와 관련된 규칙들을 포함하고 있는데, ZoneOffset은 단지 시간대를 시간의 차이로만 구분한다. 컴퓨터에게 일광절약시간처럼 계절별로 시간을 더했다 뺐다 하는 것과 같은 행위는 위험하다. 아무런 변화 없이 일관된 시간체계를 유지하는 것이 더 안전하다. <strong>같은 지역 내의 컴퓨터 간에 데이터를 주고 받을 때, 전송시간을 표현하기에 LocalDateTime이면, 충분하겠지만, 서로 다른 시간대에 존재하는 컴퓨터간의 통신에는 OffsetDateTime이 필요하다.</strong></p>
<blockquote>
<p><strong>일광 절약 시간제</strong>(Daylight saving time, DST) 또는 <strong>서머 타임</strong>(summer time)은 하절기에 표준시를 원래 시간보다 한 시간 앞당긴 시간을 쓰는 것을 말한다. 즉, 0시에 일광 절약 시간제를 실시하면 1시로 시간을 조정해야 하는 것이다. 실제 낮 시간과 사람들이 활동하는 낮 시간 사이의 격차를 줄이기 위해 사용한다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime zdt = ZondedDateTime.of(date, time, zid);</span><br><span class="line">OffsetDateTime odt = offsetDateTime.of(date, time, krOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZonedDatetime -&gt; OffsetDateTime</span></span><br><span class="line">OffsetDateTime odt = zdt.toOffsetDateTime();</span><br></pre></td></tr></table></figure>

<p>OffsetDateTime을 ZonedDateTime처럼, LocalDate와 LocalTime에 ZonedOffset을 더하거나, ZonedDateTime에 toOffsetDateTime()을 호출해서 얻을 수도 있다.</p>
<p>지금까지의 내용을 예제로 확인해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LocalDate ld = LocalDate.now();</span><br><span class="line">LocalTime lt = LocalTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;LocalDate : &quot;</span> + ld);</span><br><span class="line">System.out.println(<span class="string">&quot;LocalTime : &quot;</span> +lt);</span><br><span class="line"></span><br><span class="line">LocalDateTime dt = LocalDateTime.of(ld, lt);</span><br><span class="line">System.out.println(<span class="string">&quot;LocalDateTime : &quot;</span> + dt);</span><br><span class="line"></span><br><span class="line">ZoneId zid = ZoneId.of(<span class="string">&quot;Asia/Seoul&quot;</span>);</span><br><span class="line">ZonedDateTime zdt = dt.atZone(zid);</span><br><span class="line">System.out.println(<span class="string">&quot;ZonedDateTime1 : &quot;</span> + zdt);</span><br><span class="line"></span><br><span class="line">ZonedDateTime seoulTime = ZonedDateTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;ZonedDateTime2 : &quot;</span> + seoulTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 특정 구역 시간의 다른 구역 시간 구하기</span></span><br><span class="line">ZoneId nyId = ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line">ZonedDateTime nyTime = ZonedDateTime.now().withZoneSameInstant(nyId);</span><br><span class="line">System.out.println(<span class="string">&quot;ZonedDateTime3 : &quot;</span> + nyTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 출력 결과</span></span><br><span class="line">LocalDate : <span class="number">2018</span>-<span class="number">06</span>-<span class="number">06</span></span><br><span class="line">LocalTime : <span class="number">10</span>:<span class="number">28</span>:<span class="number">37.743</span></span><br><span class="line">LocalDateTime : <span class="number">2018</span>-<span class="number">06</span>-06T10:<span class="number">28</span>:<span class="number">37.743</span></span><br><span class="line">ZonedDateTime1 : <span class="number">2018</span>-<span class="number">06</span>-06T10:<span class="number">28</span>:<span class="number">37.743</span>+09:<span class="number">00</span>[Asia/Seoul]</span><br><span class="line">ZonedDateTime2 : <span class="number">2018</span>-<span class="number">06</span>-06T10:<span class="number">28</span>:<span class="number">37.744</span>+09:<span class="number">00</span>[Asia/Seoul]</span><br><span class="line">ZonedDateTime3 : <span class="number">2018</span>-<span class="number">06</span>-05T21:<span class="number">28</span>:<span class="number">37.747</span>-<span class="number">04</span>:<span class="number">00</span>[America/New_York]</span><br></pre></td></tr></table></figure>



<h3 id="TemporalAdjusters"><a href="#TemporalAdjusters" class="headerlink" title="TemporalAdjusters"></a>TemporalAdjusters</h3><p>plus(), minus()와 같은 메서드로 날짜와 시간을 계산하기에는 불편한 경우가 있다. (Ex. 이번 달의 3번째 금요일) 그래서 자주 쓰일만한 날짜 계산들을 대신 해주는 메서드를 정의해놓은 것이 TemporalAdjusters 클래스이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate nextMonday = today.with(TemporalAdjusters.next(DayofWeek.MONDAY))l</span><br></pre></td></tr></table></figure>

<p>with()는 LocalTime, LocalDateTime, ZonedDateTime, Instant 등 대부분의 날짜와 시간에 관련된 클래스에 포함되어 있다.</p>
<h3 id="Period와-Duration"><a href="#Period와-Duration" class="headerlink" title="Period와 Duration"></a>Period와 Duration</h3><p><code>Period</code>는 날짜의 차이를, <code>Duration</code>은 시간의 차이를 계산하기 위한 것이다.</p>
<p><strong>between()</strong></p>
<p>두 날짜 date1과 date2의 차이를 나타내는 Period는 between()으로 얻을 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">LocalDate date2 = LocalDate.of(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">Period pe = Period.between(date1, date2)</span><br></pre></td></tr></table></figure>

<p>date1이 date2보다 날짜 상으로 이전이면 양수로, 이후면 음수로 Period에 저장된다. 그리고 시간차이를 구할 때는 Duration을 사용한다는 것을 제외하고는 Period와 똑같다.</p>
<p>Period, Duration에서 특정 필드의 값을 얻을 때는 get()을 사용한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> year = pe.get(ChronoUnit.YEARS); <span class="comment">// int getYears()</span></span><br><span class="line"><span class="keyword">long</span> month = pe.get(ChronoUnit.MONTHS); <span class="comment">// int getMonths()</span></span><br><span class="line"><span class="keyword">long</span> day = pe.get(ChronoUnit.DAYS); <span class="comment">// int getDays()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> sec = du.get(ChronoUnit.SECONDS); <span class="comment">// long getSeconds()</span></span><br><span class="line"><span class="keyword">long</span> nano = du.get(ChronoUnit.NANOS); <span class="comment">// int getNano()</span></span><br></pre></td></tr></table></figure>



<p><strong>between()과 until()</strong></p>
<p>until()은 between()과 거의 같은 일을 한다. between()은 static 메서드이고, until()은 인스턴스 메서드라는 차이가 있다.</p>
<p>Period는 년월일을 분리해서 저장하기 때문에, D-day를 구하려는 경우에는 두 개의 매개변수를 받는 until()을 사용하는 것이 낫다.</p>
<h3 id="파싱과-포맷"><a href="#파싱과-포맷" class="headerlink" title="파싱과 포맷"></a>파싱과 포맷</h3><p>날짜와 시간을 원하는 형식으로 출력하고 해석(파싱)을 위한 형식화(formatting)와 관련된 클래스들은 java.time.format 패키지에 들어 있다. 그 중에서 <code>DateTimeFormatter</code>가 핵심이다. 이 클래스에는 자주 쓰이는 다양한 형식들을 기본적으로 정의하고 있으며, 그 외의 형식이 필요하다면 직접 정의해서 사용할 수도 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">String yyyymmdd = DateTimeFormatter.ISO_LOCAL_DATE.format(date); <span class="comment">// &quot;2016-06-06&quot;</span></span><br><span class="line">String yyyymmdd = date.format(DateTimeFormatter.ISO_LOCAL_DATE); <span class="comment">// &quot;2018-06-06</span></span><br></pre></td></tr></table></figure>

<p>날짜와 시간의 형식화에는 format()이 사용되는데, 이 메서드는 DateTimeFormatter뿐만 아니라 LocalDate나 LocalTime같은 클래스에도 있다. 같은 기능을 하기 때문에 상황에 따라 편한 쪽을 선택해서 사용하면 된다.</p>
<p><strong>문자열을 날짜와 시간으로 파싱하기</strong></p>
<p>문자열을 날짜 또는 시간으로 변환하려면 static 메서드 parse()를 사용하면 된다. 자주 사용되는 기본적인 형식의 문자열은 ISO_LOCAL_DATE와 같은 형식화 상수를 사용하지 않고도 파싱이 가능하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.parse(<span class="string">&quot;2018-06-06&quot;</span>, DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">LocalDate newDate = LocalDate.parse(<span class="string">&quot;2018-06-06&quot;</span>);</span><br><span class="line">LocalTime newTime = LocalTime.parse(<span class="string">&quot;23:59:59&quot;</span>);</span><br><span class="line">LocalDateTime newDateTime = LocalDateTime.parse(<span class="string">&quot;2018-06-06T23:59:59&quot;</span>);</span><br></pre></td></tr></table></figure>



<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://jsonobject.tistory.com/403">Java 8, 타임존이 포함된 ISO 8601 문자열을 LocalDateTime으로 변환하기</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://wickso.me/2018/02/20/time-zone-with-java8/#Java8%EC%9D%98-%ED%83%80%EC%9E%84%EC%A1%B4">Java8에서 타임존(Time-Zone) 다루기</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788995379431">Java의 정석 - 2</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>날짜와 시간 &amp; 형식화</p><p><a href="https://jongmin92.github.io/2018/06/06/Java/java-date-time/">https://jongmin92.github.io/2018/06/06/Java/java-date-time/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>KimJongMin</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2018-06-06</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-03-21</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="external nofollow noopener noreferrer" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="external nofollow noopener noreferrer" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="external nofollow noopener noreferrer" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/06/10/Java/java-collection-framework/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Collection Framework</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/05/20/Spring/toby-8/"><span class="level-item">토비의 스프링 8장 (스프링이란 무엇인가?)</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">댓글</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://jongmin92.github.io/2018/06/06/Java/java-date-time/';
            this.page.identifier = '2018/06/06/Java/java-date-time/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'https-jongmin92-github-io' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">카탈로그</h3><ul class="menu-list"><li><a class="level is-mobile" href="#날짜와-시간-amp-형식화"><span class="level-left"><span class="level-item">1</span><span class="level-item">날짜와 시간 &amp; 형식화</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#타임존-포함-ISO-8601-문자열의-표현"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">타임존 포함 ISO 8601 문자열의 표현</span></span></a></li><li><a class="level is-mobile" href="#날짜와-시간"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">날짜와 시간</span></span></a></li><li><a class="level is-mobile" href="#형식화-클래스"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">형식화 클래스</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#DecimalFormat"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">DecimalFormat</span></span></a></li><li><a class="level is-mobile" href="#SimpleDateFormat"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">SimpleDateFormat</span></span></a></li><li><a class="level is-mobile" href="#ChoiceFormat"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">ChoiceFormat</span></span></a></li><li><a class="level is-mobile" href="#MessageFormat"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">MessageFormat</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Java-time-패키지"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">Java.time 패키지</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#java-time-패키지의-핵심-클래스"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">java.time 패키지의 핵심 클래스</span></span></a></li><li><a class="level is-mobile" href="#LocalDate와-LocalTime"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">LocalDate와 LocalTime</span></span></a></li><li><a class="level is-mobile" href="#Instant"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">Instant</span></span></a></li><li><a class="level is-mobile" href="#LocalDateTime과-ZonedDateTime"><span class="level-left"><span class="level-item">1.4.4</span><span class="level-item">LocalDateTime과 ZonedDateTime</span></span></a></li><li><a class="level is-mobile" href="#TemporalAdjusters"><span class="level-left"><span class="level-item">1.4.5</span><span class="level-item">TemporalAdjusters</span></span></a></li><li><a class="level is-mobile" href="#Period와-Duration"><span class="level-left"><span class="level-item">1.4.6</span><span class="level-item">Period와 Duration</span></span></a></li><li><a class="level is-mobile" href="#파싱과-포맷"><span class="level-left"><span class="level-item">1.4.7</span><span class="level-item">파싱과 포맷</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#참고"><span class="level-left"><span class="level-item">2</span><span class="level-item">참고</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="92Hz" height="28"></a><p class="is-size-7"><span>&copy; 2021 KimJongMin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>