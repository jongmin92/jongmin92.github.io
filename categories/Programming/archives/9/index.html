<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8">

<meta name="generator" content="Hexo 3.9.0">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<title>카테고리: Programming - 92Hz</title>

<!-- For SEO -->
<link rel="canonical" href="https://jongmin92.github.io/categories/programming/archives/9/">


    <meta property="og:type" content="website">
<meta property="og:title" content="92Hz">
<meta property="og:url" content="https://jongmin92.github.io/categories/Programming/archives/9/index.html">
<meta property="og:site_name" content="92Hz">
<meta property="og:locale" content="ko">
<meta property="og:image" content="https://jongmin92.github.io/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="92Hz">
<meta name="twitter:image" content="https://jongmin92.github.io/images/og_image.png">





<link rel="alternative" href="rss2.xml" title="92Hz" type="application/atom+xml">



<link rel="icon" href="/images/favicon.png">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90389042-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-90389042-1');
</script>

    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.png" alt="92Hz" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item" href="/">Home</a>
                
                <a class="navbar-item" href="/archives">Archives</a>
                
                <a class="navbar-item" href="/categories">Categories</a>
                
                <a class="navbar-item" href="/tags">Tags</a>
                
                <a class="navbar-item" href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="검색" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/categories">카테고리</a></li>
            
            <li class="is-active"><a href="#" aria-current="page">Programming</a></li>
        </ul>
        </nav>
    </div>
</div>

    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-29T17:10:32.000Z">2017-01-30</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    28분 읽기 (대략 4235 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/30/JavaScript/complete-guide-to-javascript-chapter-9/">자바스크립트 완벽가이드 9장 (클래스와 모듈)</a>
            
        </h1>
        <div class="content">
            <p><strong>자바스크립트에서 <code>클래스</code>는 프로토타입 기반의 상속 메커니즘을 기반으로 하고있다.</strong> 두 객체가 같은 프로토타입 객체로부터 프로퍼티를 상속받았다면, 둘은 같은 클래스의 인스턴스다. 자바스크립트의 클래스와 프로토타입 기반 상속 메커니즘은 자바나 그와 비슷한 언어의 클래스 상속과는 상당히 다르다. 자바스크립트 클래스의 중요한 특징 중 하나는 동적으로 확장될 수 있다는 것이다. 클래스를 정의한 다는 말은 모듈화되고 재사용 가능한 코드를 작성한다는 뜻이다.</p>
<h2 id="91-클래스와-프로토타입"><a href="#9-1-클래스와-프로토타입" class="headerlink" title="9.1 클래스와 프로토타입"></a>9.1 클래스와 프로토타입</h2><p>자바스크립트의 클래스는 같은 프로토타입 객체로부터 프로퍼티를 상속받은 객체의 집합이다. 따라서 프로토타입 객체는 클래스의 핵심이다.</p>
<hr>
<h2 id="92-클래스와-생성자"><a href="#9-2-클래스와-생성자" class="headerlink" title="9.2 클래스와 생성자"></a>9.2 <span style="color:red">클래스와 생성자</span></h2><p><strong><code>생성자</code>는 새로 생성된 객체를 초기화하는 용도로 사용되는 함수다.</strong> 생성자는 <code>new</code> 키워드를 사용하여 호출한다. 생성자를 호출하면 자동으로 새로운 객체가 생성되고, 생성자 함수 내부에서 새로 생성된 객체를 사용하기 때문에, 생성자 함수는 새 객체의 상태를 초기화하는 데만 신경 쓰면 된다. 생성자 호출의 핵심적인 특징은 <strong>생성자의 prototype 프로퍼티가 새 객체의 프로토타입으로 사용</strong>된다는 것이다. 이는 한 생성자를 통해 생성된 모든 객체는 같은 객체를 상속하고, 따라서 같은 클래스의 멤버임을 뜻한다.<br>클래스와 생성자 함수의 이름은 대문자로 시작하는 것은 매우 일반적은 코딩 규칙이다. 일반 함수와 메서드는 소문자로 이름을 시작한다.<br>새 객체는 생성자 함수가 실행되기 전에 자동으로 생성되고, 생성자 함수 내에서 this 값으로 접근할 수 있다. 생성자는 그저 새 객체를 초기화하기만 하면 되고 생성된 객체를 반환할 필요도 없다. 생성자를 호출하면 새 객체는 자동으로 생성되고, 새 객체의 메서드로서 생성자 함수가 호출된 다음, 초기화가 완료된 새 객체가 반환된다. 생성자 호출이 일반적인 함수 호출과 크게 다른것이 생성자 이름의 첫 글자를 대문자로 하는 또 하나의 이유다. 생성자는 <code>new</code> 키워드를 사용하여 호출된다고 가정하기 때문에, 일반적인 함수 호출처럼 호출하면 보통 제대로 작동하지 않는다.</p>
<h4 id="921-생성자와-클래스-구별"><a href="#9-2-1-생성자와-클래스-구별" class="headerlink" title="9.2.1 생성자와 클래스 구별"></a><span style="color:red">9.2.1 생성자와 클래스 구별</span></h4><p>프로토타입 객체는 클래스를 구별할 때 핵심적인 역할을 한다. 두 객체는 같은 프로토타입 객체를 상속한 경우에만 같은 클래스의 인스턴스다. 새로 생성된 객체의 상태를 초기화하는 생성자 함수는 클래스 구별의 핵심이 아니다. 서로 다른 두 생성자 함수라도 같은 프로토타입 객체를 가리키는 prototype 프로퍼티를 가질 수 있다. 그러면 두 생성자는 같은 클래스의 인스턴스를 만드는데 사용될 수 있다.<br>생성자가 prototype 만큼 객체 구별에 핵심적인 역할을 하지는 않더라도, 생성자는 클래스를 대표하는 역할을 한다. 생성자는 객체가 어떤 클래스에 속한 것인지 검사할 때 <code>instanceof</code> 연산자와 같이 사용된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r <span class="keyword">instanceof</span> Rnage            <span class="comment">// r이 Range.prototype을 상속했다면 true를 반환한다.</span></span><br></pre></td></tr></table></figure></p>
<p>instanceof 연산자는 실제로 r이 Range 생성자에 의해 초기화되었는지를 검사하지는 않고, r이 Range.prototype을 상속하는지를 검사한다.</p>
<h4 id="922-constructor-프로퍼티"><a href="#9-2-2-constructor-프로퍼티" class="headerlink" title="9.2.2 constructor 프로퍼티"></a><span style="color:red">9.2.2 constructor 프로퍼티</span></h4><p>모든 자바스크립트 함수는 생성자로 사용될 수 있는데, 함수가 생성자로 호출되려면 <code>prototype 프로퍼티</code>가 있어야 한다. 따라서 모든 자바스크립트 함수에는 자동으로 prototype 프로퍼티가 설정된다. 이 prototype 프로퍼티의 값은 <code>constructor</code> 프로퍼티 하나만 가진 객체다. constructor 프로퍼티는 열거되지 않으며 constructor 프로퍼티의 값은 해당 함수 객체다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;      <span class="comment">// 함수 객체다.</span></span><br><span class="line"><span class="keyword">var</span> p = F.prototype;        <span class="comment">// F와 연관이 있는 프로토타입 객체다.</span></span><br><span class="line"><span class="keyword">var</span> c = p.constructor;      <span class="comment">// 프로토타입과 관련한 함수 객체다.</span></span><br><span class="line">c === F                     <span class="comment">// =&gt; true: 모든 함수에 대해 F.prototype.constructor==F이다.</span></span><br></pre></td></tr></table></figure></p>
<p>미리 정의된 프로토타입 객체가 있고 이 프로토타입 객체가 constructor 프로퍼티를 갖고 있다는 말은, 일반적으로 어떤 객체가 자기 자신의 생성자를 가리키는 constructor 프로퍼티 또한 상속하고 있음을 뜻한다.<br>별도로 정의한 프로토타입 객체에는 <code>constructor</code> 프로퍼티가 없다. 따라서 해당 클래스의 인스턴스에도 constructor 프로퍼티는 없을 것이다. 이 문제는 명시적으로 프로토타입 객체에 constructor 프로퍼티를 추가함으로써 해결한다. 일반적인 또 다른 기법은 constructor 프로퍼티가 미리 정의되어 있는 prototype 객체를 사용하는 것이다. 거기에 하나씩 메서드를 추가해가면 된다.</p>
<hr>
<h2 id="93-자바-스타일-클래스"><a href="#9-3-자바-스타일-클래스" class="headerlink" title="9.3 자바 스타일 클래스"></a><span style="color:red">9.3 자바 스타일 클래스</span></h2><p>자바스크립트가 자바와 다른 점 한가지는 <strong>함수가 값</strong>이라는 점이고, 따라서 <strong>메서드와 필드 사이에는 뚜렷한 구분이 없다.</strong> 프로퍼티 값이 함수라면 그 프로퍼티는 메서드이고, 함수가 아니라면 보통의 프로퍼티나 ‘필드’일 뿐이다.<br>자바스크립트가 자바 스타일의 클래스 멤버를 흉내 낼 수 있지만, 자바의 중요한 특징 중 자바스크립트가 지원하지 않는 것이 몇 가지 있다. 먼저 자바는 인스턴스 메서드 안에서 인스턴스 필드를 메서드의 지역 변수처럼 사용할 수 있고, this를 비롯한 어떤 접두사도 붙일 필요가 없다. 자바스크립트는 이를 지원하지 않지만, <strong>with문</strong>을 사용하여 비슷한 효과를 얻을 수 있다.(권장X) 자바에서는 final을 사용하여 상수 필드를 정의할 수 있다. 그리고 클래스 내부에서만 사용하고 외부에서 볼 수 없는 필드나 메서드는 <code>private</code>으로 정의할 수 있다. 자바스크립트에는 이런 키워드들이 없다. 따라서 힌트를 제공하는 표기 규칙을 사용한다.(값이 변경되면 안 되는 프로퍼티들은 이름이 대문자이고, 밑줄로 시작하는 이름의 프로퍼티는 클래스 외부에서 사용하면 안된다는 뜻이다.)<br>private 프로퍼티는 클로저의 지역 변수로 흉내 낼 수 있고, 상수 프로퍼티는 ECMAScript 5에서는 사용 가능하다.</p>
<hr>
<h2 id="94-클래스-확장하기"><a href="#9-4-클래스-확장하기" class="headerlink" title="9.4 클래스 확장하기"></a>9.4 클래스 확장하기</h2><p>자바스크립트의 프로토타입 기반 상속 메커니즘은 <code>동적</code>이다. 객체는 자신의 프로토타입에서 프로퍼티를 상속받는데, 심지어 이는 객체가 생성된 이후에 프로토타입이 변경되더라도 마찬가지다. 다시말해 자바스크립트 객체의 프로토타입에 메서드를 추가함으로써 간단히 자바스크립트 클래스를 확장할 수 있다는 뜻이다.<br>Object.prototype에도 메서드를 추가할 수 있고, 그러면 모든 객체에서 추가된 메서드를 사용할 수 있지만 이 프로퍼티는 모든 for/in 루프에서 열거될 것이기 때문에 권장하지 않는다.<br>호스트 환경(웹브라우저 같은)에서 정의된 클래스를 이러한 방식으로 확장할 수 있는지는 호스트 환경의 구현체마다 다르다. 이 때문에 클라이언트 측 프로그래밍에서 이러한 기법의 사용은 몹시 제한받는다.</p>
<hr>
<h2 id="95-클래스와-자료형"><a href="#9-5-클래스와-자료형" class="headerlink" title="9.5 클래스와 자료형"></a>9.5 클래스와 자료형</h2><h4 id="951-instanceof-연산자"><a href="#9-5-1-instanceof-연산자" class="headerlink" title="9.5.1 instanceof 연산자"></a>9.5.1 instanceof 연산자</h4><p>왼쪽 피연산자는 클래스를 판별하려는 객체이며, 오른쪽 피연산자는 생성자 함수여야 하는데, 이 생성자 함수의 이름이 곧 해당 클래스의 이름이다. 표현식 <strong>o instanceof c</strong>는 만약 o가 c.prototype을 상속한다면 true다.(상속은 직접적일 필요없고, 만약 o가 c.prototype을 상속한 어떤 객체를 상속한다해도 이 표현식은 true이다.)<br>instanceof 연산자는 생성자 함수를 요구하지만, 실제로 instanceof 연산자는 객체가 어떤 프로토타입을 상속했는지를 검사하여 객체를 생성하는 데 어떤 생성자를 사용했는지 테스트하지는 않는다. 만약 생성자 함수를 검사의 기준으로 삼고 싶다면, <code>isPrototype()</code> 메서드를 대신 사용할 수 있다.</p>
<h4 id="952-constructor-프로퍼티"><a href="#9-5-2-constructor-프로퍼티" class="headerlink" title="9.5.2 constructor 프로퍼티"></a>9.5.2 constructor 프로퍼티</h4><p>어떤 객체의 클래스를 구별하는 또 다른 방법은 constructor 프로퍼티를 사용하는 것이다. constructor 프로퍼티를 사용하는 이 기법은 instanceof와 같은 문제가 있으며 자바스크립트 객체 가운데는 constructor 프로퍼티가 없는 것도 있을 수 있다.</p>
<hr>
<h2 id="96-자바스크립트의-객체-지향-기법"><a href="#9-6-자바스크립트의-객체-지향-기법" class="headerlink" title="9.6 자바스크립트의 객체 지향 기법"></a>9.6 자바스크립트의 객체 지향 기법</h2><h4 id="963-표준-변환-메서드"><a href="#9-6-3-표준-변환-메서드" class="headerlink" title="9.6.3 표준 변환 메서드"></a><span style="color:red">9.6.3 표준 변환 메서드</span></h4><p>객체 자료형을 변환하는 데 사용되는 중요한 메서드들이 있고, 이 중 몇 가지 형 변환이 푤아할 때 자바스크립트 인터프리터에 의해 자동으로 호출된다. 작성한 클래스에 변환 메서드를 구현하지 않았다면, 이는 단순히 술수로 구현하지 않은 것이 아니라 의도적인 것이어야 한다.<br>먼저, 가장 중요한 메서드는 <code>toString()</code>이다. 이 메서드의 <strong>목적은 객체의 문자열 표현을 반환하는 것</strong>이다. 자바스크립트는 필요할 때 자동으로 이 메서드를 호출한다. 프로퍼티 이름 같이 문자열을 요구하는 곳에 객체를 사용했을 때 또는 문자열 결합을 위해 + 연산자를 사용했을 때 toString() 메서드가 호출된다. 만약 이 메서드를 구현하지 않으면, 클래스는 Object.prototype의 기본 구현을 상속할 것이고, 그 기본 구현 메서드는 쓸모 없는 문자열 <strong>“[object Object]”</strong>를 반환할 것이다.<br>다음 메서드는 <code>valueOf()</code>이다. 이 메서드는 <strong>객체를 원시 값으로 변환</strong>한다. 예를 들면, valueOf() 메서드는 객체가 숫자 컨텍스트에서 산술 연산자(+ 제외)나 비교 연산자와 함께 사용될 때 자동으로 호출된다. 객체 대부분은 원시 값으로 변환할 필요가 없으므로, 이 메서드를 정의하지 않는다.<br>다음 메서드는 <code>toJson()</code>이고 JSON.stringify()에 의해 자동으로 호출된다. JSON 형식은 데이터 구조를 직렬화하는데 사용되고 자바스크립트 원시 값, 배열, 일반 객체를 처리할 수 있다. 직렬화 할 때 객체의 프로토타입과 생성자는 무시된다.</p>
<h4 id="964-비교-메서드"><a href="#9-6-4-비교-메서드" class="headerlink" title="9.6.4 비교 메서드"></a><span style="color:red">9.6.4 비교 메서드</span></h4><p>자바스크립트의 <strong>동치 연산자들은 객체를 비교할 때, 값이 아니라 참조를 사용한다.</strong> 즉, 주어진 두 참조가 같은 객체를 가리키고 있는지를 본다. 만약 어떤 클래스를 정의하고 이 클래스의 인스턴스를 비교하려면 비교하는 데 사용할 메서드를 정의해야 한다.<br>인스턴스를 동등 비교하려면, <code>equals()</code>라는 인스턴스 메서드를 정의해야 한다. equals() 메서드는 하나의 인자를 받고, 전달받은 인자와 equals 메서드를 가진 객체가 같다면 true를 반환한다. 클래스 컨텍스트상에서 ‘같다’라는 것이 어떤 의미인지는 구현에 달려있다.<br>객체를 어떤 순서에 따라 비교하는 것도 유용하다. 어떤 클래스의 한 인스턴스가 다른 인스턴스보다 ‘작다’ 또는 ‘크다’라고 말할 수 있게된다. 만약 &lt;와 &lt;=같은 관계 연산자에 객체를 사용하면 자바스크립트는 먼저 해당 객체의 <code>valueOf()</code> 메서드를 호출하고, 이 메서드가 원시 값을 반환하면 값을 비교한다. 그러나 대다수 클래스에는 valueOf() 메서드가 없다. 만약 valueOf() 메서드가 없는 객체들을 명시적으로 선택한 순서에 따라 비교하려면, <code>compareTo()</code> 메서드를 정의해야 한다.<br>compareTo() 메서드는 하나의 인자를 받고, 메서드 호출 대상 객체와 인자를 비교한다. 만약 this 객체가 인자 객체보다 작으면 compareTo()는 0보다 작은 값을 반환해야 하며, this 객체가 인자 객체보다 크면 0보다 큰 값을 반환해야 한다. 만약 두 객체가 같으면 을 반환해야 한다. 가장 좋은 방법은 equals() 메서드와 compareTo() 메서드를 일관성 있게 작성하는 것이다.<br>클래스에 compareTo() 메서드를 정의하는 한 가지 이유는 해당 클래스의 인스턴스들로 구성된 배열을 정렬하기 위함이다. <code>Array.sort()</code> 메서드는 추가 인자로 인스턴스를 비교하는 함수를 받는데, 이 비교 함수는 compareTo() 메서드와 <strong>똑같은 반환 값 규칙을 사용</strong>한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ranges.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a.compareTo(b); &#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="966-private-상태"><a href="#9-6-6-private-상태" class="headerlink" title="9.6.6 private 상태"></a><span style="color:red">9.6.6 private 상태</span></h4><p>인스턴스를 생성할 때, 생성자 호출의 클로저에 포착된 변수(혹은 인자)를 사용하면 private 인스턴스 필드를 흉내 낼 수 있다. 그러면 생성자 내부에서 함수들을 정의하고, 이 함수들을 새로 생성한 객체의 프로퍼티로 할당해야 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 예제) 시작점과 끝점에 대해 약한 캡슐화가 적용된 Range 클래스</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from , to</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 객체의 프로퍼티로 from, to를 저장하지 말 것.</span></span><br><span class="line">    <span class="comment">// 대신에 시작점과 끝점을 반환하는 접근자 함수를 정의한다.</span></span><br><span class="line">    <span class="comment">// 인자로 넘어온 from, to 값은 클로저에 저장된다.</span></span><br><span class="line">    <span class="keyword">this</span>.from = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">from</span>; &#125;</span><br><span class="line">    <span class="keyword">this</span>.to = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> to; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 프로토타입의 메서드들은 생성자에 인자로 전달된 from, to를 직접 볼 수 없다.</span></span><br><span class="line">    <span class="comment">// 프로토타입의 메서드들은 다른 모든 것과 마찬가지로 접근자 메서드를 호출해야 한다.</span></span><br><span class="line">    Range.prototype = &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: Range,</span><br><span class="line">        includes: function(x) &#123; <span class="keyword">return</span> <span class="keyword">this</span>.from() &lt;= x &amp;&amp; x &lt;= <span class="keyword">this</span>.to(); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>이러한 캡슐화 기법에는 <strong>오버헤드</strong>가 있다. 상태를 캡슐화하도록 클로저를 사용하는 클래스는 그렇지 않은 클래스보다 확실히 느리고 크다.</p>
<hr>
<h2 id="97-서브클래스"><a href="#9-7-서브클래스" class="headerlink" title="9.7 서브클래스"></a><span style="color:red">9.7 서브클래스</span></h2><p>객체 지향 프로그래밍에서 클래스 B는 다른 클래스 A를 <code>확장(extend)</code>하거나 클래스 A의 하위클래스가 될 수 있다. 이런 경우, 클래스 A를 <strong>슈퍼클래스</strong>라 하고 클래스 B를 <strong>서브클래스</strong>라고 한다. 클래스 B의 인스턴스는 클래스 A의 모든 인스턴스 메서드를 상속한다. 클래스 B의 메서드가 클래스 A의 메서드를 재정의했을 때, 클래스 B의 재정의된 메서드에서 클래스 A의 원래 메서드를 호출할 수가 있는데 이를 <code>메서드 체이닝</code>이라고 한다. 비슷하게 서브클래스의 생성자 B()가 슈퍼클래스의 생성자 A()를 호출할 필요가 있는데, 이는 <code>생성자 체이닝</code>이라고 한다.</p>
<blockquote>
<p>이하 내용은 추후에 업데이트 예정… 다른 부분보다 확실히 이해가 많이 필요한 부분이라 몇 번 더 읽어봐야 할 것 같다.</p>
</blockquote>
<p><br><br><strong>출처 : <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10338797" rel="external nofollow noopener noreferrer" target="_blank">“JavaScript: The Definitive Guide, by David Flanagan (O’Reilly). Copyright 2011 David Flanagan, 978-0-596-80552-4”</a></strong></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-27T17:10:32.000Z">2017-01-28</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    42분 읽기 (대략 6318 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/28/JavaScript/complete-guide-to-javascript-chapter-6/">자바스크립트 완벽가이드 6장 (객체)</a>
            
        </h1>
        <div class="content">
            <p>자바스크립트의 기본 데이터 타입은 <strong>객체</strong>다. 객체는 일종의 복합체로, 여러 값(원시 타입, 다른 객체)들을 묶어 이름으로 저장하고, 값을 가져올 수 있다. 객체는 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합이다. 자바스크립트 객체는 객체가 가진 고유 프로퍼티를 유지하는 것 외에 <strong>‘프로토타입’</strong>이라고 하는 다른 객체의 프로퍼티를 상속 받는다. 객체의 메서드들은 일반적으로 상속받은 프로퍼티이고, 이를 <strong><code>&#39;프로토타입 상속&#39;</code></strong>이라고 한다. 프로토타입 상속은 자바스크립트의 핵심적 특징이다.<br><br><strong>자바스크립트 객체는 프로퍼티를 동적으로 추가하고 제거할 수 있기 때문에 동적이지만 자바스크립트의 객체는 정적 객체를 흉내 낼 수도 있고, 정적 타입 언어에서의 ‘구조체’처럼 사용할 수도 있다.</strong><br><br><strong>자바스크립트에서는 문자열(string)과 숫자(number), true/false와 null/undefined를 제외한 나머지는 객체다. 비록 문자열과 숫자, 불리언 값은 객체는 아니지만 변경 불가능한 객체(Wrapper 객체)처럼 동작한다.</strong><br><br>객체의 각 프로퍼티는 <strong>‘프로퍼티 속성’</strong>(쓰기, 열거, 설정) 이라고 하는 연관된 값을 갖는다.<br><br>프로퍼티뿐 아니라, 모든 개체는 세 가지의 속성을 갖는다.</p>
<ul>
<li><strong>prototype</strong>은 상속받은 프로퍼티들을 가진 객체를 참조한다.</li>
<li><strong>class</strong>는 객체의 자료형(타입)을 특정짓는 문자열이다.</li>
<li><strong>extensible 속성</strong>(ECMAScript 5)은 객체에 새 프로퍼티를 추가할 수 있는지를 결정한다.</li>
</ul>
<h4 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h4><ul>
<li><strong>세 부류의 자바스크립트 객체</strong><ul>
<li><strong>‘네이티브 객체’</strong>는 ECMAScript 명세에 정의된 객체 또는 그 객체의 클래스다. Array, Function, Date, 정규 표현식들은 전부 네이티브 객체다.</li>
<li><strong>‘호스트 객체’</strong>는 브라우저와 같이 자바스크립트 인터프리터가 내장된 호스트 환경에 정의된 객체다.</li>
<li><strong>‘사용자 정의 객체’</strong>는 자바스크립트 코드의 실행으로 생성된 객체다.</li>
</ul>
</li>
<li><strong>두 종류의 프로퍼티</strong><ul>
<li><strong>‘고유 프로퍼티’</strong>는 객체에 직접 정의된 프로퍼티다.</li>
<li><strong>‘상속받은 프로퍼티’</strong>는 객체의 프로토타입 객체가 정의한 프로퍼티를 말한다.</li>
</ul>
</li>
</ul>
<h2 id="61-객체-생성하기"><a href="#6-1-객체-생성하기" class="headerlink" title="6.1 객체 생성하기"></a>6.1 객체 생성하기</h2><p>객체 리터럴을 통해 만들 수도 있고, new 키워드를 사용해 만들 수도 있으며, ECMAScript 5의 Object.create() 함수를 통해서도 생성할 수도 있다.</p>
<h4 id="611-객체-리터럴"><a href="#6-1-1-객체-리터럴" class="headerlink" title="6.1.1 객체 리터럴"></a>6.1.1 객체 리터럴</h4><p><code>객체 리터럴</code>은 평가될 때마다 새로운 객체를 생성하고 초기화하는 표현식이다. 각 프로퍼티의 값 또한 리터럴이 평가될 때마다 새롭게 계산된다. 따라서 하나의 객체 리터럴은 수많은 객체를 만들 수 있다. 객체 리터럴이 반복적으로 호출되는 함수 내부의 루프 몸체에 있는 경우, 매 순간 생기는 객체의 프로퍼티 값들은 서로 다를 것이다.</p>
<h4 id="612-new를-사용해-객체-생성하기"><a href="#6-1-2-new를-사용해-객체-생성하기" class="headerlink" title="6.1.2 new를 사용해 객체 생성하기"></a>6.1.2 new를 사용해 객체 생성하기</h4><p><code>new 연산자</code>는 객체를 만들고, 초기화한다. new 키워드 다음에는 반드시 함수 호출문이 와야한다. 이때 호출되는 함수를 <strong>생성자(constructor)</strong>라고 한다. 새로 생성된 객체를 초기화하는 역할을 한다. 코어 자바스크립트는 기본 타입에 대한 생성자를 내장하고 있다.</p>
<h4 id="613-프로토타입"><a href="#6-1-3-프로토타입" class="headerlink" title="6.1.3 프로토타입"></a><span style="color:red">6.1.3 프로토타입</span></h4><p>자바스크립트의 모든 객체는 또 다른 자바스크립트 객체와 연관되어 있다. 이 두번째 객체는 <code>프로토타입(prototype)</code>으로 알려져있고, 이때 객체는 프로토타입으로부터 프로퍼티들을 상속받는다. 객체 리터럴로 생성된 모든 객체는 프로토타입 객체가 같으며, 자바스크립트 코드에서 이 <strong>프로토타입 객체는 Object.prototype으로 참조할 수 있다.</strong><br>new 키워드를 사용해 생성자를 호출하면, <strong>생성자 함수의 프로토타입이 생성된 객체의 프로토타입이된다.</strong> 따라서 new Object()로 생성된 객체는 {}로 생성된 객체와 마찬가지로 Object.prototype를 상속받는다. 마찬가지로, new Array()로 생성된 객체는 Array.prototype을 객체의 프로토타입으로 사용하고, new Date()로 생성된 객체는 Date.prototype을 객체의 프로토타입으로 사용한다.</p>
<p><strong>모든 내장 생성자는 (그리고 대부분의 사용자 정의 생성자는) Object.prototype을 상속하는 객체를 프로토타입으로 갖는다.</strong> 예를 들어, Date.prototype은 Object.prototype의 프로퍼티들을 상속받는다. 따라서 new Date()를 통해 생성한 Date 객체는 Date.prototype과 Object.prototype으로부터 프로퍼티를 상속받는다. 이처럼 프로토타입 객체들이 연결된 것을 <strong><code>&#39;프로토타입 체인&#39;</code></strong>이라고 한다.</p>
<h4 id="614-objectcreate"><a href="#6-1-4-Object-create" class="headerlink" title="6.1.4 Object.create()"></a>6.1.4 Object.create()</h4><p>ECMAScript 5는 객체를 생성하는 <code>Object.create()</code> 메서드를 지원한다. 이 메서드의 첫 번째 인자가 프로토타입 객체다. Object.create()는 새 객체의 프로퍼티 정보를 두 번째 인자로 받을 수 있는데, 이 인자는 생략할 수 있다.<br><br>Object.create()는 정적 함수로, 개별 객체를 통해 호출되는 메서드가 아니다. 함수를 사용하기 위해서는 단순히 프로토타입 객체를 넘기기만 하면 된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;);           <span class="comment">// o1은 x, y 프로퍼티를 상속받는다.</span></span><br></pre></td></tr></table></figure></p>
<p>프로토타입을 갖지 않는 새 객체를 만들기 위해서는 함수에 null을 전달하면 된다. 하지만 이 경우 새롭게 생성된 객체는 어떠한 객체도 상속받지 않기 때문에 toString() 메서드와 같은 기본적인 메서드조차 사용할 수 없다. 만약 {} 또는 new Object()가 만들어내는 것과 같은 일반적인 빈 객체를 만들고 싶다면, 함수에 Object.prototype을 전달한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);       <span class="comment">// o2은 &#123;&#125; 또는 new Object()와 같은 객체다.</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="62-프로퍼티-접근-및-설정"><a href="#6-2-프로퍼티-접근-및-설정" class="headerlink" title="6.2 프로퍼티 접근 및 설정"></a><span style="color:red">6.2 프로퍼티 접근 및 설정</span></h2><h4 id="621-연관-배열로서의-객체"><a href="#6-2-1-연관-배열로서의-객체" class="headerlink" title="6.2.1 연관 배열로서의 객체"></a><span style="color:red">6.2.1 연관 배열로서의 객체</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object[<span class="string">"property"</span>]</span><br></pre></td></tr></table></figure>
<p>위와 같은 형태는 마치 문자열을 인덱스로 갖는 배열에 접근하는 형태와 유사하다. 이러한 형태의 배열을 <strong><code>연관 배열</code></strong>이라고 하고, 해시나 맵, 사전이라고도 한다. <strong>모든 자바스크립트 객체는 연관 배열이다.</strong><br><br>자바스크립트는 C나 C++, 자바에 비해 타입의 제약이 느슨하다. 프로그램은 객체 안에 수많은 프로퍼티들을 만들 수 있다. 하지만 마침표(.) 연산자를 사용해 객체의 프로퍼티에 접근할 때는 프로퍼티의 이름을 반드시 식별자로 표현해야 한다. 식별자는 자바스크립트 프로그램에 직접 타이핑해 넣은 이름이며 자료형이 없으므로 프로그램이 실행되는 도중이 변경할 수 없다.<br><br><strong>반면에 [] 연산자를 사용해 객체의 프로퍼티에 접근할 때는 프로퍼티의 이름을 문자열로 표현한다.</strong> 문자열은 자바스크립트의 자료형이므로 프로그램 실행중에 생성하고 조작할 수 있다. 따라서 다음의 코드가 가능하다. 다음의 코드는 customer 객체의 address0, address1, address2, address3 프로퍼티 값을 읽고, 읽은 값을 addr 변수에 차례대로 이어 붙인다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addr = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  addr += customer[<span class="string">"address"</span> + i] + <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="622-상속"><a href="#6-2-2-상속" class="headerlink" title="6.2.2 상속"></a><span style="color:red">6.2.2 상속</span></h4><p>자바스크립트 객체는 고유 프로퍼티들을 갖고 있고, 동시에 해당 객체의 프로토타입 객체로부터 여러 프로퍼티들을 상속받는다.<br><br>객체 o에서 프로퍼티 x를 찾는다고 했을때, 객체 o가 프로토타입 객체에 고유 프로퍼티 x가 없다면, 해당 프로토타입 객체에서 x를 찾는다. 만약 프로토타입 객체에 고유 프로퍼티 x가 없다면, 해당 프로토타입 객체가 역시 또 다른 프로토타입을 가진 경우, 그 또 다른 프로토타입 객체에서 프로퍼티 x를 찾는다. 이 작업은 프로퍼티 x를 찾거나 prototype이 null인 객체가 발견될 때까지 계속된다. 이처럼 <strong>객체의 prototype 속성은 프로퍼티가 계승되는 체인 또는 연결리스트를 생성한다.</strong><br><br>다음은 객체 o의 프로퍼티 x에 값을 설정하는 경우이다. 객체 o가 상속받지 않은 고유 프로퍼티 x를 갖고 있는 경우에는 기존의 프로퍼티 값을 단순히 바꿀 수 있다. 프로퍼티 x를 갖고 있지않은 경우에는 객체 o에 프로퍼티 x를 만든 후 값을 설정한다. 따라서 만약 객체 o가 프로퍼티 x를 상속받은 상태였다면, 기존에 상속받은 프로퍼티의 x값은 새로 설정되는 값에 의해 가려지게 된다.<br><br>객체의 프로퍼티에 값을 설정할 때는 해당 프로퍼티에 값을 설정할 수 있는지 알아보기 위해 프로토타입 체인을 검사한다. 예를 들어, 객체 o가 상속한 프로퍼티 x가 읽기 전용이라면 해당 프로퍼티에는 값을 설정할 수 없다. 하지만 값 설정이 허용된다면 원래 객체에 새로운 프로퍼티가 만들어지거나 그 값이 설정되며, 프로토타입 체인은 결코 변경되지 않는다. 프로퍼티를 질의 할 때는 상속이 동작하지만 설정할 때는 그렇지 않다는 것은 자바스크립트의 중요한 특징 중 하나다. <strong>계승된 프로퍼티를 선택적으로 재정의 할 수 있기 때문이다.</strong></p>
<h4 id="623-프로퍼티-접근-에러"><a href="#6-2-3-프로퍼티-접근-에러" class="headerlink" title="6.2.3 프로퍼티 접근 에러"></a><span style="color:red">6.2.3 프로퍼티 접근 에러</span></h4><p>프로퍼티 접근 표현식을 사용해도 항상 값을 얻을 수 있거나 값을 설정할 수 있는 것은 아니다.<br><br>존재하지 않는 프로퍼티에는 접근해도 에러가 발생하지 않는다. 존재하지 않는 프로퍼티는 <strong>undefined</strong>로 평가된다. 하지만 <strong>존재하지 않는 객체의 프로퍼티에 접근하려고 하면 에러가 발생한다.</strong> null과 undefined 값은 어떠한 프로퍼티도 갖지 않기 때문에 이들 값에 프로퍼티로 접근을 시도하면 에러가 발생한다.</p>
<hr>
<h2 id="63-프로퍼티-삭제하기"><a href="#6-3-프로퍼티-삭제하기" class="headerlink" title="6.3 프로퍼티 삭제하기"></a>6.3 프로퍼티 삭제하기</h2><p><code>delete</code> 연산자는 객체의 프로퍼티를 삭제한다. 이 연산자는 프로퍼티의 값을 지우는 것이 아니라 프로퍼티를 지운다. delete 연산자는 상속받은 프로퍼티가 아닌 <strong>고유 프로퍼티만</strong> 지울 수 있다. (상속받은 프로퍼티를 지우기 위해서는 해당 프로퍼티가 정의된 프로토타입 객체에서 지워야 하고, 삭제에 성공하면 프로토타입 객체를 상속한 모든 객체가 영향을 받는다.) <br></p>
<hr>
<h2 id="64-프로퍼티-검사하기"><a href="#6-4-프로퍼티-검사하기" class="headerlink" title="6.4 프로퍼티 검사하기"></a>6.4 프로퍼티 검사하기</h2><p><code>in</code> 연산자 왼쪽에는 프로퍼티 이름이 문자열로 와야하고 오른쪽에는 개체가 와야한다. 객체에 해당 프로퍼티가 존재하면 true가 반환된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;           <span class="comment">// 객체 o에 고유 프로퍼티 x가 존재하므로 true를 반환한다.</span></span><br><span class="line"><span class="string">"toString"</span> <span class="keyword">in</span> o;    <span class="comment">// 객체 o에 상속받은 프로퍼티 toString가 있기 때문에 true를 반환한다.</span></span><br></pre></td></tr></table></figure></p>
<p>객체의 <code>hasOwnProperty()</code> 메서드는 주어진 이름의 프로퍼티가 객체에 존재하는지 검사한다. 상속받은 프로퍼티의 경우는 false를 반환한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">o.hasOwnProperty(<span class="string">"x"</span>);           <span class="comment">// 객체 o에 고유 프로퍼티 x가 존재하므로 true를 반환한다.</span></span><br><span class="line">o.hasOwnProperty(<span class="string">"toString"</span>);    <span class="comment">// toString은 상속받은 프로퍼티이기 때문에 false를 반환한다.</span></span><br></pre></td></tr></table></figure></p>
<p><code>propertyIsEnumerable()</code> 메서드는 hasOwnProperty()보다 상세한 검사를 한다.<br><br>undefined가 아니지만 확인할 때는 in 연산자 대신 논리 연산자 !==를 사용하는 편이 훨씬 효과적이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">o.x !== <span class="literal">undefined</span>;          <span class="comment">// true: 객체 o에 프로퍼티 x가 존재한다.</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>;          <span class="comment">// false: 객체 o에 프로퍼티 y가 존재하지 않는다.</span></span><br></pre></td></tr></table></figure></p>
<p>in 연산까지 사용하면 객체에 프로퍼티가 존재하지 않는 경우와 객체에 프로퍼티가 존재하지만 값이 undefined인 경우를 구별할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="literal">undefined</span> &#125;    <span class="comment">// 프로퍼티가 분명히 존재하지만 값이 undefined다.</span></span><br><span class="line">o.x !== <span class="literal">undefined</span>           <span class="comment">// false: 프로퍼티가 존재하지만 값이 undefined다.</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>           <span class="comment">// false: 프로퍼티가 존재하지 않는다.하지만 값이 undefined다.</span></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o                    <span class="comment">// true: 프로퍼티가 존재한다.</span></span><br><span class="line"><span class="string">"y"</span> <span class="keyword">in</span> o                    <span class="comment">// false: 프로퍼티가 존재하지 않는다.</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="65-프로퍼티-열거하기"><a href="#6-5-프로퍼티-열거하기" class="headerlink" title="6.5 프로퍼티 열거하기"></a>6.5 프로퍼티 열거하기</h2><p>객체가 가진 모든 프로퍼티들을 순회하고 싶을 때는 보통 <code>for/in</code> 루프토 해결한다.<br>지정한 객체가 가진 고유 프로퍼티 또는 상속된 프로퍼티들 중 열거 가능한 프로퍼티들마다 for/in 루프의 몸체가 실행된다. 상속받은 내장 메서드는 열거할 수 없지만, 사용자가 임의로 추가한 프로퍼티들은 열거할 수 있다.(임의로 열거할 수 없도록 설정하는 함수를 사용할 수도 있다.)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">z</span>:<span class="number">3</span> &#125;               <span class="comment">// 열거할 수 있는 3개의 고유 프로퍼티</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">"toString"</span>);     <span class="comment">// =&gt; false: toString은 열거할 수 없는 프로퍼티</span></span><br><span class="line"><span class="keyword">for</span>(p <span class="keyword">in</span> o)                             <span class="comment">//  객체 o의 모든 프로퍼티에 대해</span></span><br><span class="line">  <span class="built_in">console</span>.log(p);                       <span class="comment">// 프로퍼티 이름을 출력. 결과는 x, y, z가 출력</span></span><br><span class="line">                                        <span class="comment">//  toString은 출력되지 않는다.</span></span><br></pre></td></tr></table></figure></p>
<p>for/in 루프 말고도 ECMAScript 5에는 프로퍼티 이름을 열거하는 두가지 함수가 더 있다.</p>
<ol>
<li><code>Object.keys()</code> : 객체가 가진 <strong>고유 프로퍼티</strong> 중에 열거할 수 있는 프로퍼티 이름을 배열에 담아 반환한다.</li>
<li><code>Object.getOwnPropertyNames()</code> : 프로퍼티를 열거하는 함수다. Object.keys()는 객체가 가진 ‘열거할 수 있는’ 고유 프로퍼티들을 배열에 담아 반환하지만, Object.getOwnPropertyNames()는 해당 객체가 가진 <strong>모든 고유 프로퍼티</strong>의 이름을 배열로 반환한다.</li>
</ol>
<hr>
<h2 id="66-프로퍼티-getter와-setter"><a href="#6-6-프로퍼티-Getter와-Setter" class="headerlink" title="6.6 프로퍼티 Getter와 Setter"></a>6.6 프로퍼티 Getter와 Setter</h2><p>ECMAScript 5에서 프로퍼티의 값은 <code>getter/setter</code> 메서드로 대채할 수 있다. getter/setter 메서드로 정의된 프로퍼티는 단순히 값을 갖는 ‘데이터 프로퍼티’와는 다른 <strong><code>&#39;접근자 프로퍼티&#39;</code></strong>라고 한다.<br><br>프로그램이 객체의 접근자 프로퍼티의 값에 접근하면, 자바스크립트 엔진은 <strong>getter</strong> 메서드를 아무런 인자없이 호출하고 이때 반환 값이 프로퍼티 접근 표현식의 값이 된다. 프로그램이 프로퍼티의 값을 변경하려고 하면, 자바스크립트 엔진은 <strong>setter</strong> 메서드를 호출한다. 이때 할당자(=)의 오른쪽에 있는 값을 setter 메서드의 인자로 전달한다. setter 메서드는 프로퍼티의 값을 ‘설정’하는 것을 담당하고, 그 반환값은 무시된다.<br><br>데이터 프로퍼티가 writable(쓰기) 속성을 갖는 반면, 접근자 프로퍼티는 쓰기 속성이 없다. 만약 프로퍼티가 getter/setter 메서드를 모두 갖고 있으면, 읽기/쓰기 모두 가능한 프로퍼티인 것이고, 프로퍼티가 getter 메서드만 갖고 있다면, 읽기 전용 프로퍼티인 것이다. 프로퍼티가 setter 메서드만 갖고 있으면 쓰기 전용 프로퍼티고, 이때 읽기를 시도하면 항상 undefined가 반환된다.<br>접근자 프로퍼티는 다음과 같이 확장된 객체 리터럴 문법을 사용하여 쉽게 정의할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="comment">// 데이터 프로퍼티</span></span><br><span class="line">  data_prop: value,</span><br><span class="line">  <span class="comment">// 한 쌍의 함수로 정의된 접근자 프로퍼티</span></span><br><span class="line">  get accessor_prop() &#123; <span class="comment">/* 함수 몸체 */</span> &#125;,</span><br><span class="line">  set accessor_prop(value) &#123; <span class="comment">/* 함수 몸체 */</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>접근자 프로퍼티는 그 이름이 프로퍼티 이름과 같은 하나 또는 두 개의 함수이며, 함수 정의에 사용되는 function 키워드 대신 get/set을 사용한다.</strong><br>자바스크립트는 getter/setter 함수를 객체의 메서드로서 호출한다. 이는 함수의 몸체 안에 사용된 this 키워드가 객체 자신을 가리킨다는 뜻이다. 접근자 프로퍼티는 데이터 프로퍼티와 마찬가지로 상속할 수 있다.</p>
<hr>
<h2 id="67-프로퍼티-속성"><a href="#6-7-프로퍼티-속성" class="headerlink" title="6.7 프로퍼티 속성"></a>6.7 프로퍼티 속성</h2><p>프로퍼티에는 프로퍼티로 할 수 있는 작업을 결정하는 세 가지 속성이 있다.</p>
<ul>
<li><strong>writable</strong> : 프로퍼티 값의 변경 가능 여부를 결정</li>
<li><strong>enumerable</strong> : 프로퍼티가 열거될 수 있는지 여부를 결정</li>
<li><strong>configurable</strong> : configurable 속성뿐 아니라 writable 속성과 enumerable 속성 값의 변경 가능 여부를 결정</li>
</ul>
<p>접근자 프로퍼티의 getter/setter 메서드를 프로퍼티가 가진 속성으로 다룬다면 접근자 프로퍼티의 네 가지 속성은 <strong>get, set, enumerable, configurable</strong>이다.<br>ECMAScript 5에서는 프로퍼티의 속성 값을 질의하고, 값을 설정할 수 있는 <code>프로퍼티 디스크립터</code>라는 객체를 제공한다. 이 객체의 프로퍼티 이름은 표현 대상 속성의 이름과 같다.</p>
<ul>
<li>데이터 프로퍼티의 프로퍼티 디스크립터 객체의 프로퍼티 : value, writable, enumerable, configurable</li>
<li>접근자 프로퍼티의 프로퍼티 디스크립터 객체의 프로퍼티 : get, set, enumerable, configurable<br>객체가 가진 특정 프로퍼티에 대한 프로퍼티 디스크립터 객체는 <code>Object.getOwnPropertyDescriptor()</code>를 통해 얻을 수 있다. (Object.getOwnPropertyDescriptor()는 객체의 고유 프로퍼티에서만 동작한다.)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; value: 1, writable: true, enumerable:true, configurable:true &#125;를 반환한다.</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125; <span class="string">"x"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>프로퍼티의 속성을 설정하거나 임의의 속성으로 새 프로퍼티를 만들기 위해서는 <code>Object.defineProperty()</code>를 호출한다. 함수의 인자로, 수정할 객체와 추가하거나 변경할 프로퍼티 이름, 프로퍼티의 디스크립터 객체를 넘긴다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, &#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">configurable</span>:<span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>6.1 절에 있었던 ECMAScript 5 메서드인 Object.create() 메서드의 첫 번째 인자로는 새로 생성할 객체의 프로토타입 객체이며, 두 번째 선택 인자는 Object.defineProperty() 의 두 번째 인자와 같다. 이 두 번째 인자는, 생성된 객체에 프로퍼티로 추가된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.getOwnPropertyDescriptor()와 Object.defineProperty() 메서드를 사용하여 프로퍼티가 가진 속성까지 복사하는 extend() 함수</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Object.prototype에 열거되지 않는 메서드 extend()를 추가한다.</span></span><br><span class="line"><span class="comment">// 이 메서드는 호출 시에 인자로 전달된 객체에서 프로퍼티들을 복사하여 객체를 확장한다.</span></span><br><span class="line"><span class="comment">// 단순 프로퍼티의 값뿐 아니라 모든 프로퍼티 속성을 복사한다.</span></span><br><span class="line"><span class="comment">// 인자로 넘긴 객체가 소유한 모든 고유 프로퍼티는 대상 객체에 같은 이름의</span></span><br><span class="line"><span class="comment">// 프로퍼티가 존재하지 않는 한 대상 객체에 복사된다.</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype,</span><br><span class="line">  <span class="string">"extend"</span>,       <span class="comment">// Object.prototype.extend를 정의한다.</span></span><br><span class="line">  &#123;</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,      <span class="comment">// 열거 불가능</span></span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Object.prototype.extend 메서드의 값은 함수다.</span></span><br><span class="line">      <span class="comment">// 열거되지 않는 프로퍼티들을 포함한 고유 프로퍼티에 대해</span></span><br><span class="line">      <span class="keyword">var</span> names = <span class="built_in">Object</span>.getOwnPropertyNames(o);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.length; i ++) &#123;</span><br><span class="line">        <span class="comment">// this 객체에 이미 같은 이름의 프로퍼티가 존재하면 건너뛴다.</span></span><br><span class="line">        <span class="keyword">if</span> (names[i] <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 객체 o의 프로퍼티 디스크립터를 가져온다.</span></span><br><span class="line">        <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, names[i]);</span><br><span class="line">        <span class="comment">// this 객체에 프로퍼티를 생성할 때 앞에서 가져온 디스크립터 객체를 사용한다.</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, name[i], desc);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="68-객체-속성"><a href="#6-8-객체-속성" class="headerlink" title="6.8 객체 속성"></a>6.8 객체 속성</h2><p>모든 객체는 <strong>prototype, class, extensible 속성</strong>을 갖고 있다.</p>
<h4 id="681-prototype-속성"><a href="#6-8-1-prototype-속성" class="headerlink" title="6.8.1 prototype 속성"></a>6.8.1 prototype 속성</h4><p>prototype 속성은 객체가 만들어지는 시점에 설정된다. <code>객체 리터럴</code>을 통해 만든 객체는 Object.prototype을 객체의 프로토타입으로 설정하고, <code>new</code>를 사용해 만든 객체는 생성자 함수의 prototype 프로퍼티값이 prototype이 된다. <code>Object.create()</code> 메서드로 만든 객체는 메서드의 첫 번째 인자가 프로토타입 속성의 값이 된다.<br>객체 A가 객체 B의 프로토타입(또는 프로토타입 체인의 일부)인지 알아보기 위해서는 <code>isPrototypeOf()</code> 메서드를 사용한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(p);</span><br><span class="line">p.isPrototypeOf(o)                    <span class="comment">// =&gt; true: 객체 o는 객체 p를 상속받는다.</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(p)     <span class="comment">// =&gt; true: 객체 p는 Object.prototype을 상속받는다.</span></span><br></pre></td></tr></table></figure></p>
<h4 id="682-class-속성"><a href="#6-8-2-class-속성" class="headerlink" title="6.8.2 class 속성"></a>6.8.2 class 속성</h4><p><strong>객체의 class 속성은 객체의 타입에 대한 정보를 담고 있는 문자열이다.</strong><br>Object.prototype으로부터 상속되는 기본(default) <code>toString()</code> 메서드는 객체의 타입을 아래 형태의 문자열로 반환한다.<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[object class]</span><br></pre></td></tr></table></figure></p>
<p>따라서 객체의 클래스 정보를 알아보기 위해서는 객체의 toString() 메서드를 호출하면 된다.</p>
<h4 id="683-extensible-속성"><a href="#6-8-3-extensible-속성" class="headerlink" title="6.8.3 extensible 속성"></a>6.8.3 extensible 속성</h4><p><strong>객체의 extensible 속성은 객체에 새 프로퍼티를 추가할 수 있는지 여부를 결정한다.</strong> extensible 속성의 목적은 ‘잠겨있는’ 객체의 상태를 고정하고, 외부에서 변경하는 것을 막는 것이다. ECMAScript 5에서는 모든 내장 객체와 사용자 정의 객체는 확장할 수 없게 바뀌지 않는한 확장 가능하고, 호스트 객체의 확장성은 구현체에 따라 다르다.<br>확장할 수 있는 객체인지 알아보려면 <code>object.isExtensible()</code> 함수에 해당 객체를 인자로 넘긴다. 객체를 확장할 수 없도록 하려면, <code>Object.preventExtensions()</code>에 해당 객체를 인자로 넘긴다. 해당함수를 사용하면 전 상태로 돌아갈 수 없다. 또한 extensible 속성 값이 false인 객체라도, 프로토타입에 새 프로퍼티를 추가하면, 추가된 프로퍼티는 해당 객체에 상속된다.</p>
<hr>
<h2 id="69-객체-직렬화하기"><a href="#6-9-객체-직렬화하기" class="headerlink" title="6.9 객체 직렬화하기"></a><span style="color:red">6.9 객체 직렬화하기</span></h2><p><strong>객체 직렬화는 객체의 상태를 문자열로 변환하는 과정을 말한다.</strong> ECMAScript 5는 자바스크립트 객체를 직렬화하는 <code>JSON.stringify()</code> 메서드와 직렬화한 문자열을 객체로 복원하는 <code>JSON.parse()</code> 메서드를 지원한다. 이 두 함수는 JSON 데이터 교환 형식을 사용한다. <strong>JSON</strong>은 ‘JavaScript Object Notation’의 줄임 표현이다.<br>JSON 문법은 자바스크립트 문법의 부분 집합이기 때문에, 자바스크립트의 모든 값을 표현할 수는 없다. Function, RegExp, Error 객체와 undefined 값은 직렬화하거나 복원할 수 없다. <strong>JSON.stringify() 메서드는 객체가 가진 열거 가능한 고유 프로퍼티만 직렬화한다.</strong></p>
<hr>
<h2 id="610-객체-메서드"><a href="#6-10-객체-메서드" class="headerlink" title="6.10 객체 메서드"></a><span style="color:red">6.10 객체 메서드</span></h2><p>모든 자바스크립트 객체는 <strong>Object.prototype</strong>의 프로퍼티를 상속받는다. 상속된 프로퍼티들은 대부분 메서드이고, 어느 객체에서도 사용할 수 있기 때문에 주요 메서드라고 할 수 있다.</p>
<h4 id="6101-tostring-메서드"><a href="#6-10-1-toString-메서드" class="headerlink" title="6.10.1 toString() 메서드"></a><span style="color:red">6.10.1 toString() 메서드<span></span></span></h4><p><code>toString()</code> 메서드는 어떠한 인자도 받지 않고, <strong>호출 대상 객체의 값을 어떠한 방식으로든 문자열로 만들어서 반환한다.</strong> 자바스크립트는 객체를 문자열로 변환해야 할 때 항상 toString() 메서드를 사용한다.</p>
<h4 id="6103-tojson-메서드"><a href="#6-10-3-toJSON-메서드" class="headerlink" title="6.10.3 toJSON() 메서드"></a><span style="color:red">6.10.3 toJSON() 메서드<span></span></span></h4><p>Object.prototype에는 toJSON() 메서드가 정의되어 있지 않다. 하지만 JSON.stringify() 메서드는, 직렬화할 객체에 toJSON() 메서드가 있는지 찾고, 만약 있다면, toJSON() 메서드가 호출되고 그 결과 값이 원래 객체 대신 직렬화된다.</p>
<h4 id="6104-vluaeof-메서드"><a href="#6-10-4-vluaeOf-메서드" class="headerlink" title="6.10.4 vluaeOf() 메서드"></a><span style="color:red">6.10.4 vluaeOf() 메서드<span></span></span></h4><p>valueOf() 메서드는 toString() 메서드와 매우 비슷하다. 이 메서드는 <strong>객체가 원시 타입 값을 필요로 하는 문맥 안에서 사용될 때</strong>, 자바스크립트는 valueOf() 메서드를 자동으로 호출한다.</p>
<p><br><br><strong>출처 : <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10338797" rel="external nofollow noopener noreferrer" target="_blank">“JavaScript: The Definitive Guide, by David Flanagan (O’Reilly). Copyright 2011 David Flanagan, 978-0-596-80552-4”</a></strong></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-27T17:10:32.000Z">2017-01-28</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    38분 읽기 (대략 5708 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/28/JavaScript/complete-guide-to-javascript-chapter-7/">자바스크립트 완벽가이드 7장 (배열)</a>
            
        </h1>
        <div class="content">
            <p>자바스크립트의 배열은 타입이 고정되어 있지 않다. 같은 배열에 있는 원소 값의 타입은 서로 다를 수 있다. 배열의 원소는 객체가 될 수도 있고, 또 다른 배열이 될 수도 있다. 자바스크립트 배열은 <strong>동적</strong>이다. 배열의 크기가 필요에 따라 커지거나 작아질 수 있다. 배열을 생성하거나, 크기가 변경되어 다시 할당을 할 때도 배열 크기를 선언할 필요가 없다. 자바스크립트 배열은 밀집도가 높지 않고, 각 원소의 인덱스가 연속적이지 않아도 되고, 원소들 사이에 빈자리가 있어도 된다. 자바스크립트 배열에는 length 프로퍼티가 존재한다.<br><strong>자바스크립트 배열은 자바스크립트 객체의 특별한 형태이고, 배열의 인덱스는 프로퍼티 이름인데 정수인 것이다.</strong> 일반적으로 배열은 객체 프로퍼티를 통해 원소에 접근하는 것보다 <strong>정수 첨자</strong>를 통해 원소에 접근하는 것이 훨씬 빠르도록 최적화 되어 있다.<br>배열은 <code>Array.prototype</code>의 프로퍼티들을 상속받는다.</p>
<h2 id="71-배열-만들기"><a href="#7-1-배열-만들기" class="headerlink" title="7.1 배열 만들기"></a>7.1 배열 만들기</h2><p>배열을 만드는 가장 쉬운 방법은 <code>배열 리터럴</code>을 사용하는 것이다. 배열 리터럴은 대괄호([,])안에 배열의 원소를 쉼표(,)로 구분해 나열한 것이다.<br>만약 배열 리터럴은 객체 리터럴 또는 다른 배열 리터럴을 포함할 수 있다.  만약 배열 리터럴에서 빠진 부분이 있다면 해당 부분의 원소 값은 <strong>undefined</strong>가 된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> undefs = [,,];    <span class="comment">// 두 원소 모두 값은 undefined (배열 리터럴의 문법은 마지막 원소 다음에 쉼표 추가 가능)</span></span><br></pre></td></tr></table></figure></p>
<p>배열을 만드는 또 다른 방법은 <code>Array() 생성자</code>를 이용하는 것이다. 생성자는 3가지 방법으로 호출 가능하다.<br>– <strong>인자 없이 호출</strong><br>빈 배열을 생성하고 생성된 배열은 배열 리터럴 []과 동일하다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure></p>
<p>– <strong>배열의 길이를 의미하는 숫자를 인자로 주어 호출</strong><br>배열에 저장될 원소의 크기를 알고, 미리 공간을 할당할 때 사용한다. 배열에는 어떠한 값도 저장되지 않고, 배열의 인덱스 프로퍼티 값(“0”, “1” …)도 존재하지 않는다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>– <strong>두 개 이상의 원소, 또는 숫자가 아닌 원소 값 하나를 명시적으로 지정</strong><br>생성자의 인자 값들이 배열의 원소가 된다. 리터럴을 사용하는편이 훨씬 더 간단하다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">"test"</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="72-배열의-원소-읽고-쓰기"><a href="#7-2-배열의-원소-읽고-쓰기" class="headerlink" title="7.2 배열의 원소 읽고 쓰기"></a>7.2 배열의 원소 읽고 쓰기</h2><p>배열의 각 원소에 접근할 때에는 <code>[] 연산자</code>를 사용한다. <strong>배열은 객체의 특별한 종류이다.</strong> 배열의 [] 구문은 객체 프로퍼티 접근 때 쓰는 []와 똑같이 동작한다. 자바스크립트는 사용자가 명시한 숫자 배열 인덱스를 문자열 형태로 바꿔서 프로퍼티 이름으로 사용한다.<br><strong>배열의 인덱스와 객체 프로퍼티 이름을 올바르게 구별할 줄 알면 좋다.</strong> 모든 인덱스 값은 프로퍼티 이름이지만, 프로퍼티 이름은 0과 2의32승-1 사이의 정수여야만 인덱스가 될 수 있다. 모든 배열은 객체이므로, 어떤 이름의 프로퍼티라도 자유롭게 만들 수 있다. 하지만 배열에는, 프로퍼티 가운데 인덱스인 것들을 사용하면 <code>length</code> 프로퍼티의 값이 자동으로 갱신되는 특별한 기능도 갖추어져 있다.(배열이 일반 객체와 다른 점은 속성 이름으로 2의32승보다 작은 양수를 사용할 때, 자동으로 length 프로퍼티의 값을 바꾼다는 것이다.) 배열 첨자로 양의 정수가 담긴 문자열을 사용하면, 일반적으로 프로퍼티가 아닌 배열 인덱스로 쓰인다. (소수점 아래가 없는 부동 소수점 값도 마찬가지) 반면에 음수나, 정수 아닌 수들을 사용하면 숫자는 문자열로 변환되고, 변환된 문자열은 배열 객체의 프로퍼티 이름으로 사용된다.<br>객체에 존재하지 않는 프로퍼티 이름을 질의하면, 에러가 발생하지 않고 단순히 <strong>undefined</strong>값이 반환된다. 이러한 성질은 배열에도 적용된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="literal">true</span>, <span class="literal">false</span>];    <span class="comment">// 두 개의 원소를 가진 배열을 생성한다.</span></span><br><span class="line">a[<span class="number">2</span>]                  <span class="comment">// =&gt; undefined. 해당 인덱스에 원소가 없어서.</span></span><br><span class="line">a[<span class="number">-1</span>]                 <span class="comment">// =&gt; undefined. '-1'이라는 속성 이름에 해당하는 값이 없어서.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>모든 배열은 객체다.</strong> 따라서 배열은 객체의 프로토타입으로부터 원소들을 상속 받을 수 있다.</p>
<hr>
<h2 id="73-희소배열"><a href="#7-3-희소배열" class="headerlink" title="7.3 희소배열"></a>7.3 희소배열</h2><p><code>희소배열</code>은 배열에 속한 원소의 위치가 연속적이지 않은 배열을 말한다. 보통, 배열의 length 프로퍼티는 배열에 속한 원소의 개수를 의미한다. 그러나 희소배열의 경우, length 프로퍼티의 값은 원소의 개수보다 항상 크다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);      <span class="comment">// 원소가 없는 배열이지만 a.length의 값은 5다.</span></span><br><span class="line">a = [?];               <span class="comment">// length 값이 0인 빈 배열을 생성한다.</span></span><br><span class="line">a[<span class="number">1000</span>] = <span class="number">0</span>;           <span class="comment">// 하나의 원소를 할당했지만, length 값은 1001이 된다.</span></span><br></pre></td></tr></table></figure></p>
<p>희소배열은 보통배열보다 일반적으로 느리고, 메모리를 많이 사용할 뿐 아니라, 원소를 찾는데 걸리는 시간이 일반 객체의 속성 값을 찾는 시간만큼 오래 걸린다.<br>배열 리터럴 사용 시 값을 명시하지 않는 방법으로는 희소배열을 만들 수 없다. 해당 원소의 값이 <strong>undefined</strong>가 되기 때문이다. 이는 배열에 원소가 아예 존재하지 않는 것과는 다르다. in 연산자를 사용하면 두 경우의 차이점을 알 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = [,,,];          <span class="comment">// 세 개의 원소가 undefined인 배열</span></span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);   <span class="comment">// 원소가 존재하지 않는 배열</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a1                  <span class="comment">// =&gt; true: a1에는 0번 인덱스 위치에 원소가 존재한다.</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a2                  <span class="comment">// =&gt; false: a2에는 0번 인덱스 위치에 원소가 존재하지 않는다.</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="74-배열의-길이"><a href="#7-4-배열의-길이" class="headerlink" title="7.4 배열의 길이"></a>7.4 배열의 길이</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];    <span class="comment">// 다섯 개의 원소를 가진 배열</span></span><br><span class="line">a.length = <span class="number">3</span>;       <span class="comment">// length를 3으로 바꿨기 때문에 결과는 [1,2,3]</span></span><br><span class="line">a.length = <span class="number">0</span>;       <span class="comment">// length 값이 0이기 때문에 모든 element를 삭제, 결과는 []</span></span><br><span class="line">a.length = <span class="number">5</span>;       <span class="comment">// length 값은 5이지만, 원소가 없다. new Array(5)와 같은 결과</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="75-배열에-원소를-추가하거나-삭제하기"><a href="#7-5-배열에-원소를-추가하거나-삭제하기" class="headerlink" title="7.5 배열에 원소를 추가하거나 삭제하기"></a>7.5 배열에 원소를 추가하거나 삭제하기</h2><p>배열에 원소를 <strong>추가</strong>하는 방법</p>
<ul>
<li>배열의 새 인덱스에 값을 할당한다.</li>
<li>push() 메서드를 사용해 배열의 끝에 원소를 추가한다. (a[a.length]에 값을 할당하는것과 같다.)</li>
<li>unshift() 메서드를 사용하면 배열의 앞쪽에 원소를 추가할 수 있다.</li>
</ul>
<p>배열에 원소를 <strong>삭제</strong>하는 방법</p>
<ul>
<li>delete 연산자로 배열의 원소를 삭제할 수 있다. (배열의 length는 줄어들지 않는다.)</li>
<li>pop() 메서드를 사용해 배열의 앞에서 원소를 삭제한다.</li>
</ul>
<p>배열의 특정 원소를 지우는 것은, 해당 원소에 <strong>undefined</strong> 값을 할당하는 것과 의미가 비슷하다. 원소가 지워지더라도 생기는 공백을 다른 원소가 대신하지 않으며, 해당 배열은 희소배열이 된다.</p>
<hr>
<h2 id="76-배열-순회하기"><a href="#7-6-배열-순회하기" class="headerlink" title="7.6 배열 순회하기"></a>7.6 배열 순회하기</h2><p>ECMAScript 5에는 배열을 순회하는 다양한 메서드가 추가되었다. 사용자가 정의한 함수에 배열의 원소가 <strong>인덱스 순서</strong>대로 하나씩 넘어오도록 하여 배열을 순회하는 형태다. <code>forEach()</code> 메서드가 대표적이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sumOfSquares = <span class="number">0</span>;</span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)) </span>&#123;</span><br><span class="line">    sumOfSquares += x*x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>배열을 다룰 때 forEach() 같은 순회 메서드는 간단하고 강력한 함수형 프로그래밍 스타일을 사용할 수 있게 한다.</p>
<hr>
<h2 id="77-다차원-배열"><a href="#7-7-다차원-배열" class="headerlink" title="7.7 다차원 배열"></a>7.7 다차원 배열</h2><p>자바스크립트는 진정한 의미에서의 다차원 배열을 지원하지는 않는다. 그러나 배열의 배열을 사용해 다차원 배열을 흉내 낼 수 있다. 배열 내의 배열에 있는 원소에 접근하기 위해서는 단순히 [] 연산자를 두 번 사용하면 된다.</p>
<hr>
<h2 id="78-배열-메서드"><a href="#7-8-배열-메서드" class="headerlink" title="7.8 배열 메서드"></a><span style="color:red">7.8 배열 메서드</span></h2><h4 id="781-join"><a href="#7-8-1-join" class="headerlink" title="7.8.1 join()"></a><span style="color:red">7.8.1 join()</span></h4><p><code>Array.join()</code> 메서드는 배열의 모든 원소를 문자열로 변환하고, 변환한 문자들을 이어 붙인 결과를 반환한다. 결과로 반환되는 문자열에서 배열의 원소들을 구별하기 위해 <strong>구분자 문자열</strong>을 사용한다. 별도로 구분자 문자열을 지정하지 않으면 쉼표(,)가 기본 값으로 사용된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.join();                   <span class="comment">// =&gt; '1,2,3'</span></span><br><span class="line">a.join(<span class="string">" "</span>);                <span class="comment">// =&gt; '1 2 3'</span></span><br><span class="line">a.join(<span class="string">""</span>);                 <span class="comment">// =&gt; '123'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);     <span class="comment">// 길이가 10인 빈 배열</span></span><br><span class="line">b.join(<span class="string">'-'</span>)                <span class="comment">// =&gt; '---------': 아홉 개의 하이픈 문자열</span></span><br></pre></td></tr></table></figure></p>
<p>Array.join() 메서드는 String.split() 메서드와는 반대로 작동한다. <code>String.split()</code> 메서드는 문자열을 조각들로 분리하고, 이 조각들을 원소로 하는 배열을 생성한다.</p>
<h4 id="782-reverse"><a href="#7-8-2-reverse" class="headerlink" title="7.8.2 reverse()"></a><span style="color:red">7.8.2 reverse()</span></h4><p><code>Array.reverse()</code> 메서드는 배열의 원소 순서를 반대로 뒤집어 반환한다. 순서가 뒤바뀐 새로운 배열을 생성하는 것이 아니라, <strong>이미 존재하는</strong> 배열 안에서 원소들의 순서를 뒤바꾼다.</p>
<h4 id="783-sort"><a href="#7-8-3-sort" class="headerlink" title="7.8.3 sort()"></a><span style="color:red">7.8.3 sort()</span></h4><p><code>Array.sort()</code> 메서드는 배열 안의 원소들을 정렬하여 반환한다. sort() 메서드는 별도의 인자전달 없이 호출하면, 배열 안의 원소들을 알파벳순으로 정렬한다. 배열에 undefined 원소들이 존재하면, 이 원소들은 배열의 끝부분으로 정렬된다.<br>알파벳순이 아니라 다른 순서로 배열을 정려하려면, sort() 메서드의 전달 인자를 통해 비교 함수를 직접 명시해주어야 한다. 비교 함수는 전달인자를 두 개 받아서, 정렬된 배열에서 어떤 것이 먼저 나타나야 하는지 판단한다. <strong>만약 첫 번 째 인자가 두 번째보다 먼저 나타나야 한다면, 비교 함수는 0보다 작은 숫자를 반환해야 한다.</strong> 만약 두 값이 동등하다면 0을 반환해야 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">33</span>, <span class="number">4</span>, <span class="number">1111</span>, <span class="number">222</span>];</span><br><span class="line">a.sort();                     <span class="comment">// 알파벳순: 1111, 222, 33, 4</span></span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;       <span class="comment">// 번호순: 4, 33, 222, 1111</span></span><br><span class="line">    <span class="keyword">return</span> a-b;               <span class="comment">// 0보다 작은 값, 0, 또는 0보다 큰 값을 반환한다.</span></span><br><span class="line">&#125;);</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;<span class="keyword">return</span> b-a&#125;); <span class="comment">// 내림차순 정렬</span></span><br></pre></td></tr></table></figure></p>
<h4 id="784-concat"><a href="#7-8-4-concat" class="headerlink" title="7.8.4 concat()"></a><span style="color:red">7.8.4 concat()</span></h4><p><code>Array.concat()</code> 메서드는 기존 배열의 모든 원소에 concat() 메서드의 전달인자들을 추가한 <strong>새로운 배열을 반환</strong>한다. 전달인자로 배열을 전달하면, 이 배열안의 원소들을 꺼내어 반환하는 배열에 추가한다. 하지만 중첩 배열일 경우에는 중첩된 배열의 원소까지는 꺼내지 않는다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.concat(<span class="number">4</span>, <span class="number">5</span>);                   <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>, <span class="number">5</span>]);                 <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>]);         <span class="comment">// [1,2,3,4,5,6,7]</span></span><br><span class="line">a.concat(<span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]]);         <span class="comment">// [1,2,3,4,5, [6,7]]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="785-slice"><a href="#7-8-5-slice" class="headerlink" title="7.8.5 slice()"></a><span style="color:red">7.8.5 slice()</span></h4><p><code>Array.slice()</code> 메서드는 <strong>부분 배열을 반환</strong>한다. 부분 배열은 배열에서 잘라낸 원소들을 담은 <strong>새 배열</strong>이다. slice() 메서드는 전달인자를 두 개 받는데, 각 인자는 <strong>반환될 부분의 처음</strong>과 <strong>끝</strong>을 명시한다. 반환되는 배열은 첫 번째 전달인자가 지정하는 위치부터 두 번째 전달인자가 지정하는 위치 이전까지의 모든 원소를 포함한다. 만약 전달인자가 하나라면 그 위치에서 배열 끝까지의 모든 원소를 포함하는 부분 배열을 반환한다. 만약 전달인자가 음수라면, 배열의 마지막 원소에서부터의 상대적인 위치를 가리키는 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.slice(<span class="number">0</span>, <span class="number">3</span>);         <span class="comment">// [1,2,3]</span></span><br><span class="line">a.slice(<span class="number">3</span>);            <span class="comment">// [4,5]</span></span><br><span class="line">a.slice(<span class="number">1</span>, <span class="number">-1</span>);        <span class="comment">// [2,3,4]</span></span><br><span class="line">a.slice(<span class="number">-3</span>, <span class="number">-2</span>);       <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="786-splice"><a href="#7-8-6-splice" class="headerlink" title="7.8.6 splice()"></a><span style="color:red">7.8.6 splice()</span></h4><p><code>Array.splice()</code> 메서드는 배열의 원소를 삽입하거나 원소를 제거하려 할 때 범용적으로 사용하는 메서드다. splice() 메서드는 slice()나 concat() 메서드와는 달리 <strong>호출 대상 배열을 바로 수정</strong>한다.<br>splice()의 첫 번째 전달인자는 배열상에서 삽입 혹은 삭제 작업을 시작할 위치를 지정하고, 두 번째 전달인자는 배열에서 삭제할 원소의 개수를 지정한다. 두 번째 전달인자를 지정하지 않으면 첫 번째 전달인자로 지정한 배열의 시작 위치에서 마지막 원소까지 전부 삭제한다. splice()는 삭제한 배열을 반환하며, 만약 삭제된 원소가 하나도 없다면 빈 배열을 반환한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">a.splice(<span class="number">4</span>);       <span class="comment">// [5,6,7,8]을 반환, a는 이제 [1,2,3,4]</span></span><br><span class="line">a.splice(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">// [2, 3]을 반환, a는 이제 [1,4]</span></span><br><span class="line">a.splice(<span class="number">1</span>, <span class="number">1</span>);    <span class="comment">// [4]를 반환, a는 이제 [1]</span></span><br></pre></td></tr></table></figure></p>
<p>세 번째 전달인자부터는 배열에 새롭게 삽입할 원소들을 지정하는데 사용한다. 삽입 작업은 첫 번째 전달인자로 지정된 시작 위치부터 수행한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.splice(<span class="number">2</span>,<span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'b'</span>);    <span class="comment">// []를 반환, a는 이제 [1,2,'a','b',3,4,5]</span></span><br><span class="line">apsplice(<span class="number">2</span>,<span class="number">2</span>, [<span class="number">1</span>,<span class="number">2</span>], <span class="number">3</span>);    <span class="comment">// ['a', 'b']를 반환, a는 이제 [1,2,[1,2],3,3,4,5]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>concat() 메서드와 달리 splice() 메서드는 전달인자로 배열이 전달되면, 그 배열의 원소들을 꺼내어 삽입하지 않고 배열 그 자체를 삽입한다.</strong></p>
<h4 id="787-push와-pop"><a href="#7-8-7-push-와-pop" class="headerlink" title="7.8.7 push()와 pop()"></a><span style="color:red">7.8.7 push()와 pop()</span></h4><p>push()와 pop() 메서드를 사용하면 배열을 마치 스택처럼 조작할 수 있다. (FILO (선입후출) 스택 구현 가능)<br>push() 메서드는 하나 이상의 원소들을 배열의 끝 부분에 이어 붙이고, <strong>배열의 새로운 length 값을 반환</strong>한다<br>pop() 메서드는 배열의 마지막 원소를 제거하고 배열의 length 값을 감소시킨 후, <strong>배열에서 제거한 원소를 반환</strong>한다.</p>
<h4 id="788-unshift와-shift"><a href="#7-8-8-unshift-와-shift" class="headerlink" title="7.8.8 unshift()와 shift()"></a><span style="color:red">7.8.8 unshift()와 shift()</span></h4><p>push(), pop()과 매우 유사하게 동작하는데, 배열의 끝이 아니라 배열의 맨 앞에서 원소를 추가하고 제거한다.<br>unshift() 메서드는 하나 혹은 그 이상의 원소들을 배열의 맨 앞에 추가하고, 추가된 원소만큼 공간을 만들기 위해 기존 배열 원소들을 인덱스가 높은 방향으로 옮긴 후, 배열의 새로운 length 값을 반환한다.<br>shift() 메서드는 배열의 첫 번째 원소를 제거한 후, 배열에서 제거한 원소를 반환한다.</p>
<h4 id="789-tostring"><a href="#7-8-9-toString" class="headerlink" title="7.8.9 toString()"></a><span style="color:red">7.8.9 toString()</span></h4><p>배열의 toString() 메서드는 배열의 모든 원소를 문자열로 변환하고 이 문자열들을 쉼표(,)로 분리한 목록을 반환한다. 별도의 전달인자를 지정하지 않고 join() 메서드를 호출하면 toString()과 동일한 결과를 얻을 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString()             <span class="comment">// '1,2,3'</span></span><br><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>].toString()     <span class="comment">// 'a,b,c'</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, <span class="string">'c'</span>]].toString()       <span class="comment">// '1,2,c'</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="79-ecmascript-5-배열-메서드"><a href="#7-9-ECMAScript-5-배열-메서드" class="headerlink" title="7.9 ECMAScript 5 배열 메서드"></a><span style="color:red">7.9 ECMAScript 5 배열 메서드</span></h2><p>ECMAScript 5는 배열을 <strong>순회, 매핑, 필터링, 테스팅, 감소, 검색하기</strong>위한 아홉 가지 새로운 메서드를 정의한다.<br>대부분의 메서드들은 첫 번째 전달인자로 함수를 받는다. 이 함수는 배열의 각 원소마다 한 번씩 실행하거나 일부 원소들에 한해 실행된다. 만약 배열이 희소배열이라면, 빈 원소의 경우 함수를 호출하지 않는다. 대부분, 첫 번째 전달인자로 지정한 함수는 세 개의 전달인자를 갖고 호출되는데, 배열 원소의 값과 인덱스, 마지막으로 배열 그 자체다. 첫 인자로 함수를 받는 대부분의 ECMAScript 5의 배열 메서드들은 생략 가능한 두 번째 인자를 받는다. 두 번째 전달인자를 지정하면, 첫 번째 전달인자인 함수는 마치 두 번째 인자의 메서드인 것처럼 호출된다. 두 번째 인자는 첫 번째 전달인자인 함수 안에서 <strong>this 키워드의 값으로 사용</strong>된다. ECMAScript 5 배열 메서드는 호출 대상 배열을 수정하지 않는다. 메서드의 전달인자로 쓰인 함수 안에서는 배열을 수정할 수 있다.</p>
<h4 id="791-foreach"><a href="#7-9-1-forEach" class="headerlink" title="7.9.1 forEach()"></a><span style="color:red">7.9.1 forEach()</span></h4><p><code>forEach()</code> 메서드는 배열을 순회하는 메서드이다. 첫 번째 인자로 넘긴 함수를 각각의 원소를 대사응로 호출한다. forEach()는 첫 인자로 전달된 함수를 호출할 때 세가지 인자를 넘긴다. <strong>각 인자는 배열의 원소 값과, 원소의 인덱스 값, 그리고 배열 그 자체다.</strong><br>forEach() 메서드는 <strong>배열의 모든 원소가 순회되기 전에는 종료도지 않는다.</strong> 루프에서 사용하는  break문은 사용할 수 없다. 루프를 중간에 종료시키려면, 예외를 발생시켜야 하고, forEach()는 try 블록 안에서 호출되어야 한다.</p>
<h4 id="792-map"><a href="#7-9-2-map" class="headerlink" title="7.9.2 map()"></a><span style="color:red">7.9.2 map()</span></h4><p><code>map()</code> 메서드는 배열의 각 원소를 메서드의 첫 번째 전달인자로 지정한 함수에 전달하고, 해당 함수의 반환 값을 배열에 담아 반환한다.<br>map() 메서드에 전달한 함수는 forEach()에 전달한 함수와 동일한 형태로 호출되지만 map() 메서드에 인자로 전달된 함수는 반드시 값을 반환해야 한다. <strong>map() 메서드는 기존의 배열을 수정하지 않고, 새배열을 반환한다.</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">b = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x*x; &#125;); <span class="comment">// b는 [1, 4, 9]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="793-filter"><a href="#7-9-3-filter" class="headerlink" title="7.9.3 filter()"></a><span style="color:red">7.9.3 filter()</span></h4><p><code>filter()</code> 메서드는 배열의 일부분을 반환한다. 이 메서드에 전달하는 함수는 <strong>조건자 함수</strong>(항상 true 또는 false 값을 반환하는 함수)여야 한다. filter()의 조건 함수는 forEach()와 map() 메서드와 동일한 형태로 호출된다. 반환값이 true이거나 true로 변환되는 값이면 조건자 함수에 전달된 값은 filter가 반환할 배열에 추가된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">smallvalues = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x &gt; <span class="number">3</span> &#125;);        <span class="comment">// [2, 1]</span></span><br><span class="line">everyother = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x, i</span>) </span>&#123; <span class="keyword">return</span> i%<span class="number">2</span>==<span class="number">0</span> &#125;);     <span class="comment">// [5, 3, 1]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="794-every와-some"><a href="#7-9-4-every-와-some" class="headerlink" title="7.9.4 every()와 some()"></a><span style="color:red">7.9.4 every()와 some()</span></h4><p><code>every()</code>와 <code>some()</code> 메서드는 배열 조건자 함수다. 두 메서드는 인자로 주어진 조건자 함수를 배열에 적용하여, 결과로 true나 false를 반환한다.<br>every() 메서드는 전달인자로 넘긴 함수가 배열의 모든 원소에 대하여 true를 반환하는 경우, every() 메서드는 true를 반환한다.<br>some() 메서드는 전달인자로 넘긴 함수가 배열의 일부 원소에 대해 true를 반환하는 경우, some() 메서드는 true를 반환한다.<br>every()와 some() 메서드는 반환 값이 결정되면 배열의 원소 순회를 중단한다.</p>
<h4 id="795-reduce와-reduceright"><a href="#7-9-5-reduce-와-reduceRight" class="headerlink" title="7.9.5 reduce()와 reduceRight()"></a><span style="color:red">7.9.5 reduce()와 reduceRight()</span></h4><p><code>reduce()</code>와 <code>reduceRight()</code> 메서드는 인자로 주어진 함수를 사용하여 배열의 원소들을 하나의 값으로 결합한다.<br>reduce() 메서드는 두 개의 인자를 갖는다. 첫 번째 인자는 배열 원소의 감소 작업을 하는 함수다. 이 감소 함수는 배열 원소 중 두 값을 하나로 결합하면서 크기를 줄이고, 마지막 남은 값을 반환한다. 두 번째 인자는 감소 함수에 전달할 시작 값이다.<br>reduce()에 사용되는 함수는 forEach()와 map()과는 조금 다르다. reduce()에서 사용하는 함수의 첫 번째 인자는 함수를 사용해 계산된 값의 누적된 결과다. 그 초기 값은 reduce()의 두 번째 인자로 전달한 값이다. 이후의 호출에서는 전 단계 함수 호출에서 반환된 값을 함수의 첫 번째 인자로 사용한다.<br>reduceRight() 메서드는 reduce()와 동작은 같지만, 배열의 끝부터 시작해 반대 방향으로 처리한다. 감소 함수의 피연사자들 중 오른쪽 피연산자의 우선순위가 높다면, reduceRight()를 사용해야 한다. reduce()와 reduceRight() 메서드는 감소 함수 호출 시 사용할 this 값을 선택인자로 지정할 수 없다. 선택 초기 값 인자만 지정할 수 있다. 만약 감소 함수를 특정 object의 메서드로 호출하고 싶다면, Function.bind() 메서드를 사용해야 한다.</p>
<h4 id="796-indexof와-lastindexof"><a href="#7-9-6-indexOf-와-lastIndexOf" class="headerlink" title="7.9.6 indexOf()와 lastIndexOf()"></a><span style="color:red">7.9.6 indexOf()와 lastIndexOf()</span></h4><p><code>indexOf()</code>와 <code>lastIndexOf()</code> 메서드는 배열의 원소 중에서 특정한 값을 찾는다. 값이 존재하면 해당 값의 인덱스를 반환하고, 존재하지 않을 경우에는 -1을 반환한다. indexOf()는 배열의 처음부터 검색하고, lastIndexOf()는 배열의 끝에서부터 검색한다. indexOf()와 lastIndexOf()는 함수를 인자로 받지 않고, 첫 번째 인자에서 배열에서 찾고자 하는 값, 두 번째 인자에서 검색을 시작할 배열 인덱스를 지정할 수 있다.(생략가능)</p>
<hr>
<h2 id="710-배열-타입"><a href="#7-10-배열-타입" class="headerlink" title="7.10 배열 타입"></a>7.10 배열 타입</h2><p>ECMAScript 5에서는 <code>Array.isArray()</code>라는 함수를 통해 특정 객체가 배열인지 판단할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([?])      <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;?&#125;)      <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="711-유사-배열-객체"><a href="#7-11-유사-배열-객체" class="headerlink" title="7.11 유사 배열 객체"></a>7.11 유사 배열 객체</h2><p>length 프로퍼티와 양의 정수 이름의 프로퍼티가 있는 객체는 일종의 배열로 취급할 수 있다. 이를 <code>유사 배열 객체</code>라고 한다.<br>자바스크립트 배열 메서드는 배열뿐 아니라 유사 배열 객체에도 적용이 가능 하도록 범용 메서드로 구현되었다. 유사 배열은 Array.prototype을 상속받지 않기 때문에, 배열 메서드를 해당 객체의 메서드로 호출할 수는 없지만 <code>Function.call</code> 메서드를 통해서 간접적으로 호출할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="string">"0"</span>:<span class="string">"a"</span>, <span class="string">"1"</span>:<span class="string">"b"</span>, <span class="string">"2"</span>:<span class="string">"c"</span>, <span class="attr">length</span>:<span class="number">3</span>&#125;;     <span class="comment">// 유사 배열 객체</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.join(a, <span class="string">"+"</span>)                       <span class="comment">// =&gt; 'a+b+c'</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="712-문자열을-배열처럼-사용하기"><a href="#7-12-문자열을-배열처럼-사용하기" class="headerlink" title="7.12 문자열을 배열처럼 사용하기"></a><span style="color:red">7.12 문자열을 배열처럼 사용하기</span></h2><p>문자열은 읽기 전용 배열처럼 동작한다. 문자열의 각 문자는 chatAt() 메서드로 접근할 수도 있지만 대괄호 []를 사용해 접근할 수도 있다. 문자열을 인덱스로 접근함으로써 얻을 수 있는 가장 큰 장점은 charAt() 메서드 호출을 단순하게 []로 대체 함으로써 코드가 전보다 간결해지고, 가독성이 높아지는 것이다.<br><strong>문자열은 변하지 않는 값이라서, 읽기 전용 배열</strong>로만 다룰 수 있다. push(), sort(), reverse(), splice()와 같은 배열 메서드는 배열을 직접 수정하므로 문자열에서는 작동하지 않는다.</p>
<p><br><br><strong>출처 : <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10338797" rel="external nofollow noopener noreferrer" target="_blank">“JavaScript: The Definitive Guide, by David Flanagan (O’Reilly). Copyright 2011 David Flanagan, 978-0-596-80552-4”</a></strong></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-26T17:10:32.000Z">2017-01-27</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    22분 읽기 (대략 3333 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/27/JavaScript/complete-guide-to-javascript-chapter-4/">자바스크립트 완벽가이드 4장 (표현식과 연산자)</a>
            
        </h1>
        <div class="content">
            <p>표현식(expression)은 자바스크립트 인터프리터가 값으로 평가하는 자바스크립트 구문이다.</p>
<h2 id="41-기본-표현식"><a href="#4-1-기본-표현식" class="headerlink" title="4.1 기본 표현식"></a>4.1 기본 표현식</h2><p>가장 간단한 형태의 표현식은 ‘기본 표현식’으로, 다른 표현식을 포함하지 않은 독립적 표현식이다. 자바스크립트에서 기본 표현식은 상수나 리터럴 값, 특정 키워드들 그리고 변수 참조를 말한다.<br><br><code>this</code>는 상수가 아니고 프로그램 안에서 위치에 따라 각기 다른 값으로 평가된다. this 키워드는 객체 지향 프로그래밍에서 주로 사용된다. <strong>메서드의 본문 안에서 this는 메서드를 호출한 객체로 평가된다.</strong> 자바스크립트에서는 프로그램 안에 존재하는 각 식별자들을 일단 변수라고 가정하고 값을 살펴보는데 해당 식별자를 이름으로 하는 변수가 없다면, 해당 표현식은 undefined 값으로 평가된다. 하지만 ECMAScript 5의 strict 에서는 존재하지 않는 변수를 평가하려고 하면 ReferenceError 예외가 발생한다.</p>
<hr>
<h2 id="42-객체와-배열의-초기화-표현식"><a href="#4-2-객체와-배열의-초기화-표현식" class="headerlink" title="4.2 객체와 배열의 초기화 표현식"></a>4.2 객체와 배열의 초기화 표현식</h2><p>객체와 배열 초기화 표현식은 새로 생성된 객체나 배열을 값으로 하는 표현식이다. 일반 리터럴과는 달리, 이들은 기본 표현식이 아니다. 이들 리터럴은 프로퍼티와 원소의 값을 지정하는 수많은 하위 표현식을 포함할 수 있기 때문이다.</p>
<hr>
<h2 id="44-프로퍼티-접근-표현식"><a href="#4-4-프로퍼티-접근-표현식" class="headerlink" title="4.4 프로퍼티 접근 표현식"></a><span style="color:red">4.4 프로퍼티 접근 표현식</span></h2><p>두 프로퍼티 접근 표현식 모두 점(.)이나 대괄호([) 왼쪽 표현식이 먼저 평가된다. 만약 평가된 값이 null이나 undefined이면 이들 값은 프로퍼티를 갖지 않기 때문에 표현식은 <strong>TypeError 예외</strong>를 발생시킨다. 만약 값이 객체(또는 배열)가 아니면 객체로 변환된다. 객체에 해당 프로퍼티가 존재하지 않으면, 프로퍼티 접근 표현식의 값은 <strong>undefined</strong>가 된다.<br><br>‘. 식별자’ 문법이 두 방법 중 좀 더 간단하지만 접근하려는 프로퍼티 이름이 ‘합법적’ 식별자일 때만 사용 가능하고, 프로그램을 작성할 때 그 식별자를 미리 알고 있어야 한다. 만약 프로퍼티 이름이 예약어이거나, 구두점 문자나 공백을 포함, 숫자일 때는 반드시 대괄호를 사용해야 한다. 대괄호는 프로퍼티 이름이 고정되어 있지 않고, 그 이름 자체가 어떤 연산의 결과인 경우에도 사용할 수 있다.</p>
<hr>
<h2 id="45-호출-표현식"><a href="#4-5-호출-표현식" class="headerlink" title="4.5 호출 표현식"></a><span style="color:red">4.5 호출 표현식</span></h2><p>값을 반환하기 위해 return문을 사용하면, 그 값이 결국 호출 표현식의 값이 된다. 함수가 값을 반환하지 않는다면, 함수 표현식의 값은 undefined가 된다.<br><br>모든 호출 표현식은 한 쌍의 괄호 ()와, 괄호 앞에 오는 표현식으로 이뤄진다. 만약 그 표현식이 프로퍼티 접근 표현식이면, <strong>호출 표현식은 메서드 호출</strong>이 된다. 메서드가 호출되면 함수의 몸체가 실행되는 동안 프로퍼티 접근 표현식이 가리키는 객체나 배열이 모두 this의 값이 된다.<br><br>메서드 호출이 아닌 호출 표현식은 보통 전역객체를 this 키워드의 값으로 사용한다. 하지만 ECMAScript 5에서는 메서드 호출이 아닌 호출 표현식을 ‘엄격모드’에서 사용할 경우, 전역 객체 대신 undefined가 this의 값이 된다.’</p>
<hr>
<h2 id="46-객체-생성-표현식"><a href="#4-6-객체-생성-표현식" class="headerlink" title="4.6 객체 생성 표현식"></a><span style="color:red">4.6 객체 생성 표현식</span></h2><p>객체 생성 표현식은 새 객체를 생성하고 생성자라고 부르는 함수를 호출해 객체에 속한 프로퍼티들을 초기화한다. 객체 생성 표현식이 평가될 때, 자바스크립트 인터프리터는 먼저 새로운 빈 객체를 생성한다. 이때 생성된 객체는 객체 초기자 {}에 의해 생성되는 객체와 동일하다. 다음으로, 주어진 인자들과 함께 생성자를 호출하는데, 이때 방금 생성된 새 객체를 <strong>this</strong> 키워드의 값으로 설정하여 전달한다. 생성자 함수는 이 this 키워드를 사용해 새로 생성된 객체의 프로퍼티들을 초기화한다.</p>
<hr>
<h2 id="48-산술-표현식"><a href="#4-8-산술-표현식" class="headerlink" title="4.8 산술 표현식"></a>4.8 산술 표현식</h2><p>수로 변환 불가능한 피연산자는 NaN 값으로 변환되며, 피연산자중 하나라도 NaN일 경우에는 연산 결과도 NaN이다.<br><br>/ 연산자는 첫 번째 피연산자를 두 번째 피연산자로 나눈다. 정수를 정수로 나누면 계산 값이 당연히 정수가 되리라고 예상하겠지만, 자바스크립트에서 모든 숫자는 <strong>부동소숫점 숫자</strong>로 취급된다. 따라서 모든 나눗셈 연산의 결과 또한 부동소숫점 숫자 값이 된다. 예를 들어 5/2는 2가 아니라 2.5로 평가된다. 값을 0으로 나누면 양의 무한도 또는 음의 무한대 값이 되고, 0/0의 값은 NaN로 평가된다.<br><br>% 연산자 결과의 부호는 첫 번째 피연산자의 부호와 동일하다.</p>
<h4 id="481-덧셈-연산자"><a href="#4-8-1-덧셈-연산자" class="headerlink" title="4.8.1 덧셈 연산자 +"></a>4.8.1 덧셈 연산자 +</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span>                   <span class="comment">// =&gt; 3: 덧셈</span></span><br><span class="line"><span class="string">"1"</span> + <span class="string">"2"</span>               <span class="comment">// =&gt; '12': 이어붙이기</span></span><br><span class="line"><span class="string">"1"</span> + <span class="number">2</span>                 <span class="comment">// =&gt; '12': 숫자를 문자열로 바꾼 후 이어붙이기</span></span><br><span class="line"><span class="number">1</span> + &#123;?&#125;                 <span class="comment">// =&gt; "1[object Object]": 객체를 문자열로 바꾼 후 이어붙이기</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span>             <span class="comment">// =&gt; 2: 불리언 값을 숫자로 바꾼 후 더하기</span></span><br><span class="line"><span class="number">2</span> + <span class="literal">null</span>                <span class="comment">// =&gt; 2: null 값을 0으로 바꾼 후 더하기</span></span><br><span class="line"><span class="number">2</span> + <span class="literal">undefined</span>           <span class="comment">// =&gt; NaN: undefined를 NaN으로 바꾼 후 더하기</span></span><br></pre></td></tr></table></figure>
<h4 id="482-단항-산술-연산자"><a href="#4-8-2-단항-산술-연산자" class="headerlink" title="4.8.2 단항 산술 연산자"></a>4.8.2 단항 산술 연산자</h4><p><strong>증가(++)</strong><br><br>표현식 <code>++x</code>는 <code>x=x+1</code>과 항상 같지 않다. ++ 연산자는 절대 문자열 결합을 하지 않고, 항상 피연산자를 숫자로 바꾼 후에 값을 하나 증가시킨다. 예를 들어, x가 문자열 “1”이면 ++x는 숫자 2가 되지만 x+1은 문자열 “11”이 된다.</p>
<hr>
<h2 id="49-관계형-표현식"><a href="#4-9-관계형-표현식" class="headerlink" title="4.9 관계형 표현식"></a>4.9 관계형 표현식</h2><h4 id="491-동치와-부등치-연산자"><a href="#4-9-1-동치와-부등치-연산자" class="headerlink" title="4.9.1 동치와 부등치 연산자"></a>4.9.1 동치와 부등치 연산자</h4><p>==와 === 연산자 모두 주어진 두 값이 같은지를 확인하는 데 쓰이지만 같음을 정의하는 기준이 서로 다르다. 두 연산자 모두 피연산자 타입을 가리지 않고, 주어진 피연산자들이 같으면 true, 다르면 false를 반환한다. === 연산자는 일치(엄격한 동치) 연산자로 알려져 있는데, 같음을 정의하는 기준을 매우 엄격하게 정의하여, 두 피연산자가 <strong>‘일치’</strong>하는지 확인한다.<br><br>자바스크립트는 =(할당), ==(동치), ===(일치) 연산자를 지원하고 있다.</p>
<h4 id="492-비교-연산자"><a href="#4-9-2-비교-연산자" class="headerlink" title="4.9.2 비교 연산자"></a>4.9.2 비교 연산자</h4><p><strong>비교 연산자는 피연산자 타입에 제한이 없다.</strong> 하지만 오직 숫자와 문자열만 비교할 수 있기 때문에, 숫자나 문자열이 아닌 피연산자는 먼저 변환된다.<br><br>문자열 비교는 대소문자를 구분한다. 모든 ASCII 대문자는 모든 ASCII 소문자보다 작다. 대소문자를 구분하지 않고 문자열을 비교하려면, 우선 <code>String.toLowerCase()</code>나 <code>String.toUpperCase()</code> 메서드를 사용해야 한다.</p>
<h4 id="493-in-연산자"><a href="#4-9-3-in-연산자" class="headerlink" title="4.9.3 in 연산자"></a>4.9.3 in 연산자</h4><p><code>in</code> 연산자는 좌변의 피연산자로 <strong>문자열</strong>(또는 문자열로 변환될 수 있는 것)을 받고, 우변의 피연산자로는 <strong>객체나 배열</strong>을 받는다. 좌변 값이 우변 객체의 <strong>프로퍼티 이름</strong>에 해당할 경우 연산 결과는 true이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123; <span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">1</span> &#125;;          <span class="comment">// 객체 정의</span></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> point                       <span class="comment">// =&gt; true: 프로퍼티 x가 있다.</span></span><br><span class="line"><span class="string">"z"</span> <span class="keyword">in</span> point                       <span class="comment">// =&gt; false: 프로퍼티 z가 없다..</span></span><br><span class="line"><span class="string">"toString"</span> <span class="keyword">in</span> point                <span class="comment">// =&gt; true: 상속된 프로퍼티</span></span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];                <span class="comment">// 원소가 0, 1, 2 위치에 차례로 7, 8, 9</span></span><br><span class="line"><span class="string">"0"</span> <span class="keyword">in</span> data                        <span class="comment">// =&gt; true: 배열에 0번째 원소가 있기 때문</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> data                          <span class="comment">// =&gt; true: 배열에 1번째 원소가 있기 때문</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> data                          <span class="comment">// =&gt; false: 배열에 4번째 원소가 없기 때문</span></span><br></pre></td></tr></table></figure></p>
<h4 id="494-instanceof-연산자"><a href="#4-9-4-instanceof-연산자" class="headerlink" title="4.9.4 instanceof 연산자"></a>4.9.4 instanceof 연산자</h4><p><code>instanceof</code> 연산자는 좌변의 피연산자로 객체를, 우변의 피연산자로 객체 클래스의 이름을 받는다. 자바스크립트에서 객체의 클래스는 객체를 초기화하는 생성자 함수로부터 정의된다. 그러므로 instanceof의 우변 피연산자는 함수가 되어야 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();          <span class="comment">// Date() 생성자로 새로운 객체를 생성한다.</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Date</span>;           <span class="comment">// =&gt; true: d는 Date()에 의해 생성되었다.</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Object</span>;         <span class="comment">// =&gt; true: 모든 객체는 Object의 인스턴스.</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Number</span>;         <span class="comment">// =&gt; false: d는 Number의 객체가 아니다.</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];           <span class="comment">// 배열 리터럴 문법으로 새로운 배열을 생성한다.</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>;          <span class="comment">// =&gt; true: a는 배열이다.</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span>;         <span class="comment">// =&gt; true: 모든 배열은 객체다.</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>;         <span class="comment">// =&gt; false: 배열은 정규 표현식이 아니다.</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="410-논리-표현식"><a href="#4-10-논리-표현식" class="headerlink" title="4.10 논리 표현식"></a>4.10 논리 표현식</h2><h4 id="4101-논리-and-ampamp"><a href="#4-10-1-논리-AND-amp-amp" class="headerlink" title="4.10.1 논리 AND (&amp;&amp;)"></a>4.10.1 논리 AND (&amp;&amp;)</h4><p><code>&amp;&amp;</code> 연산자의 피연산자로 반드시 불리언 값이 올 필요는 없다. <strong>모든 자바스크립트 값은 true 또는 false로 평가될 수 있기 때문이다.</strong> 피연산자 <strong>모두 true로 평가</strong>되는 값이면, &amp;&amp; 연산자는 <strong>true로 평가되는 값을 반환</strong>한다. 하지만 <strong>적어도 하나의 피연산자가 false로 평가</strong>될 경우에는 <strong>false로 평가되는 값을 반환</strong>한다.<br><br>&amp;&amp; 연산자의 특성을 ‘단축 평가’라고도 부르고 다음과 같이도 사용 가능하다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == b) stop();</span><br><span class="line">(a == b) &amp;&amp; stop();</span><br></pre></td></tr></table></figure></p>
<p>&amp;&amp; 연산자는 우변 표현식을 평가할 수도, 하지 않을 수도 있기 때문에 &amp;&amp; 우변에 부수 효과가 일어나는 표현식(하당, 증가, 감소, 함수 호출)을 사용할 때는 각별히 주의해야 한다. 이러한 부수 효과가 일어나는 표현식은 &amp;&amp; 좌변 값에 따라 실행 여부가 결정되기 때문이다.</p>
<h4 id="4102-논리-or"><a href="#4-10-2-논리-OR" class="headerlink" title="4.10.2 논리 OR (||)"></a>4.10.2 논리 OR (||)</h4><p><code>||</code> 연산자는 일반적으로, 다음 코드와 같이 여러 값중에 최초로 true로 평가되는 값을 선택하는 경우에 사용된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// max_width가 정의되어 있으면 이것을 사용한다.</span></span><br><span class="line"><span class="comment">// 이 외의 경우 preference 객체에 속한 값을 찾아본다.</span></span><br><span class="line"><span class="comment">// 그것조차 정의되어 있지 않을 경우 하드 코딩된 상수를 사용한다.</span></span><br><span class="line"><span class="keyword">var</span> max = max_width || preferences.max_width || <span class="number">500</span>;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="413-기타-연산자들"><a href="#4-13-기타-연산자들" class="headerlink" title="4.13 기타 연산자들"></a>4.13 기타 연산자들</h2><h4 id="4132-typeof-연산자"><a href="#4-13-2-typeof-연산자" class="headerlink" title="4.13.2 typeof 연산자"></a>4.13.2 typeof 연산자</h4><p>typeof의 피연산자 값이 <strong>null</strong>일 때 연산자는 <strong>“object”</strong>를 반환한다. 만약 다른 Object들과 null을 구분하고 싶다면, typeof를 사용하기 보다는 명시적으로 null인지를 테스트해야한다.<br><br>typeof 연산자는 함수를 제외한 모든 객체와 배열을 “object”로 평가하기 때문에, 객체를 다른 원시 타입과 구분하는 용도로만 사용할 수 있다. 객체의 클래스를 구분하기 위해서는 instanceof 연산자나 class 속성 또는 constructor 프로퍼티와 같은 다른 수단을 사용해야 한다.<br><br>자바스크립트에서 함수는 객체의 일종이지만, typeof 연산자는 함수들이 자신의 반환 값을 가지고 있다는 점 때문에 일반 객체와는 충분히 다르다고 본다. 자바스크립트에서는 함수와 ‘호출 가능한 객체’ 사이에 미묘한 차이점이 있다. 모든 함수는 호출 가능하다. 하지만 실제로는 함수가 아닌데도 함수처럼 호출이 가능한 객체도 있을 수 있다.<br><br>ECMAScript 5 표준은 typeof 연산자가 모든 호출 가능한 객체에 대해 일반 개체든 호스트 객체든 관계없이 ‘function’을 반환하도록 명세를 확장했다.</p>
<h4 id="4133-delete-연산자"><a href="#4-13-3-delete-연산자" class="headerlink" title="4.13.3 delete 연산자"></a>4.13.3 delete 연산자</h4><p>delete는 단항 연산자이며, 피연산자로 지정된 객체 프로퍼티, 배열 원소 또는 변수의 <strong>삭제를 시도</strong>한다. delete 연산자는 보통 연산자가 가진 부수 효과(프로퍼티 삭제) 때문에 사용하는 것이며, 연산자가 반환하는 값 때문에 사용하는 것이 아니다. (단, 배열의 원소를 delete 연산자를 사용하여 삭제해도 배열의 길이는 변하지 않는다.)<br><br>삭제된 프로퍼티나 배열의 원소는 단순히 undefined 값으로 설정된 것이 아니라는 점을 유의해야한다. 어떤 프로퍼티가 삭제되면 그 프로퍼티는 더 이상 존재하지 않는다. 그런데 존재하지 않는 프로퍼티에 접근하려고 해도 undefined가 반환되므로, 프로퍼티가 객체에 존재하는지 여부를 검사하려면 <strong>in 연산자</strong>를 쓰면 된다.<br><br>그러나 모든 변수나 프로퍼티를 삭제할 수는 없다. var 문으로 선언한 사용자 정의 변수나 내장 코어 프로퍼티, 클라이언트 측 프로퍼티는 삭제할 수 없다. function 문으로 정의한 함수와 함수 매개변수도 삭제할 수 없다.</p>
<p><br><br><strong>출처 : <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10338797" rel="external nofollow noopener noreferrer" target="_blank">“JavaScript: The Definitive Guide, by David Flanagan (O’Reilly). Copyright 2011 David Flanagan, 978-0-596-80552-4”</a></strong></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-26T17:10:32.000Z">2017-01-27</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    24분 읽기 (대략 3527 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/27/JavaScript/complete-guide-to-javascript-chapter-5/">자바스크립트 완벽가이드 5장 (문장)</a>
            
        </h1>
        <div class="content">
            <p>문장(statement), 즉 ‘문’은 자바스크립트 문장, 다시 말해 <strong>명령</strong>이다. 자바스크립트 문장은 세미콜론(;)으로 끝난다. 표현식은 어떤 값을 생성하기 위해 평가되지만, 구문은 어떤 일을 하기위해 실행되는 것이다.</p>
<h2 id="52-복합문과-빈-문장"><a href="#5-2-복합문과-빈-문장" class="headerlink" title="5.2 복합문과 빈 문장"></a>5.2 복합문과 빈 문장</h2><p>문장 블록은 여러 문장을 하나의 복합문으로 묶는다. 자바스크립트에는 블록 단위의 유효범위(scope)가 존재하지 않기 때문에, 구문 블록 안에 선언된 변수는 블록뿐 아니라 블록 밖에서도 접근할 수 있다.<br><br>자바스크립트 문법은 대체로 하나의 하위문을 허용한다. 예를 들어, while 루프 문법은 루프 몸체로 하나의 문장을 허용한다. 문장 블록을 사용하면 문법이 허용하는 하나의 하위문 자리에 얼마든지 많은 문장을 넣을 수 있다.<br><br>결과적으로 복합문은 자바스크립트 문법에서 하나의 문장이 있어야 할 곳에 여러 문장을 사용할 수 있게 한다. 빈문장은 정 반대다. 하나의 문장이 있어야 할 곳에 아무런 문장도 두지 않을 수 있도록 한다. 빈 문장은 <code>;</code>을 사용하여 표현한다. 임의로 빈 문장을 사용할 경우에는, 코드에 고의로 사용했다는 설명을 주석으로 표시하는 것이 좋다.</p>
<hr>
<h2 id="53-선언문"><a href="#5-3-선언문" class="headerlink" title="5.3 선언문"></a>5.3 선언문</h2><h4 id="531-var"><a href="#5-3-1-var" class="headerlink" title="5.3.1 var"></a>5.3.1 var</h4><p>var문은 하나 또는 그 이상의 변수를 선언한다. var문에서 변수에 초기 값을 지정하지 않으면 변수의 초기 값은 <strong>undefined</strong>가 된다. 스크립트나 함수 안에서 선언된 변수는 해당 스크립트나 함수 전체에 걸쳐 유효하다. 하지만 초기화된 var문이 선언된 시점에서 발생하고, 그 전까지는 변수 값은 undefined가 된다.</p>
<h4 id="532-function"><a href="#5-3-2-function" class="headerlink" title="5.3.2 function"></a>5.3.2 function</h4><p>함수 선언문은 자바스크립트 최상위 단계 코드에서 나타날 수도 있고, 다른 함수 내에 중첩될 수도 있다. 하지만 함수가 다른 함수 속에 중첩될 때는, 중첩된 함수 내에서 최상위 단계에 위치해야 한다. 즉, 함수 선언은 if문이나 while문 등의 다른 문장 안에 있을 수 없다.<br><br><strong><code>함수 선언문</code></strong>은 함수 이름을 포함한다는 점에서 <strong><code>함수 정의표현식</code></strong>과는 차이가 있다. 둘 다 새 함수 객체를 만들지만, 함수 선언문은 함수 이름을 변수로 선언한 후 이 변수에 함수 객체를 할당한다는 차이가 있다. var로 선언한 변수와 같이, 함수 선언문으로 정의된 함수는 스크립트나 함수 유효범위 최상단에 위치하게 되어(hoisted) 해당 유효범위 내에서 사용할 수 있다. <strong>var 문을 이용하면 변수 선언만 유효범위 최상단으로 끌어올려지지만(변수 초기화 코드는 원래 위치에 그대로 유지), 함수 선언문을 이용하면 함수의 이름과 본문 모두 유효범위 최상단으로 끌어올려진다. 이때 스크립트 내의 모든 함수 또는 함수의 중첩 함수는 다른 코드가 실행되기 전에 선언된다. 이는 자바스크립트 함수를 호출하는 코드가 선언문이 나오기 전에도 올 수 있다는 뜻이다.</strong></p>
<hr>
<h2 id="54-조건문"><a href="#5-4-조건문" class="headerlink" title="5.4 조건문"></a>5.4 조건문</h2><h4 id="541-if"><a href="#5-4-1-if" class="headerlink" title="5.4.1 if"></a>5.4.1 if</h4><p>대다수의 프로그래밍 언어와 마찬가지로 자바스크립트 규칙에 의하면 else 절은 기본적으로 가장 가까운 if문에 속한다. 모하함을 없애고 읽기 쉽고 이해하기 쉬운 동시에 유지보수와 디버깅을 쉽게 하려면 반드시 <strong>중괄호</strong>를 사용해야 한다.</p>
<h4 id="543-switch"><a href="#5-4-3-switch" class="headerlink" title="5.4.3 switch"></a>5.4.3 switch</h4><p>switch문은 if문에서처럼 동일한 표현식이 여러 번 반복되는 문제점을 확실히 해결한다. 다음은 실용적인 switch 문의 예제이다. 이 예제에서는 어떤 값을 문자열로 바꾸는데, 그 값의 타입에 따라 각기 다른 방법을 적용해 문자열로 변환한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(<span class="keyword">typeof</span> x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'number'</span>:      <span class="comment">// 주어진 숫자를 16진수 정수로 변경한다.</span></span><br><span class="line">      <span class="keyword">return</span> x.toString(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'string'</span>:      <span class="comment">// 문자열을 큰따옴표로 묶어서 반환한다.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">'"'</span> + x + <span class="string">'"'</span>;</span><br><span class="line">    <span class="keyword">default</span>:            <span class="comment">// 이 외의 타입은 문자열로 변환한다.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">String</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>switch문이 실행될 때마다 모든 case 표현식이 매번 평가되지는 않기 때문에, case 표현식에 함수 호출이나 값 할당과 같이 부수 효과를 일으킬 수 있는 표현식을 사용해서는 안된다. 가장 안전한 방법은 case 표현식을 상수 표현식만으로 제한하는 것이다. case를 판별할 때는 동치 연산자 ==가 아닌 <strong>일치 연산자 ===</strong>가 사용된다.</p>
<hr>
<h2 id="55-루프"><a href="#5-5-루프" class="headerlink" title="5.5 루프"></a>5.5 루프</h2><p>자바스크립트에는 네 개의 루프문이 있다.</p>
<ol>
<li>while</li>
<li>do/while</li>
<li>for</li>
<li>for/in</li>
</ol>
<h4 id="554-forin"><a href="#5-5-4-for-in" class="headerlink" title="5.5.4 for/in"></a>5.5.4 for/in</h4><p>for/in문은 for 키워드를 사용하지만, 일반적인 for 루프와는 전혀 다른 종류다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (변수 <span class="keyword">in</span> 객체)</span><br><span class="line">  문장</span><br></pre></td></tr></table></figure></p>
<p>‘변수’는 보통 변수 이름이지만 좌변 값으로 평가되는 표현식이거나, 단일 변수를 선언하는 var문일 수도 있다. ‘객체’는 객체로 평가되는 표현식이어야 한다. ‘문장’은 루프 몸체를 구성하는 문장 또는 문장 블록이다.<br>일반적인 for 루프를 사용하면 다음과 같이 배열의 원소를 쉽게 순회할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">  <span class="built_in">console</span>.log(a[i]);</span><br></pre></td></tr></table></figure></p>
<p>이와 비슷하게 for/in 루프를 사용하면 객체가 가진 프로퍼티들을 쉽게 순회할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> o) &#123;       <span class="comment">// 변수 p에 객체 o가 가진 프로퍼티 이름을 할당한다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(o[p]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>for/in문을 실행하기 위해서 자바스크립트 인터프리터는 먼저 객체 표현식을 평가한다. 이때 표현식이 <strong>null</strong>이나 <strong>undefined</strong>로 평가되면 인터프리터는 해당 루프를 중단하고 다음 문장을 실행한다. 만약 표현식이 원시 값으로 평가되면 해당 값은, 값과 상응하는 Wrapper 객체로 바뀐다. 이 외에 표현식은 객체로 평가된다.<br><br>for/in 루프에서 사용하는 ‘변수’로는 할당 표현식의 좌변에 적합한 무언가로 평가되는 임의의 표현식을 사용할 수 있다. 이 표현식은 루프가 돌 때마다 평가되는데, 이때 매번 다르게 평가될 수 있다. 다음과 같은 코드를 사용하면 주어진 객체의 모든 프로퍼티 이름을 배열에 복사할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">z</span>:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> a = [?],  i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(a[i++] <span class="keyword">in</span> o)   <span class="comment">/*  비어 있음 */</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>자바스크립트 배열은 단순히 특별한 종류의 객체에 지나지 않는다.</strong> 따라서 for/in 루프는 객체의 프로퍼티와 마찬가지로 배열 인덱스 또한 하나씩 열거할 수 있다.<br><br>for/in 루프는 실제로 객체가 가진 모든 프로퍼티를 열거하지 않고 오직 ‘열거 할 수 있는 프로퍼티’만 열거한다. 자바스크립트 코어에 정의된 다양한 내장 메서드들은 일반적으로 열거할 수 없다. (예를 들면 toString() 메서드)</p>
<hr>
<h2 id="56-점프문"><a href="#5-6-점프문" class="headerlink" title="5.6 점프문"></a>5.6 점프문</h2><h4 id="564-return"><a href="#5-6-4-return" class="headerlink" title="5.6.4 return"></a>5.6.4 return</h4><p>함수를 호출하는 것 역시 표현식이고, 모든 표현식에는 값이 있다. return문은 함수 호출 표현식의 값, 즉 함수에서 반환하는 값을 지정하는 데 쓰인다. return문은 오직 함수 몸체 내부에서만 나타날 수 있다. 다른 곳에서 사용하면 문법 에러가 발생한다. return문이 실행되면 ‘표현식’이 평가되어 그 결과가 함수의 값으로 반환된다. 함수 내에 return문이 없다면 함수 호출은 단지 함수 몸체의 끝에 도달할 때까지 모든 구문을 차례로 실행하고, 호출한 지점으로 돌아간다. 이 경우에 해당 함수 호출 표현식의 값은 <strong>undefined</strong>가 된다. return문은 주로 함수의 마지막에 위치하지만 반드시 마지막에 있어야 하는것은 아니며, 함수 몸체 내에서 return문이 실행되면 아직 남은 문장들이 있어도 함수를 호출한 지점으로 돌아간다.</p>
<h4 id="565-throw"><a href="#5-6-5-throw" class="headerlink" title="5.6.5 throw"></a>5.6.5 throw</h4><p>자바스크립트에서는 <strong>런타임 에러</strong>가 일어날 때마다 예외를 발생시킨다. <code>Error 객체</code>는 에러의 종류를 담고 있는 <strong>name 프로퍼티</strong>와 Error 클래스 생성자 함수에 넘기는 문자열 값을 담고 있는 <strong>message 프로퍼티</strong>를 갖고 있다.<br><br>예외가 발생하면 자바스크립트 인터프리터는 정상적인 프로그램 실행을 즉시 중단하고 <strong>가장 가까운 예외 처리기</strong>로 넘어간다. 예외를 발생시킨 코드 블록이 catch절과 연결되어 있지 않으면, 인터프리터는 바로 상위 단계를 감싸고 있는 코드 블록에 연결된 예외 처리기가 있는지 확인한다. 이 과정은 처리기를 찾을 때까지 계속된다. 이같은 방법으로 자바스크립트의 언어적인 구조를 따라서, 즉 <strong>호출 스택</strong>을 따라서 예외가 전파되어 올라간다. <strong>예외 처리기를 찾을 수 없는 경우 해당 예외는 에러로 취급되고 사용자에게 보고된다.</strong></p>
<h4 id="565-trycatchfinally"><a href="#5-6-5-try-catch-finally" class="headerlink" title="5.6.5 try/catch/finally"></a>5.6.5 try/catch/finally</h4><ul>
<li>try : 단순히 예외가 발생할지도 모르는 코드 블록을 정의하는 역할</li>
<li>catch : try 블록 내부에서 예외가 발생할 경우 호출되는 문장 블록</li>
<li>finally : try 블록에서 일어난 일에 관계없이 항상 실행이 보장되어야 할 뒷정리용 코드가 포함</li>
</ul>
<p>정상적인 경우에, 자바스크립트 인터프리터는 try 블록의 끝까지 도달하고 난 후, finally 블록으로 이동해 무언가 필요한 뒷정리를 수행한다. 만일 <strong>인터프리터가 return, continue, break 문 등을 만나 try 블록의 제어를 벗어날 경우, 새 지점으로 이동하기 전에 finally 블록이 실행된다.</strong><br><br>만일 예외를 처리할 catch 블록이 없다면 인터프리터는 일단 finally 블록을 실행한 후 상위 블록으로 예외를 전파하여, 해당 예외를 처리할 수 있는 가장 가까운 catch 절로 이동한다.</p>
<hr>
<h2 id="57-기타"><a href="#5-7-기타" class="headerlink" title="5.7 기타"></a>5.7 기타</h2><h4 id="571-with"><a href="#5-7-1-with" class="headerlink" title="5.7.1 with"></a>5.7.1 with</h4><p><code>with</code>문은 유효범위 체인의 첫 번째에 ‘객체’를 추가한다. 그 후에 ‘문장’을 실행한 다음, 유효범위 체인을 ‘객체’를 추가하기 전 상태로 되돌려 놓는다. with문을 사용하는 자바스크립트 코드는 최적화하기 힘들고 with문을 사용하지 않는 코드에 비해 느리기 때문에 사용하지 않는것이 좋다.</p>
<h4 id="572-debugger"><a href="#5-7-2-debugger" class="headerlink" title="5.7.2 debugger"></a>5.7.2 debugger</h4><p><code>debugger</code>문은 평소에는 아무것도 하지 않지만 디버거 프로그램을 사용할 수 있고 디버거가 실행 중일 때, 자바스크립트 구현체는 해당 위치에서 정의된 코드 디버깅을 수행한다. debugger문은 코드의 중단점(breakpoint)와 같이 동작한다. 자바스크립트 코드의 실행을 잠시 멈추고 디버거 프로그램을 사용해 변수의 값을 출력할 수 있고, 호출 스택등을 살펴볼 수 있다.</p>
<h4 id="573-use-strict"><a href="#5-7-3-“use-strict”" class="headerlink" title="5.7.3 “use strict”"></a>5.7.3 “use strict”</h4><p><code>&#39;use strict&#39;</code>는 ECMAScript 5에서 처음 소개된 지시어다. ‘use strict’ 지시어를 사용하는 목적은 지시어 다음에 오는 (스크립트나 함수의) 코드들이 엄격 모드를 따르게 하기 위해서다. 스크립트의 최상단에 ‘use strict’ 지시어가 있으면 최상단(함수가 아닌) 코드는 엄격한 코드(엄격 모드를 따르는 코드)다.<br><br>엄격한 코드는 엄격 모드에서 실행된다. ECMAScript 5의 엄격 모드는 언어의 일부 기능이 제한된 부분 집합으로, 몇 가지 주용한 언어적 문제점을 수정하고 강력한 에러 검사와 향상된 보안 기능을 제공한다. 다음과 같은 부분이 일반 모드와 다르다.</p>
<ul>
<li>with문은 엄격 모드에서 사용 불가능 하다.</li>
<li>엄격 모드에서 모든 변수는 반드시 선언되어야 한다. 선언되지 않은 변수나 함수, 함수 인자, catch 절 인자, 전역 객체 프로퍼티에 값을 할당하는 경우 <code>ReferenceError</code> 예외가 발생한다.</li>
<li><strong>엄격 모드에서 함수는 메서드로 호출된 것이 아닌, 함수로 호출된 함수의 this 값은 undefined다.</strong> (표준 모드에서는 함수가 함수로 호출될 때 항상 전역 객체를 this의 값으로 넘겨주게 된다.) 또한 엄격 모드에서는 함수를 <strong>call()</strong>이나 <strong>apply()</strong>로 호출하면, this의 값은 정확히 call()이나 apply() 함수의 첫 번째 인자 값으로 설정된다. (표준 모드에서는 null과 undefined 값은 전역 객체로 대체되고, 객체가 아닌 값들은 객체로 바뀌게 된다.)</li>
<li>엄격 모드에서 함수의 arguments 객체는 함수에 전달된 값의 정적 사본을 갖고 있지만 표준 모드에서 arguments 배열의 원소와 함수의 전달인자는 동일한 값을 참조한다.</li>
</ul>
<p><br><br><strong>출처 : <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10338797" rel="external nofollow noopener noreferrer" target="_blank">“JavaScript: The Definitive Guide, by David Flanagan (O’Reilly). Copyright 2011 David Flanagan, 978-0-596-80552-4”</a></strong></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-25T17:10:32.000Z">2017-01-26</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    37분 읽기 (대략 5549 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/26/JavaScript/complete-guide-to-javascript-chapter-3/">자바스크립트 완벽가이드 3장 (타입, 값, 변수)</a>
            
        </h1>
        <div class="content">
            <p>자바스크립트의 타입은 크게 <code>원시 타입(promitive type)</code>과 <code>객체 타입(object type)</code>으로 나뉜다. 원시타입에는 숫자, 텍스트의 나열, 불리언 진리 값이 있다.<br>자바스크립트에서 null과 undefined는 원시값이긴 하지만, 숫자도 아니고, 문자열이나 불리언도 아니다. null과 undefined는 자기 자신만을 값으로 갖는 독립적인 타입이다. <strong>숫자와 문자열, 불리언, null, undefined 외의 값은 객체다. 객체는 이름과 값을 갖는 프로퍼티의 집합이다.</strong><br><br><strong>자바스크립트에서는 함수도 특별한 객체</strong>이다. 함수는 값이고, 자바스크립트 프로그램은 함수를 보통 객체처럼 다룰 수 있다.<br><br><strong>클래스는 객체 타입의 하위 타입으로 생각할 수 있다.</strong> 코어 자바스크립트에서는 Array와 Function 클래스 뿐만 아니라 세 개의 다른 유용한 클래스들을 정의하고 있다.</p>
<ul>
<li>Date : 날짜를 표현하는 객체를 정의</li>
<li>RegExp : 정규 표현식을 표현하는 객체를 정의</li>
<li>Error : 자바스크립트 프로그램에서 발생할 수 있는 문법과 런타임 에러를 표현하는 객체를 정의</li>
</ul>
<p>자바스크립트 인터프리터는 <strong>메모리 관리를 위해 자동</strong>으로 <strong><code>가비지 컬렉션</code></strong>을 수행한다. 프로그램이 필요할 때 객체를 생성할 수 있고, 프로그래머는 이 객체를 어떻게 해제할지 걱정할 필요가 없다. 객체에 더 이상 접근할 수 없을 때(프로그램이 더 이상 객체를 참조하지 않을 때) 인터프리터는 그 객체를 자동으로 메모리에서 해제한다.<br><br>자바스크립트는 <strong>객체 지향 언어</strong>다. 다양한 타입의 값을 다루는 전역 함수를 정의해두기보다, 어떠한 값과 작동하는 메서드를 그 값의 타입에 정의해둔다는 말이다. 예를 들면, 배열의 원소들을 정렬할 때는 배열 a를 sort() 함수에 인자로 전달하는 것이 아니라 a의 sort() 메서드를 호출하여 정렬하는 것이다. null과 undefined를 제외하고는 모두 메서드를 가질 수 있다.</p>
<h2 id="31-숫자"><a href="#3-1-숫자" class="headerlink" title="3.1 숫자"></a>3.1 숫자</h2><p>다른 프로그래밍 언어들과는 다르게 자바스크립트는 정수 값과 실수 값을 구분하지 않는다. 자바스크립트에서는 <strong>모든 숫자를 실수로 표현</strong>한다.</p>
<h4 id="313-산술-연산"><a href="#3-1-3-산술-연산" class="headerlink" title="3.1.3 산술 연산"></a>3.1.3 산술 연산</h4><p>자바스크립트의 산술 연산은 오버플로와 언더플로, 0으로 나누는 에러를 발생시키지 않는다. 산술 연산의 결과가 표현할 수 있는 가장 큰 수보다 더 크다면(오버플로) <code>Infinity</code>라고 표현하는 무한대의 값을 출력한다. 음의 무한대가 되면 이 값을 <code>-Infinity</code>로 출력한다. 언더플로는 산술 연산의 결과가 표현할 수 있는 가장 작은 값보다 더 0에 가까울 때 발생한다. 이런 경우 자바스크립트는 0을 돌려준다.<br><br><strong>자바스크립트에서 0으로 나누는 연산은 에러가 아니다.</strong> 이런 경우 무한대 또는 음의 무한대가 반환된다. 그러나 0을 0으로 나누는 것은 정의되지 않은 값을 갖고, 그 결과로 숫자가 아닌 특수한 값을 가진다. 자바스크립트에서는 이러한 값을 <strong>NaN</strong>으로 출력한다. (ECMAScript 5에서는 Infinity와 NaN을 읽기 전용 값으로 정의한다.) <code>Number</code>객체에는 Inifiny와 NaN이 따로 상수로 정의되어 있다.</p>
<p>자바스크립트에서 NaN은 그 자신뿐만 아니라 다른 값과 같은지 비교 할 수 없다. 변수 x가 NaN인지 판단하기 위해 <code>x === NaN</code> 문을 작성할 수 없고, 대신 <code>x != x</code> 라고 작성해야 한다. isNaN() 함수가 이러한 경우에 유용하게 사용할 수 있다. 이 함수는 인자가 NaN이거나, 문자열이나 객체처럼 숫자가 아니라면 참을 반환한다.</p>
<h4 id="314-이진-부동소수점과-반올림-오류"><a href="#3-1-4-이진-부동소수점과-반올림-오류" class="headerlink" title="3.1.4 이진 부동소수점과 반올림 오류"></a>3.1.4 이진 부동소수점과 반올림 오류</h4><p>무한히 많은 실수가 있지만 자바스크립트에서는 한정된 숫자만 부동소수점 형태로 표현할 수 있다. 자바스크립트에서 사용하는 IEEE-754 부동소수점 표현 방식은 1/2, 1/8, 1/1024 같은 분수를 정확하게 표현 할 수 있는 이진 표현법이다. 하지만 가장 많이 사용하는 분수는 10진수 분수인데, 이진 표현법으로는 0.1과 같은 간단한 값도 정확하게 표현 할 수 없다.<br>따라서 다음과 같은 상황이 발생한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">.3</span> - <span class="number">.2</span>;        <span class="comment">// 0.3 - 0.2</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">.2</span> - <span class="number">.1</span>;        <span class="comment">// 0.2 - 0.1</span></span><br><span class="line">x == y                  <span class="comment">// =&gt; false: 두 값은 같지 않다.</span></span><br><span class="line">x == <span class="number">.1</span>                 <span class="comment">// =&gt; false: 0.3 - 0.2는 0.1이 아니다.</span></span><br><span class="line">y == <span class="number">.1</span>                 <span class="comment">// =&gt; true: 0.2 - 0.1은 0.1과 같다.</span></span><br></pre></td></tr></table></figure></p>
<p>이진 부동소수점 숫자를 사용하기 때문에 발생하는 현상이다. 계산된 값은 대부분 적절하지만, 값들을 동등 비교할 경우에 문제가 발생한다.</p>
<h4 id="315-날짜와-시간"><a href="#3-1-5-날짜와-시간" class="headerlink" title="3.1.5 날짜와 시간"></a>3.1.5 날짜와 시간</h4><p>날짜와 시간을 표현하는 Date 객체를 사용한다. Date 객체는 숫자 같은 <strong>원시 타입이 아니다.</strong></p>
<hr>
<h2 id="32-텍스트"><a href="#3-2-텍스트" class="headerlink" title="3.2 텍스트"></a>3.2 텍스트</h2><p>문자열(string)은 16비트 값들이 연속적으로 나열된 변경이 불가능한 값으로, 각 문자는 유니코드 문자로 표현된다. 문자열의 길이 값은 문자열에 들어 있는 16비트 값의 개수다.</p>
<p>자바스크립트는 유니코드 문자열 집합으로 UTF-16을 사용한다. 유니코드 문자는 16비트에 적합한 코드 포인트를 갖고 있고, 문자열의 한 문자로 표현할 수 있다. 16비트로 표현할 수 없는 유니코드는 UTF-16 규칙에 따라 두 개의 16비트 값으로 인코딩한다. 따라서, 자바스크립트에서는 길이가 2인 문자열이 하나의 유니코드 문자를 표현하는 경우도 있다.<br><strong>문자열을 다루는 다양한 메서드는 문자를 다루는게 아니라 문자의 16비트 값을 다룬다.</strong></p>
<h4 id="323-문자열-다루기"><a href="#3-2-3-문자열-다루기" class="headerlink" title="3.2.3 문자열 다루기"></a>3.2.3 문자열 다루기</h4><p><strong>자바스크립트에서 문자열은 변경되지 않는다.</strong> replace()와 toUpperCase() 같은 메서드는 기존 문자열을 변경하지 않고 새문자열을 반환한다. 즉, 문자열 관련 메서드는 호출 시에 기존 문자열을 수정하지 않는다. ECMAScript5에서 문자열은 읽기 전용 배열처럼 취급될 수 있고, 대괄호 대신 <strong>charAt()</strong> 메서드를 사용해도 문자열의 개별 문자(16비트 값)에 접근할 수 있다.</p>
<h4 id="324-패턴-매칭"><a href="#3-2-4-패턴-매칭" class="headerlink" title="3.2.4 패턴 매칭"></a>3.2.4 패턴 매칭</h4><p>자바스크립트는 문자 패턴을 나타내는 객체를 생성하기 위해 RegExp() 생성자를 정의한다. 이 패턴은 <strong>정규 표현식</strong>이라 부르며, 자바스크립트는 정규 표현식을 위해 펄(Perl)의 구문을 따른다. 문자열과 RegExp 객체는 모두 패턴 매칭과 ‘검색 후 바꾸기’기능을 수행하는 메서드를 갖고 있다. RegExp는 자바스크립트의 원시 타입이 아니다. Date 객체처럼 RegExp는 유용한 API를 갖고 있는 <strong>특별한 종류의 객체</strong>다.<br>한 쌍의 슬래시 사이에 있는 문자열은 정규 표현식 리터럴을 구성하고, 한 쌍의 슬래시 중 두 번째 슬래시 뒤에는 하나 혹은 그 이상의 문자가 뒤따라 올 수 있는데, 이것은 패턴의 의미를 수정할 수 있다.<br><br>RegExp 객체에는 유용한 메서드들이 정의되어 있다. 또한 <strong>문자열은 RegExp 객체를 인자로 갖는 메서드들을 갖고 있다.</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"testing: 1, 2, 3"</span>;      <span class="comment">// 간단한 문자열</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\b+/g</span>                <span class="comment">// 하나 이상의 모든 숫자와 일치</span></span><br><span class="line">pattern.test(text);                 <span class="comment">// =&gt; true: 일치하는 문자열이 존재</span></span><br><span class="line">text.search(pattern);               <span class="comment">// =&gt; 9: 첫 번째로 매치하는 문자열의 위치</span></span><br><span class="line">text.match(pattern);                <span class="comment">// =&gt; ["1", "2", "3"]: 일치된 항목의 배열</span></span><br><span class="line">text.replace(pattern, <span class="string">"#"</span>);         <span class="comment">// =&gt; "testing: #, #, #"</span></span><br><span class="line">text.split(<span class="regexp">/\D+/</span>);                  <span class="comment">// =&gt; ["", "1", "2", "3"]: 숫자가 아닌 문자(열)를 기준으로 분할</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="33-불리언-값"><a href="#3-3-불리언-값" class="headerlink" title="3.3 불리언 값"></a><span style="color:red">3.3 불리언 값</span></h2><p><strong>자바스크립트의 어떤 값이든 불리언 값으로 변환될 수 있다.</strong> 다음은 모두 불리언 false 값으로 변한다.</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>0</li>
<li>-0</li>
<li>NAN</li>
<li>“” // 빈 문자열</li>
</ul>
<p>불리언 값은 문자열 “true” 혹은 “false”로 변환할 수 있는 <code>toString()</code> 메서드를 갖고 있지만 그 밖의 메서드는 갖고있지 않다.</p>
<h2 id="34-null과-undefined"><a href="#3-4-null과-undefined" class="headerlink" title="3.4 null과 undefined"></a><span style="color:red">3.4 null과 undefined</span></h2><p><code>null</code>은 보통 아무 값도 갖지 않음을 가리킬 때 사용한다. typeof 연산자를 null에 사용하면 문자열 “object”를 반환한다. 그 결과로 볼 때, <strong>null은 ‘객체가 없음’을 뜻하는 특수한 객체 값으로 생각할 수 있다.</strong> 하지만 실무에서 null은 값이 null 하나뿐인 어떤 고유한 자료형에 속한 것으로 간주하여, 객체뿐 아니라 수나 문자열 “값이 없음”을 나타내는 데도 쓰인다.<br><br>자바스크립트에는 값이 없음을 나타내는 또 다른 값, <code>undefined</code>가 있다. <strong>undefined는 null보다 심한 부재 상태</strong>를 나타낸다. undefined는 초기화되어 있지 않는 변수나, 존재하지 않는 객체 프로퍼티나 배열의 원소 값에 접근하려고 할 때 얻는 값이다. 또한 undefined는 반환값이 없는 함수의 반환값이고, 실 인자가 전달되지 않은 형식인자의 값이다. ECMAScript 5에서 undefined는 읽기 전용이며, typeof 연산자의 결과로 “undefined”가 반환된다. 이는 undefined가 <strong>특별한 고유의 값</strong>임을 말한다.<br><br>이러한 차이에도 불구하고 <strong>null</strong>과 <strong>undefined</strong>는 둘다 값이 없음을 가리키고, 사용할 때 서로 바꿔 사용할 수도 있다. 동치 연산자 ==를 null과 undefined에 사용하면 두 값이 같다고 간주하며 엄격한 동치 연산자 ===는 다르다고 판단한다.<br><br>시스템 수준에서 예기치 않은 상황에 발생한, 오류성 값 부재를 표현할 때는 주로 undefined를 사용하고, 일반적인 프로그램 수준에서 일반적으로, 또는 예상 가능한 값 부재 상황을 표현하고 싶을 때는 null을 사용한다. <strong>만약 이들 값 중 하나를 변수나 프로퍼티에 할당할 필요가 있거나 함수에 인자로 전달할 필요가 있다면, undefined보다는 null을 사용하는게 적절하다.</strong></p>
<h2 id="36-래퍼wrapper-객체"><a href="#3-6-래퍼-wrapper-객체" class="headerlink" title="3.6 래퍼(wrapper) 객체"></a><span style="color:red">3.6 래퍼(wrapper) 객체</span></h2><p>자바스크립트 객체는 복합적인 값이다. 객체는 프로퍼티 또는 이름 있는 값들의 집합이다. 프로퍼티의 값이 함수일 때, 그 함수를 <strong>메서드</strong>라 부른다.<br><br>문자열의 프로퍼티를 참조하려 할 때, 자바스크립트는 new String()를 호출한 것처럼 <strong>문자열 값을 객체로 변환한다.</strong> 이 객체는 문자열 메서드를 상속하며, 프로퍼티 참조를 살펴보는 데 사용한다. 일단 프로퍼티 참조가 해제되면 새로 생성된 임시 객체는 메모리에서 회수된다.<br><br>숫자와 불리언은 문자열과 같은 이유로 메서드를 갖고 있다. 임시 객체는 <code>Number()</code> 혹은 <code>Boolean()</code> 생성자를 통해 만들어지고, 메서드는 임시 객체를 통해 호출된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"test"</span>;</span><br><span class="line">s.len = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> t = s.len;</span><br></pre></td></tr></table></figure></p>
<p>위의 코드를 실행시 t의 값은 undefined이다. 2행은 생성된 임시 String 객체의 len 프로퍼티에 4를 할당한다. 그리고 임시 객체는 바로 삭제된다. 3행은 기존 문자열 값과 같은 값을 가진 새로운 String 객체를 생성하고 len 프로퍼티를 읽으려고 하지만 존재하지 않아 undefined를 출력한다. <strong>값을 할당하는 것은 임시 객체에서 수행되며, 지속되지 않는다.</strong><br><br>문자열, 숫자, 불리언의 프로퍼티에 접근하려고 할 때 생성되는 <strong>임시 객체</strong>는 <code>래퍼(wrapper) 객체</code>로 알려져 있다. 문자열과 숫자, 불리언 값의 프로퍼티는 읽기 전용이고, 이 값들에 새로운 프로퍼티를 정의할 수 없다는 점에서 이 값들이 객체와 다르다는 사실을 알아야 한다.<br><br>String()과 Number(), Boolean() 생성자를 사용해 명시적으로 래퍼 객체를 생성할 수도 있다. 자바스크립트는 래퍼 객체를 필요에 따라 기본 타입으로 변환한다. == 동치 연산자는 값과 그 값의 래퍼 객체를 동등하게 다루지만 === 엄격한 동치 연산자로 이를 구별할 수 있다. (typeof 연산자는 기본 타입과 래퍼 객체의 차이점을 보여줄 수 있다.)</p>
<h2 id="37-변경-불가능한-원시-타입-값과-변경-가능-객체-참조"><a href="#3-7-변경-불가능한-원시-타입-값과-변경-가능-객체-참조" class="headerlink" title="3.7 변경 불가능한 원시 타입 값과 변경 가능 객체 참조"></a><span style="color:red">3.7 변경 불가능한 원시 타입 값과 변경 가능 객체 참조</span></h2><p>자바스크립트에서 <strong>원시 타입(undefined, null, 불리언, 숫자, 문자열) 값</strong>과 <strong>객체(배열과 함수를 포함한)</strong> 사이에는 근본적인 차이점이 있다. 원시 타입의 값은 수정할 수 없다는것이다. 문자열 같은 경우 문자열을 수정하는 모든 문자열 메서드는 새로운 문자열을 반환한다. 원시 타입은 값으로 비교된다. 두 값은 같은 값이어야만 같다. 문자열 같은 경우 서로 다른 문자열 값을 비교할 때, 자바스크립트는 두 문자열의 길이가 같고 각 인덱스에 있는 문자들이 같다면 두 문자열을 같다고 판단한다.<br><br>객체는 원시 타입과는 다르다. 객체는 자신의 값을 변경할 수 있다. <strong>객체는 값으로 비교되지 않는다. 두 객체가 같은 프로퍼티와 값을 가지고 있어도 두 객체는 같지 않다.</strong> 그리고 두 배열은 같은 순서로 같은 원소를 갖고 있어도 같지 않다.<br><br>객체는 <code>참조 타입(reference type)</code>으로 불리는데, 이는 자바스크립트의 원시 타입과 구별하기 위해서다. <strong>객체의 값은 참조다.</strong> 객체는 참조로 비교될 수 있다. 두 객체 값은 그들이 같은 객체를 참조하면 같다. 객체는 새로운 복사본을 생성하지 않기 때문에 객체 혹은 배열의 새로운 복사본을 만들고 싶다면 <strong>명시적으로 객체의 프로퍼티 또는 배열의 원소를 복사</strong>해야 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];                  <span class="comment">// 복사하고자 하는 배열</span></span><br><span class="line"><span class="keyword">var</span> b = [];                               <span class="comment">// 복사하고자 하는 배열</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;       <span class="comment">// 배열 a의 각 인덱스</span></span><br><span class="line">    b[i] = a[i];                          <span class="comment">// a의 원소를 b로 복사한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>두 다른 객체 또는 배열을 서로 비교하고 싶다면 그들의 프로퍼티 또는 원소를 비교해야 한다.</p>
<hr>
<h2 id="38-타입-변환"><a href="#3-8-타입-변환" class="headerlink" title="3.8 타입 변환"></a>3.8 타입 변환</h2><p>자바스크립트는 타입에 매우 유연하다. 자바스크립트가 문자열을 원한다면, 문자열이 올 자리에 어떤 값을 전달하더라도 문자열로 변환될 것이고, 숫자를 원한다면 숫자가 올 자리에 다른 어떤 값이 오더라도 숫자로 변환될 것이다.(또는 의미 있는 변환을 할 수 없다면 NaN으로 변환된다.)</p>
<h4 id="381-변환과-동치"><a href="#3-8-1-변환과-동치" class="headerlink" title="3.8.1 변환과 동치"></a>3.8.1 변환과 동치</h4><p>자바스크립트는 <strong>값의 타입을 유연하게 변환</strong>시킬 수 있다. 따라서, 동치 연산자 ==도 유연하게 동작한다. 다음은 모두 true를 반환한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>     <span class="comment">// 이 두 값은 같다고 판단된다.</span></span><br><span class="line"><span class="string">"0"</span> == <span class="number">0</span>              <span class="comment">// 비교하기 전에 숫자로 변환된다.</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>            <span class="comment">// 불리언은 비교하기 전에 숫자로 변환한다.</span></span><br><span class="line"><span class="string">"0"</span> == <span class="literal">false</span>          <span class="comment">// 두 피연선자는 비교하기 전에 숫자로 변환된다.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>서로 변환 가능한 값이라고 해서 동치는 아니다.</strong> undefined가 불리언 값이 올 자리에 사용되면 false로 변환된다. 하지만 이것이 undefined == false 임을 의미하지는 않는다. if문은 undefined를 false로 변환하지만, == 연산자는 undefined를 불리언으로 변환하지 않는다.</p>
<h4 id="382-명시적-변환"><a href="#3-8-2-명시적-변환" class="headerlink" title="3.8.2 명시적 변환"></a>3.8.2 명시적 변환</h4><p>자바스크립트는 많은 형 변환을 자동으로 수행하지만, 명시적 변환이 필요할 때가 있다. 명시적으로 타입변환을 수행하는 가장 간단한 방법은 Boolean(), Number(), String(), Object() 함수를 사용하는 것이다. new 연산자 없이 호출되면, 이 함수들은 <strong>변환 함수</strong>로 작동한다.</p>
<h4 id="383-객체에서-원시-타입으로-변환"><a href="#3-8-3-객체에서-원시-타입으로-변환" class="headerlink" title="3.8.3 객체에서 원시 타입으로 변환"></a>3.8.3 객체에서 원시 타입으로 변환</h4><p>모든 객체는 두 개의 타입 변환 메서드를 상속한다.</p>
<ul>
<li>toString() : 객체를 <strong>문자열</strong>로 표현하여 반환한다.</li>
<li>valueOf() : 기본적으로 원시 타입을 반환하지 않고 단순히 <strong>객체</strong> 그 자신을 반환한다.</li>
</ul>
<p>자바스크립트는 toString(), valueOf() 순으로 메서드를 호출하여 문자열로 변환하여 반환한다. 만약 toString() 또는 valueOf() 로부터 원시타입 값을 얻을 수 없다면 <code>TypeError</code>를 발생시킨다. 객체를 숫자로 전환할 때는 문자열과 같은 방식으로 전환하지만, valueOf() 메서드를 먼저 호출한다.</p>
<hr>
<h2 id="39-변수-선언"><a href="#3-9-변수-선언" class="headerlink" title="3.9 변수 선언"></a>3.9 변수 선언</h2><p>자바스크립트에서는 변수를 사용하기 전에 변수 선언을 해야 한다. var 문을 통해서 변수를 선언하는데, var 문에서 변수에 초기 값을 지정하지 않는다면, 변수는 값이 설정될 때까지 <strong>undefined</strong> 값을 갖게 된다. 자바스크립트 변수 선언에는 타입을 명시하지 않는다.</p>
<h2 id="310-변수의-유효범위"><a href="#3-10-변수의-유효범위" class="headerlink" title="3.10 변수의 유효범위"></a><span style="color:red">3.10 변수의 유효범위</span></h2><p>변수의 유효범위란 프로그램에서 어떤 변수가 정의되어 있는 영역을 말한다.</p>
<h4 id="3101-함수-유효범위와-끌어올림hoisting"><a href="#3-10-1-함수-유효범위와-끌어올림-hoisting" class="headerlink" title="3.10.1 함수 유효범위와 끌어올림(hoisting)"></a><span style="color:red">3.10.1 함수 유효범위와 끌어올림(hoisting)</span></h4><p>C 같은 프로그래밍 언어에서 블록 안에 있는 코드는 자신만의 유효범위를 가지며, 변수는 해당 변수가 선언되지 않은 블록 밖에서는 보이지 않는다. 이를 <strong>블록 유효범위</strong>라고 부른다. 자바스크립트에서는 블록 유효범위의 개념이 없고 <strong>함수 유효범위</strong>를 사용한다. 변수는 해당 변수가 정의된 함수 안에서 보일 뿐 아니라, 그 함수 안에 중첩된 함수 안에서도 보인다. 이런 자바스크립트의 특징을 비공식적으로 <strong>끌어올림(hoisting)</strong>이라고 한다. 자바스크립트의 코드는 함수 안에 있는 모든 변수를 함수 맨 위로 ‘끌어올린’ 것처럼 동작한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(scope);       <span class="comment">// "global"이 아니라 "undefined"를 출력한다.</span></span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local"</span>;      <span class="comment">// 여기서 초기호하지만, 정의는 다른 곳에서 이루어진다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(scope);       <span class="comment">// "local"을 출력한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>위의 함수는 실제로 다음 코드와 같다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope;                <span class="comment">// 지역 변수는 함수 맨 꼭대기에서 선언한다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(scope);       <span class="comment">// scope 변수는 존재하지만 아직 "undefined" 값이다.</span></span><br><span class="line">  scope = <span class="string">"local"</span>;          <span class="comment">// 이제 scope 변수가 초기화되고 제대로 된 값이 있다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(scope);       <span class="comment">// 여기서는 기대한 값이 들어있다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>함수의 유효범위 규칙 때문에 지역 변수는 함수 전체에 걸쳐 정의된다. 지역 변수가 함수 전체에 걸쳐 정의되었더라도 var 문이 실행되고 나서야 실제로 초기화 된다. 따라서 변수 선언은 함수 맨 위로 <strong>‘끌어올려(hoisting)’</strong>지고 초기화는 나중에 이루어지게 된다.<br><br>블록 유효범위를 가진 프로그래밍 언어에서 일반적으로 변수를 선언하는 좋은 프로그래밍 방법은, <strong>가능한 한 그 변수가 사용되는 가장 가까운 곳에서 선언하는 것이다. 하지만 자바스크립트는 블록 유효범위를 가지고 있지 않기 때문에 함수의 맨 위에 선언해야할지도 모른다.</strong></p>
<h4 id="3103-유효범위-체인"><a href="#3-10-3-유효범위-체인" class="headerlink" title="3.10.3 유효범위 체인"></a><span style="color:red">3.10.3 유효범위 체인</span></h4><p><strong>자바스크립트는 언어적으로 유효범위를 갖고 있는 언어다.</strong> 변수의 유효범위란 정의된 변수를 사용 가능한 소스코드의 집합으로 생각할 수 있다.<br><br>지역 변수를 객체의 프로퍼티로 생각한다면, 변수 유효범위를 다른 관점으로 볼 수도 있다. 자바스크립트의 모든 코드 무더기는 그것과 연관된 유효범위 체인을 갖고 있다. 이 유효범위 체인은 해당 코드 무더기의 ‘범위 안’에 있는 변수를 정의하는 <strong>객체의 체인, 리스트</strong>다.<br><br>최상위 자바스크립트 코드의 경우, 유효범위 체인은 단 하나의 ‘전역 객체’만으로 이루어진다. 중첩되지 않은 함수의 유효 범위 체인은 두 개의 객체로 이루어진다. 하나는 함수 매개변수와 지역 변수를 정의하는 객체고, 다른 하나는 전역 객체다. 중첩된 함수에서 유효범위 체인은 세 개 이상의 객체를 갖는다. 함수가 호출될 때, 해당 함수의 지역변수를 저장하기 위해서 새로운 객체를 하나 생성하고, 해당 객체를 기존에 저장된 유효범위 체인에 추가한다. 중첩 함수의 경우에는 외부에서 함수를 호출할 때마다 중첩된 함수가 매번 선언된다.</p>
<p><br><br><strong>출처 : <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10338797" rel="external nofollow noopener noreferrer" target="_blank">“JavaScript: The Definitive Guide, by David Flanagan (O’Reilly). Copyright 2011 David Flanagan, 978-0-596-80552-4”</a></strong></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-25T16:10:32.000Z">2017-01-26</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    4분 읽기 (대략 665 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/26/JavaScript/complete-guide-to-javascript-chapter-2/">자바스크립트 완벽가이드 2장 (어휘 구조)</a>
            
        </h1>
        <div class="content">
            <p>프로그래밍 언어의 어휘 구조는 프로그램을 <strong>어떻게 작성</strong>해야 하는지를 알려주는 기본 규칙이다. 어휘 구조는 가장 저수준 문법이다.</p>
<h2 id="21-문자-집합"><a href="#2-1-문자-집합" class="headerlink" title="2.1 문자 집합"></a>2.1 문자 집합</h2><p>자바스크립트 프로그램은 Unicode 문자 집합을 사용해 작성된다.</p>
<h4 id="211-대소문자-구분"><a href="#2-1-1-대소문자-구분" class="headerlink" title="2.1.1 대소문자 구분"></a>2.1.1 대소문자 구분</h4><p>자바스크립트는 대소문자를 구분하는 언어이다. 그러나 HTML은 대소문자를 구별하지 않는다.</p>
<h4 id="212-공백-줄바꿈-제어-문자"><a href="#2-1-2-공백-줄바꿈-제어-문자" class="headerlink" title="2.1.2 공백, 줄바꿈 제어 문자"></a>2.1.2 공백, 줄바꿈 제어 문자</h4><p>자바스크립트는 프로그램 코드 내의 토큰들 사이에 있는 공백들을 무시한다. 대부분의 경우, 줄바꿈 문자도 무시한다.</p>
<h4 id="213-유니코드-이스케이프-시퀀스"><a href="#2-1-3-유니코드-이스케이프-시퀀스" class="headerlink" title="2.1.3 유니코드 이스케이프 시퀀스"></a>2.1.3 유니코드 이스케이프 시퀀스</h4><p>일부 컴퓨터 하드웨어와 소프트웨어에서는 특정 유니코드 글자들을 입력받고서 화면에 출력할 수 없는데 이와 같은 경우 프로그래머가 유니코드를 사용할 수 있도록 일련의 6자리 ASCII 문자열 시퀀스를 정의하고 있다. 유니코드 이스케이프 시퀀스는 <code>\u</code>로 시작하고, 그 뒤에 16진수 숫자 4개가 온다. (유니코드 이스케이프는 자바스크립트 문자열 리터럴이나 정규 표현식 리터럴에서 사용가능)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;café&quot; === &quot;caf\u00e9&quot; // true</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="23-리터럴"><a href="#2-3-리터럴" class="headerlink" title="2.3 리터럴"></a>2.3 리터럴</h2><p>리터럴(literal)은 프로그램에 <strong>직접 나타나는 데이터 값</strong>이다. 숫자, 문자열, 불리언, null 모두 리터럴이다.</p>
<hr>
<h2 id="25-선택적인-세미콜론-사용"><a href="#2-5-선택적인-세미콜론-사용" class="headerlink" title="2.5 선택적인 세미콜론 사용"></a>2.5 선택적인 세미콜론 사용</h2><p>자바스크립트가 항상 모든 줄바꿈을 세미콜론으로 해석하는 것은 아니다. 일반적으로 세미콜론 없이 코드를 해석할 수 없는 경우에만 줄바꿈을 세미콜론으로 해석한다. 일반적으로, 문장이 <strong>(, [, /, +, -</strong> 로 시작하면 자바스크립트 인터프리터는 해당 문장을 이전 문장에 이어서 해석한다.<br>다음 줄을 첫 줄의 문장과 이어서 하나로 처리할 수 없는 경우에만 줄바꿈을 세미콜론으로 해석한다는 일반 규칙에는 두 가지 예외가 있다.</p>
<ul>
<li><strong>return, break, continue 문</strong> 바로 다음에 사용했을 경우다. 따라서 return, break, continue와 다음에 오는 키워드 사이에 줄바꿈을 하지 말아야 한다.</li>
<li><strong>++나 – 연산자</strong>가 포함된 경우다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x</span><br><span class="line">++</span><br><span class="line">y</span><br><span class="line">// 위코드는 x++; y가 아니라 x; ++y로 해석된다.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br><strong>출처 : <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10338797" rel="external nofollow noopener noreferrer" target="_blank">“JavaScript: The Definitive Guide, by David Flanagan (O’Reilly). Copyright 2011 David Flanagan, 978-0-596-80552-4”</a></strong></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-25T15:10:32.000Z">2017-01-26</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    5분 읽기 (대략 764 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/26/JavaScript/complete-guide-to-javascript-chapter-1/">자바스크립트 완벽가이드 1장 (자바스크립트 소개)</a>
            
        </h1>
        <div class="content">
            <p>자바스크립트는 고수준이고 동적이며 타입을 명시할 필요가 없는 <strong>인터프리터 언어</strong>로, <strong>객체지향</strong> 프로그래밍 스타일과 <strong>함수형</strong> 프로그래밍 스타일을 모두 잘 표현하는 언어이다.</p>
<blockquote>
<p><strong>인터프리터</strong>는 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다. 원시 코드를 기계어로 번역하는 <strong>컴파일러</strong>와 대비된다. 인터프리터는 다음의 과정 가운데 적어도 한 가지 기능을 가진 프로그램이다. 구글의 <code>V8</code>엔진 이라는것은 결국 인터프리터인것이다.<br>출처 : <a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0" rel="external nofollow noopener noreferrer" target="_blank">위키백과 - 인터프리터</a></p>
</blockquote>
<p>자바스크립트는 웹 초창기에 현재 <code>오라클</code>이라고 불리는 썬마이크로시스템즈에서 상표권 라이센스를 갖고 있고, 언어 자체 구현은 현재 <code>모질라</code>라고 불리는 넷스케이프에서 담당했다. 넷스케이프는 이 언어를 표준화 하기 위해서 <strong>ECMA(European Computer Manufacturer’s Association)</strong>에 제출했는데, 상표권 문제로 언어의 이름을 <strong>ECMAScript</strong>라고 정했다. 깉은 이유로, 마이크로소프트가 제작한 언어의 이름은 JScript가 되었지만 사람들은 이들 모두를 <strong>자바스크립트</strong>라고 부른다.<br>지난 십 년 동안 모든 웹브라우저에 탑재된 자바스크립트는 ECMAScript 3 구현체였다. 최근에는 ECMAScript 5 그리고 ECMAScript 6까지 정의되었다.<br>자바스크립트 언어 자체만 볼 때, 실질적인 버전은 ECMAScript 3과 5, 6뿐이다. (ECMAScript 4는 기존의 자바스크립트와 다른점이 많아 세상에 나오지 못했다.)</p>
<p>모든 언어는 기초적인 입출력을 처리하는 데 필요한 함수 API나 기반이 되는 플랫폼 또는 표준 라이브러리를 포함하고 있지만 자바스크립트 언어의 코어는 <strong>최소한의 API만 정의</strong>하고 입출력과 관련된 기능은 포함하고 있지 않다. 입출력을 비롯해 통신과 파일 저장, 그래픽 처리와 같은 복잡한 기능들은 자바스크립트를 내장하고 있는 <strong>‘호스트 환경’</strong>에서 담당한다. 브라우저가 자바스크립트 엔진을 내장하고 있기 때문에 클라이언트 측 자바스크립트의 호스트 환경은 웹브라우저다.</p>
<h2 id="11-자바스크립트-코어"><a href="#1-1-자바스크립트-코어" class="headerlink" title="1.1 자바스크립트 코어"></a>1.1 자바스크립트 코어</h2><p>– <strong>표현식 (expression)</strong> : 값으로 평가될 수 있는 구절, 프로그램의 상태를 바꾸지는 않는다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">topic: &quot;Javascript&quot;,</span><br><span class="line">fat: true</span><br><span class="line">&#125;;</span><br><span class="line">book.topic // =&gt; &quot;Javascript&quot;</span><br></pre></td></tr></table></figure></p>
<p>– <strong>설명문 (statement)</strong> : 프로그램의 상태를 변경할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var count = 0;</span><br><span class="line">count++;</span><br><span class="line">count--;</span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>출처 : <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10338797" rel="external nofollow noopener noreferrer" target="_blank">“JavaScript: The Definitive Guide, by David Flanagan (O’Reilly). Copyright 2011 David Flanagan, 978-0-596-80552-4”</a></strong></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-21T15:00:00.000Z">2017-01-22</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/React-Native/">React Native</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12분 읽기 (대략 1830 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/22/ReactNative/image-res-management(1)/">정적 이미지 사용하기</a>
            
        </h1>
        <div class="content">
            <h2 id="index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><ol>
<li><a href="#1">React Native 정적 이미지 사용하기</a></li>
<li><a href="#2">Native 측면에서 바라보기</a><ol>
<li><a href="#2-1">Android</a></li>
<li><a href="#2-2">iOS</a></li>
<li><a href="#2-3">이미지 사용하기</a></li>
</ol>
</li>
<li><a href="#3">코드로 한번 더 복습하기</a></li>
<li><a href="#4">눈으로 확인하는 결과</a></li>
</ol>
<hr>
<p>React Native는 <strong>웹뷰</strong>를 통해 인터페이스를 구축하는 하이브리드 방식(예를 들면 Ionic)과는 달리 자바스크립트로 작성한 코드가 <strong>Native UI 컴포넌트</strong>로 만들어집니다. React Native에서 이미지를 사용하는 코드는 iOS와 Android 모두 통합되어 있지만, 정적인 이미지 파일을 추가하는 부분은 <strong>Naming</strong>에 있어 차이가 있습니다. 이번에는 React Native에서 정적 이미지를 사용하는 방법과, 정적 이미지 추가 시 반복되는 작업을 좀 더 효율적으로 할 수 있도록 Node를 사용하여 스크립트를 작성하는 부분을 다뤄보도록 하겠습니다. 글 작성 기준 React Native의 최신버전은 0.4입니다.</p>
<hr>
<p><span id="1"></span></p>
<h2 id="react-native-정적-이미지-사용하기"><a href="#React-Native-정적-이미지-사용하기" class="headerlink" title="React Native 정적 이미지 사용하기"></a>React Native 정적 이미지 사용하기</h2><p>React Native에서 <strong>정적 이미지</strong>를 추가하는 방법은 <a href="https://facebook.github.io/react-native/docs/images.html" rel="external nofollow noopener noreferrer" target="_blank">공식홈페이지</a>에서도 잘 설명되어 있지만 한번 더 살펴보겠습니다.</p>
<p>다음과 같이 react-native 의 기본적인 <code>Image</code> 컴포넌트를 통해 정적인 이미지 파일을 사용할 수 있습니다. 아래의 코드는 작성된 컴포넌트의 파일과 같은 경로에 있는 <code>gold.png</code>라는 파일을 사용합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Image source=&#123;require(&apos;./gold.png&apos;)&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>하나의 파일을 두개의 플랫폼(iOS와 Android)에서 같이 사용할 수 있지만 만약 플랫폼에 따라 다른 이미지를 사용하고 싶다면 <code>gold.png</code>라는 파일을 <code>gold.android.png</code>와 <code>gold.ios.png</code>로 각각 저장하여 사용할 수 있습니다.  이와 같은 경우는 주로 Android와 iOS에서 같은 목적으로 사용되는 이미지가 다를 경우 유용합니다. (React Native에서 iOS와 Android의 Entry file이 index.ios.js와 index.android.js 인것과 같은 개념입니다.)</p>
<p>또한 React Native의 <code>packager</code>는 <strong>플랫폼</strong> 뿐만 아니라 <strong>디바이스 스크린의 해상도</strong>에 따라서도 다른 이미지를 제공할 수 있습니다. 따라서 다음과 같이 이미지 파일의 이름을 해상도에 따라 달리하여 사용할 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├─ Test.js</span><br><span class="line">└── img/</span><br><span class="line">    ├── gold@2x.png</span><br><span class="line">    └── gold@3x.png</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;/* Test.js 코드의 render 부분 */&#125;</span><br><span class="line">&lt;Image source=&#123;require(&apos;./img/gold.png&apos;)&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>파일 구조와 Test.js의 코드가 위와 같을 때 iPhone 6와 iPhone 6 Plus는 각각 gold@2x.png와 gold@3x.png 파일을 사용합니다. 만약 디바이스 스크린의 해상도에 해당하는 파일이 없다면 <strong>가장 밀접한 해상도를 가진 파일</strong>을 사용합니다.</p>
<p>정리하면 <strong>디바이스의 플랫폼과 해상도</strong>에 따라 파일을 사용하고 싶을 경우 다음과 같이 사용할 수 있습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├─ Test.js</span><br><span class="line">└── img/</span><br><span class="line">    ├── gold@2x.android.png</span><br><span class="line">    ├── gold@2x.ios.png</span><br><span class="line">    ├── gold@3x.android.png</span><br><span class="line">    └── gold@3x.ios.png</span><br></pre></td></tr></table></figure></p>
<p>React Native에서 정적인 이미지를 사용할 경우 주의해야할 점은 <a href="https://facebook.github.io/react-native/docs/images.html" rel="external nofollow noopener noreferrer" target="_blank">공식홈페이지</a>를 참고하시면 좋을것 같습니다.</p>
<hr>
<p><span id="2"></span></p>
<h2 id="native-측면에서-바라보기"><a href="#Native-측면에서-바라보기" class="headerlink" title="Native 측면에서 바라보기"></a>Native 측면에서 바라보기</h2><p>React Native는 기존 Android와 iOS에서 이미지를 추가하여 사용하는 방법을 그대로 사용할 수도 있습니다. 이미 위의 방법으로 해결이 가능하며 이 방법이 좀 더 복잡하기에 사용을 권장드리지 않지만 이런방법으로도 가능하다는걸 알고계시면 좋을것 같습니다. Native에서 Android와 iOS의 이미지 파일은 다음과 같은 경로에 저장하여 사용합니다.</p>
<ul>
<li>Android <code>Test-app/android/app/src/main/res/</code></li>
<li>iOS <code>Test-app/ios/Test-app/images.xcassets/</code></li>
</ul>
<p><span id="2-1"></span></p>
<h3 id="android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>Android에서 해상도별로 이미지를 추가하는 방법을 알아보겠습니다.</p>
<p>1.처음 프로젝트 생성시에는 <strong>drawable</strong>관련 폴더가 없으므로 <code>android/app/src/main/res/</code> 에 해당 폴더들을 생성합니다.</p>
<ul>
<li>drawable-mdpi</li>
<li>drawable-hdpi</li>
<li>drawable-xhdpi</li>
<li>drawable-xxhdpi</li>
<li>drawable-xxxhdpi</li>
</ul>
<p>2.해상도 별로 각 drawable 폴더에 파일을 저장합니다. (각 폴더별 저장되는 이미지는 파일명이 모두 같아야합니다.) 파일명이 <code>gold.png</code> 라면 각 폴더에는 다음과 같이 존재하게 됩니다.</p>
<ul>
<li>drawable-mdpi/gold.png</li>
<li>drawable-hdpi/gold.png</li>
<li>drawable-xhdpi/gold.png</li>
<li>drawable-xxhdpi/gold.png</li>
<li>drawable-xxxhdpi/gold.png</li>
</ul>
<p><span id="2-2"></span></p>
<h3 id="ios"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p>iOS에서 이미지를 추가하는 방법은 Android에 비해 좀 더 번거롭습니다. 글로 설명하는것보다 사진을 참고하는 것이 이해하기 쉽기 때문에 사진을 첨부합니다.</p>
<p>1.먼저 xcode에서 프로젝트의 root폴더에서 ios폴더를 로드한 후 <strong>images.xcassets</strong> 폴더를 클릭 후 AppIcon 아래의 빈공간을 우클릭하면 <strong>New Image set</strong>라는 메뉴가 있습니다. 클릭 후 1x, 2x, 3x에 이미지를 넣으신 후 이미지의 이름을 설정합니다.<br><img src="/images/post/2017-01-22/iOS-add-image1.png" alt="xcode에서 이미지 추가1"></p>
<p>2.위와 같이 이미지를 넣고나면 해당 경로에 다음과 같은 형식으로 파일이 생성됩니다. <strong>Contents.json</strong>은 이미지 파일에 대한 정보를 갖고 있습니다.<br><img src="/images/post/2017-01-22/iOS-add-image2.png" alt="xcode에서 이미지 추가2"></p>
<p><span id="2-3"></span></p>
<h4 id="이미지-사용하기"><a href="#이미지-사용하기" class="headerlink" title="이미지 사용하기"></a>이미지 사용하기</h4><p>Android와 iOS에 이미지 추가가 모두 끝났습니다. 추가한 이미지를 React Native 에서 사용해보겠습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;/* Test.js 코드의 render 부분 */&#125;</span><br><span class="line">&lt;Image source=&#123;require(&apos;image!gold&apos;)&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>위의 코드에 <strong>image!</strong>라는 부분의 추가와 <strong>이미지 파일의 확장자</strong>가 사라졌다는게 전과 다릅니다. 이미지의 위치를 알리는 <strong>경로</strong> 또한 명시할 필요가 사라졌습니다.</p>
<hr>
<p><span id="3"></span></p>
<h2 id="코드로-한번-더-복습하기"><a href="#코드로-한번-더-복습하기" class="headerlink" title="코드로 한번 더 복습하기"></a>코드로 한번 더 복습하기</h2><p>이제 React Native에서 정적인 이미지를 추가하는 방법을 모두 알아보았습니다. 마지막으로 코드상에서 정적인 이미지를 사용하는 방법을 정리해보겠습니다.</p>
<p>– Native 에서 이미지를 추가하는 방법을 사용하였을 경우<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;/* Test.js 코드의 render 부분 */&#125;</span><br><span class="line">&lt;Image source=&#123;require(&apos;image!gold&apos;)&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>– 프로젝트 폴더내에 추가 후 상대경로를 사용하는 경우<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;/* Test.js 코드의 render 부분 */&#125;</span><br><span class="line">&lt;Image source=&#123;require(&apos;./image/gold.png&apos;)&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>– 첫번째와 두번째 방법을 모두 사용하는 경우 (Native에서 사용되는 폴더에서 이미지를 찾은 후 존재하지 않을 경우 상대경로를 사용하여 이미지를 사용)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;/* Test.js 코드의 render 부분 */&#125;</span><br><span class="line">&lt;Image source=&#123; &#123;uri: &apos;gold&apos;, isStatic: true&#125; &#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><span id="4"></span></p>
<h2 id="눈으로-확인하는-결과"><a href="#눈으로-확인하는-결과" class="headerlink" title="눈으로 확인하는 결과"></a>눈으로 확인하는 결과</h2><p>iPhone6와 iPhone6 Plus 에서 Gold 이미지가 기기의 해상도에 맞게 다른 파일로 사용된것을 확인할 수 있습니다.</p>
<div style="display:flex; justify-content: center"><br><figure style="width: 350px; max-height: 580px"><br><img src="/images/post/2017-01-22/iPhone6.png" alt="iPhone6 에서의 Gold 이미지"><br></figure><br><br><figure style="width: 350px; max-height: 580px"><br><img src="/images/post/2017-01-22/iPhone6Plus.png" alt="iPhone6Plus 에서의 Gold 이미지"><br></figure><br></div>

<p><br>다음 포스팅에서는 정적인 이미지 파일을 쉽게 추가하여 사용할 수 있도록 자동화하는 스크립트 작성에 대해서 작성하겠습니다.</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2016-12-12T15:00:00.000Z">2016-12-13</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/Linux-Ubuntu/">Linux & Ubuntu</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    7분 읽기 (대략 987 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2016/12/13/Linux & Ubuntu/bashrc-bash_profile/">.bashrc 와 .bash_profile 의 차이</a>
            
        </h1>
        <div class="content">
            <h2 id="index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><ol>
<li><a href="#1">bash 쉘(Shell) 이란?</a></li>
<li><a href="#2">Login Shell 과 Non-Login Shell</a></li>
<li><a href="#3">.bashrc 와 .bash_profile 의 차이</a></li>
</ol>
<hr>
<p><span id="1"></span></p>
<h2 id="bash-쉘shell-이란"><a href="#bash-쉘-Shell-이란" class="headerlink" title="bash 쉘(Shell) 이란?"></a>bash 쉘(Shell) 이란?</h2><p><code>쉘(Shell)</code>은 운영체제에서 <strong>사용자가 입력하는 명령을 읽고 해석하여 대신 실행해주는 프로그램</strong>입니다. 운영체제 상에서 다양한 운영체제 기능과 서비스를 구현하는 인터페이스를 제공하며, 사용자와 운영체제의 <code>내부(커널)</code> 사이의 인터페이스를 감싸는 층이기 때문에 셸이라는 이름이 붙었습니다. 쉘은 운영체제에서 필수적으로 존재합니다.</p>
<p>운영체제는 로그인한 사용자가 없다면 하나의 쉘도 실행되지 않은 상태이며, 사용자가 로그인을 시도하면 운영체제는 ID와 패스워드를 받아들이는 로기은 프로그램을 실행하고, 사용자가 입력한 ID와 패스워드를 검증한 후 인증된 사용자라면 쉘을 실행하여 사용자 세션을 쉘에게 전달합니다.</p>
<p>쉘의 역할은 사용자가 입력한 명령을 해석하여 대신 실행해주는 것입니다. 쉘의 내부 명령어라면 스스로 실행한 뒤 화면에 표시해주고 내부 명령어가 아니라면 <code>PATH 환경변수</code>에 지정된 경로에서 입력받은 명령과 같은 파일을 찾아 <code>exec() 시스템콜</code>을 호출하여 실행한 뒤 키보드와 마우스 등의 입력장치와 모니터에 해당하는 표준 출력장치의 제어권을 해당 프로그램에 넘겨준 뒤 프로그램이 끝날 때 까지 대기하는 역할을 합니다.</p>
<p><code>bash 쉘</code>은 유닉스에서 사용하는 커맨드 쉘의 일종으로 <a href="https://ko.wikipedia.org/wiki/GNU" rel="external nofollow noopener noreferrer" target="_blank">GNU 프로젝트</a>를 위해 만들어졌습니다. 초기의 유닉스 쉘인 본 쉘(Bourne Shell)과 새로 태어났다는 뜻의 영어 ‘born again’을 합쳐 <strong>본 어게인 쉘(Bourne-again Shell)</strong>이라고 불렸으나, 일반적으로 <code>bash</code>로 줄여 부릅니다.</p>
<hr>
<p><span id="2"></span></p>
<h2 id="login-shell-과-non-login-shell"><a href="#Login-Shell-과-Non-Login-Shell" class="headerlink" title="Login Shell 과 Non-Login Shell"></a>Login Shell 과 Non-Login Shell</h2><h4 id="login-shell"><a href="#Login-Shell" class="headerlink" title="Login Shell"></a>Login Shell</h4><p>Login은 ID와 패스워드를 입력해서 Shell을 실행하는 것을 말합니다. 따라서 ssh로 접속하거나 로컬에서 GUI를 통해 Shell을 실행하는 것은 Login Shell 입니다.<br><code>.profile</code>, <code>.bash_profile</code> 이 두 파일은 Login할 때 로드되는 파일입니다. <code>.profile</code>은 꼭 bash가 아니더라도 로그인하면 로드되며, <code>.bash_profile</code>은 꼭 <strong>bash로 로그인 할 때</strong>만 실행됩니다.</p>
<h4 id="non-login-shell"><a href="#Non-Login-Shell" class="headerlink" title="Non-Login Shell"></a>Non-Login Shell</h4><p>Non-Login Shell은 로그인 없이 실행하는 Shell을 말합니다. ssh로 접속하고 나서 다시 bash를 실행하는 경우나, GUI 세션에서 터미널을 띄우는 것도 여기 해당합니다. ‘sudo bash’나  ‘su’같은 것도 해당합니다.</p>
<hr>
<p><span id="3"></span></p>
<h2 id="bashrc-와-bash_profile-의-차이"><a href="#bashrc-와-bash-profile-의-차이" class="headerlink" title=".bashrc 와 .bash_profile 의 차이"></a>.bashrc 와 .bash_profile 의 차이</h2><h4 id="bashrc"><a href="#bashrc" class="headerlink" title=".bashrc"></a>.bashrc</h4><p>이미 로그인 한 상태에서 새 터미널 창을 열 때마다 로드됩니다. (Non-Login Shell에서 실행됩니다.)</p>
<h4 id="bash_profile"><a href="#bash-profile" class="headerlink" title=".bash_profile"></a>.bash_profile</h4><p>시스템에 로그인할 때마다 로드됩니다. (Login Shell에서 실행됩니다.) 대부분 <strong>개별 사용자에 대한 설정에 대한 코드</strong>들이 들어갑니다. 예를 들면 nvm(Node Version Manager)은 기본적으로 nvm을 사용하지 않고 Node를 설치할 때와는 다르게 각 사용자의 경로에 설치되게 되는데, 이럴때 nvm의 PATH를 .bash_profile 파일에 기재합니다.</p>
<h4 id="profile"><a href="#profile" class="headerlink" title=".profile"></a>.profile</h4><p>로그인할 때 로드됩니다. 개별 사용자에 대한 설정 코드들 중 bash와는 관계없는 부분을 기재합니다.</p>
<ul>
<li>만약 Mac에서 새 터미널 창을 열 때마다 <code>.bashrc</code>를 로드하고 싶다면 <code>.bash_profile</code>에서 .bashrc를 로드하면 됩니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Source bashrc</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
</ul>

        </div>
        
        
        
    </div>
</div>









<!-- For Google Adsense -->
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-3921438651818825" data-ad-slot="3015269677"></ins>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({});
</script>



    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous">
            <a class="is-flex-grow has-text-black-ter" href="/categories/Programming/archives/8/">이전</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/categories/Programming/archives/10/">다음</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link has-text-black-ter" href="/categories/Programming/">1</a></li>
            
            <li><span class="pagination-ellipsis has-text-black-ter">&hellip;</span></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/categories/Programming/archives/8/">8</a></li>
            
            <li><a class="pagination-link is-current" href="/categories/Programming/archives/9/">9</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/categories/Programming/archives/10/">10</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="is-rounded" src="/images/avatar.jpeg" alt="JongMin">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        JongMin
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        생각을 기록하자
                    </p>
                    
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        포스트
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            123
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        카테고리
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            21
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        태그
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            203
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/jongmin92" target="_blank" rel="external nofollow noopener noreferrer">
                팔로우</a>
        </div>
        
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/jongmin92">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Facebook" href="https://www.facebook.com/jongmin.kim.7796420">
                
                <i class="fab fa-facebook"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            최근 글
        </h3>
        
        <article class="media">
            
            <a href="/2020/01/02/Java/rsa/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="Encryption - RSA">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-01-02T13:29:00.000Z">2020-01-02</time></div>
                    <a href="/2020/01/02/Java/rsa/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Encryption - RSA</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Programming/">Programming</a> / <a class="has-link-grey -link" href="/categories/Programming/Java/">Java</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/12/26/Programming/2019-retrospect/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="2년차 LINE 서버 개발자의 2019년 회고">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-12-26T13:23:00.000Z">2019-12-26</time></div>
                    <a href="/2019/12/26/Programming/2019-retrospect/" class="title has-link-black-ter is-size-6 has-text-weight-normal">2년차 LINE 서버 개발자의 2019년 회고</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/12/23/Programming/hmac/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="HMAC을 이용한 무결성 보장">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-12-23T14:37:00.000Z">2019-12-23</time></div>
                    <a href="/2019/12/23/Programming/hmac/" class="title has-link-black-ter is-size-6 has-text-weight-normal">HMAC을 이용한 무결성 보장</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/12/18/Java/hash/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="Hash - MD5와 SHA256">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-12-17T15:23:00.000Z">2019-12-18</time></div>
                    <a href="/2019/12/18/Java/hash/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Hash - MD5와 SHA256</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Programming/">Programming</a> / <a class="has-link-grey -link" href="/categories/Programming/Java/">Java</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/12/07/Gradle/gradle-implementation/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="Gradle에서 Dependency Pollution 문제 해결하기">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-12-07T04:56:00.000Z">2019-12-07</time></div>
                    <a href="/2019/12/07/Gradle/gradle-implementation/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Gradle에서 Dependency Pollution 문제 해결하기</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Programming/">Programming</a> / <a class="has-link-grey -link" href="/categories/Programming/Gradle/">Gradle</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                카테고리
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/Algorithm/">
            <span class="level-start">
                <span class="level-item">Algorithm</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">14</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/Algorithm/BOJ/">
            <span class="level-start">
                <span class="level-item">BOJ</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">6</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Algorithm/Concept/">
            <span class="level-start">
                <span class="level-item">Concept</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">8</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/Book/">
            <span class="level-start">
                <span class="level-item">Book</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Database/">
            <span class="level-start">
                <span class="level-item">Database</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/">
            <span class="level-start">
                <span class="level-item">Programming</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">95</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/Programming/AWS/">
            <span class="level-start">
                <span class="level-item">AWS</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Git/">
            <span class="level-start">
                <span class="level-item">Git</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Gradle/">
            <span class="level-start">
                <span class="level-item">Gradle</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/HTML/">
            <span class="level-start">
                <span class="level-item">HTML</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Java/">
            <span class="level-start">
                <span class="level-item">Java</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">21</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/JavaScript/">
            <span class="level-start">
                <span class="level-item">JavaScript</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">15</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Linux-Ubuntu/">
            <span class="level-start">
                <span class="level-item">Linux & Ubuntu</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">5</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Node/">
            <span class="level-start">
                <span class="level-item">Node</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">5</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/RaspberryPi/">
            <span class="level-start">
                <span class="level-item">RaspberryPi</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">8</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/React-Native/">
            <span class="level-start">
                <span class="level-item">React Native</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Spring/">
            <span class="level-start">
                <span class="level-item">Spring</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">19</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Tool/">
            <span class="level-start">
                <span class="level-item">Tool</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/Project/">
            <span class="level-start">
                <span class="level-item">Project</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">6</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/Project/Emily/">
            <span class="level-start">
                <span class="level-item">Emily</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">6</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/Tip/">
            <span class="level-start">
                <span class="level-item">Tip</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.png" alt="92Hz" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 KimJongMin&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("ko");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'https://jongmin92.github.io',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/" rel="external nofollow noopener noreferrer" target="_blank">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="Zurück nach oben" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="입력 하세요...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '포스트',
                PAGES: '페이지',
                CATEGORIES: '카테고리',
                TAGS: '태그',
                UNTITLED: '(제목없음)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>