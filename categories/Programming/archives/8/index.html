<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="naver-site-verification" content="427d651b8544d9dd05f3baf8b71682504788ae7e"><title>카테고리: Programming - 92Hz</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="92Hz"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="92Hz"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="website"><meta property="og:title" content="92Hz"><meta property="og:url" content="https://jongmin92.github.io/"><meta property="og:site_name" content="92Hz"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jongmin92.github.io/img/og_image.png"><meta property="article:author" content="KimJongMin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jongmin92.github.io"},"headline":"92Hz","image":["https://jongmin92.github.io/img/og_image.png"],"author":{"@type":"Person","name":"KimJongMin"},"description":""}</script><link rel="alternate" href="/rss2.xml" title="92Hz" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-90389042-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-90389042-1');</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="ca-pub-3921438651818825" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="92Hz" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">카테고리</a></li><li class="is-active"><a href="#" aria-current="page">Programming</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-07-05T15:00:00.000Z" title="7/6/2017, 12:00:00 AM">2017-07-06</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-22T13:12:18.893Z" title="3/22/2021, 10:12:18 PM">2021-03-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/RaspberryPi/">RaspberryPi</a></span><span class="level-item">3분안에 읽기 (약 439 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/07/06/RaspberryPi/0-Intro/">0. 라즈베리파이 강의 소개</a></h1><div class="content"><p>오랜만에 포스팅을 하는 것 같습니다. 그간 회사에서 운이 좋게 3주간 보조 강사로 강의를 할 수 있는 기회를 얻어 강의를 하고 있습니다. 신기하게도 제가 졸업한 인천대학교에서 강의를 하고있습니다.</p>
<p>강의 주제는 **<code>라즈베리파이에 음성인식 서비스(STT, TTS)와 GPIO를 활용해 나만의 비서</code>**를 만들기 입니다. 라즈베리파이 같은 경우 이전에 친구들과 스마트미러를 만들며 사용했던 경험이 있었기에 낯설지 않았지만, 강의를 준비하고 강의자료를 만들면서 생각보다 여러가지로 고난을 겪었습니다…</p>
<p>단순히 발표자료가 아닌 누군가에게 지식을 잘 전달할 수 있도록 만들어야 하다보니 생각보다 만드는게 쉽지 않았습니다. 그래도 혹시나 필요하신 분이 있을까 하여 만들었던 강의자료를 공개합니다. 파이썬 관련된 부분은 책을 많이 참고하였기에 생략하고 <strong>라즈베리파이와 GPIO, 그리고 음성인식 프레임워크로 사용했던 Jasper에 대한 강의자료를 업로드</strong>하겠습니다. 다음은 강의 목차입니다.</p>
<h1 id="라즈베리파이-강의-목차"><a href="#라즈베리파이-강의-목차" class="headerlink" title="- 라즈베리파이 강의 목차 -"></a>- 라즈베리파이 강의 목차 -</h1><ol>
<li>라즈베리파이 OS 설치 &amp; 설정</li>
<li>Unix / Linux 소개</li>
<li>사용자 관리, 원격접속 vi 편집기</li>
<li>bash 설정, vim 설정, gist 사용하기</li>
<li>GPIO, LED, BreadBoard</li>
<li>Extra GPIO</li>
<li>Jasper</li>
</ol>
<p>앞으로 강의에 대한 **<code>간단한 내용정리</code>**와 사용한 **<code>pdf 파일</code>**을 업로드하도록 하겠습니다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-06-17T15:00:00.000Z" title="6/18/2017, 12:00:00 AM">2017-06-18</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-22T12:44:36.377Z" title="3/22/2021, 9:44:36 PM">2021-03-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/JavaScript/">JavaScript</a></span><span class="level-item">15분안에 읽기 (약 2204 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/06/18/JavaScript/class/">ES6 Class 파헤치기</a></h1><div class="content"><h1 id="ES6-Class-문법"><a href="#ES6-Class-문법" class="headerlink" title="ES6 Class 문법"></a>ES6 Class 문법</h1><p>JavaScript **<code>Class</code>**는 ECMAScript 6을 통해 소개되었습니다. ES6의 Class는 기존 <strong><code>prototype</code></strong> 기반의 상속을 보다 명료하게 사용할 수 있도록 문법을 제공합니다. 이를  <strong>Syntatic Sugar</strong>라고 부르기도 합니다.</p>
<blockquote>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Syntactic_sugar">Syntatic Sugar</a> : 읽고 표현하는것을 더 쉽게 하기 위해서 고안된 프로그래밍 언어 문법을 말합니다.</p>
</blockquote>
<p>JavaScript를 ES6를 통해 처음 접하시는 분들은 알아두셔야할 것이 JavaScript의 Class는 다른 객체지향 언어(C++, C#, Java, Python, Ruby 등…)에서 사용되는 Class 문법과는 다르다는 것입니다. JavaScript에는 Class라는 개념이 없습니다.<br>Class가 없기 때문에 기본적으로 Class 기반의 상속도 불가능합니다. 대신 다른 언어에는 존재하지 않는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain">프로토타입(Prototype)</a>이라는 것이 존재합니다. JavaScript는 이 <strong>prototype을 기반으로 상속을 흉내내도록 구현해 사용</strong>합니다. Prototype을 처음 접하시는 분은 <a href="https://jongmin92.github.io/2017/03/14/JavaScript/understand-prototype/">“Prototype 이제는 이해하자”</a>를 참고하시면 도움이 될것같습니다.</p>
<h1 id="Class-정의"><a href="#Class-정의" class="headerlink" title="Class 정의"></a>Class 정의</h1><p>JavaScript에서 Class는 사실 <strong>함수</strong>입니다. 함수를 <strong>함수 선언</strong>과 <strong>함수 표현식</strong>으로 정의할 수 있듯이 class 문법도 <strong>class 선언</strong>과 <strong>class 표현식</strong> 두가지 방법으로 정의가 가능합니다.</p>
<p>JavaScript 엔진은 function 키워드를 만나면 Function 오브젝트를 생성하듯, class 키워드를 만나면 Class 오브젝트를 생성합니다. class는 클래스를 선언하는 키워드이고 Class 오브젝트는 엔진이 class 키워드로 생성한 오브젝트입니다.</p>
<h2 id="Class-선언"><a href="#Class-선언" class="headerlink" title="Class 선언"></a>Class 선언</h2><p>함수 선언과 달리 클래스 선언은 <strong>호이스팅</strong>이 일어나지 않기 때문에, 클래스를 사용하기 위해서는 먼저 선언을 해야합니다. 그렇지 않으면 <strong>ReferenceError</strong> 가 발생합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Class-표현식"><a href="#Class-표현식" class="headerlink" title="Class 표현식"></a>Class 표현식</h2><p>Class 표현식은 이름을 가질 수도 있고 갖지 않을 수도 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> People = <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> People = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>constructor는 클래스 인스턴스를 생성하고 생성한 인스턴스를 초기화하는 역할을 합니다. <strong>new People()</strong> 코드를 실행하면 <strong>People.prototype.constructor</strong>가 호출됩니다. 이를 default constructor라고 하며 constructor가 없으면 인스턴스를 생성할 수 없습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&#x27;KimJongMin&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>new People(‘KimJongMin’)을 실행하면 People 클래스에 작성한 constructor가 자동으로 호출되고 파라미터 값으로 ‘KimJongMin’을 넘겨 줍니다.</p>
<p>new 연산자가 인스턴스를 생성하는 것처럼 보이지만, 사실 new 연산자는 constructor를 호출하면서 파라미터를 넘겨주는 역할만 합니다. 호출된 constructor가 인스턴스를 생성하여 반환하면 new 연산자가 받아 new를 실행한 곳으로 반환합니다. 과정은 다음과 같습니다.</p>
<ol>
<li>new People(‘KimJongMin’)을 실행</li>
<li>new 연산자가 constructor를 호출하면서 파라미터 전달</li>
<li>constructor에 작성한 코드를 실행하기 전에 빈 Object 를 생성</li>
<li>constructor 코드를 실행</li>
<li>생성한 Object(인스턴스)에 property 할당 (인스턴스를 먼저 생성했기 때문에 this로 Object 참조 가능</li>
<li>생성한 Object 반환</li>
</ol>
<p>다음은 생성된 인스턴스의 구조입니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(people);</span><br></pre></td></tr></table></figure>

<p><img src="/images/post/2017-06-18/instance-structure.png"></p>
<p>people 인스턴스의 **_<em>proto_</em>**는 People Class 오브젝트와 함께 생성된 <strong>Prototype object</strong>를 가리키고 있습니다. 결국 Class 문법을 이용한 코드를 prototype 기반의 코드로 변경하면 다음과 같습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">People.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Prototype-기반-상속-ES5-과-Class-기반-상속-ES6-비교"><a href="#Prototype-기반-상속-ES5-과-Class-기반-상속-ES6-비교" class="headerlink" title="Prototype 기반 상속(ES5)과 Class 기반 상속(ES6) 비교"></a>Prototype 기반 상속(ES5)과 Class 기반 상속(ES6) 비교</h2><p>먼저 ES5에서 Prototype을 사용하여 상속을 구현하는 방법을 살펴보고, 그 후 ES6에서 Class로 상속을 구현하는 형태를 보겠습니다.</p>
<h3 id="ES5-Prototype-기반-상속"><a href="#ES5-Prototype-기반-상속" class="headerlink" title="ES5 Prototype 기반 상속"></a>ES5 Prototype 기반 상속</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; makes a noise.&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Lion</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// `super()` 호출</span></span><br><span class="line">  Cat.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Cat` 클래스 상속</span></span><br><span class="line">Lion.prototype = <span class="built_in">Object</span>.create(Cat.prototype);</span><br><span class="line">Lion.prototype.constructor = Lion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `speak()` 메서드 오버라이드</span></span><br><span class="line">Lion.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Cat.prototype.speak.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; roars.&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lion = <span class="keyword">new</span> Lion(<span class="string">&#x27;Samba&#x27;</span>);</span><br><span class="line">lion.speak();</span><br><span class="line"></span><br><span class="line">[결과]</span><br><span class="line">Sambda makes a noise.</span><br><span class="line">Sambda roars.</span><br></pre></td></tr></table></figure>

<p>new Lion()을 실행하면 Lion()이 호출되고, default constructor를 호출합니다. 그래서 Lion()을 생성자(constructor) 함수라고 합니다.</p>
<p>생성자 함수가 있으면 Cat.prototype.speak와 같이 prototype에 메서드를 연결한 코드가 있습니다. 이와 같이 prototype에 작성하지 않으면 각각의 인스턴스에 메서드가 생성되게 됩니다. 이 형태가 ES5에서 인스턴스를 구현하는 기본 형태 입니다.</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create()</a>를 통해 Cat.prototype에 연결된 메서드를 Lion.prototype.__proto__에 첨부합니다. Lion.prototype에는 constructor가 연결되어 있는데 prototype을 재 할당했기 때문에 지워진 constructor를 다시 할당해 줍니다.</p>
<p>결과적으로 Lion 생성자 함수의 구조는 다음과 같습니다.</p>
<p><img src="/images/post/2017-06-18/instance-structure2.png"></p>
<h3 id="ES6-Class-기반-상속"><a href="#ES6-Class-기반-상속" class="headerlink" title="ES6 Class 기반 상속"></a>ES6 Class 기반 상속</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; makes a noise.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.speak();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; roars.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lion = <span class="keyword">new</span> Lion(<span class="string">&#x27;Samba&#x27;</span>);</span><br><span class="line">lion.speak();</span><br><span class="line"></span><br><span class="line">[결과]</span><br><span class="line">Sambda makes a noise.</span><br><span class="line">Sambda roars.</span><br></pre></td></tr></table></figure>

<p>ES6에서는 <strong><code>extends</code></strong> 키워드로 상속을 구현합니다. Cat 클래스를 상속받은 Lion 클래스의 구조는 다음과 같습니다.</p>
<p><img src="/images/post/2017-06-18/instance-structure3.png"></p>
<p>위의 prototype을 통해 상속을 구현한 Lion 생성자 함수의 구조와 비교했을때 일치합니다. 추가적으로 new Lion(‘Samba’) 를 실행하면 다음의 과정을 거치게됩니다.</p>
<ol>
<li>Lion 클래스의 constructor를 호출</li>
<li>Lion 클래스에 constructor를 작성하지 않았기 때문에 슈퍼 클래스의(Cat) constructor가 호출됨 (내부적으로 프로토타입 체인으로 인해)</li>
<li>슈퍼 클래스의 constructor에서 this는 현재의 인스턴스를 참조하므로 인스턴스의 name 프로퍼티에 파라미터로 전달받은 값을 설정</li>
<li>생성한 인스턴스를 lion에 할당</li>
</ol>
<h1 id="super-키워드"><a href="#super-키워드" class="headerlink" title="super 키워드"></a>super 키워드</h1><p>서브 클래스와 슈퍼 클래스에 같은 이름의 메서드가 존재하면 슈퍼 클래스의 메서드는 호출되지 않습니다. 이때 <strong><code>super</code></strong> 키워드를 사용해서 슈퍼 클래스의 메서드를 호출할 수 있습니다. (서브 클래스의 constructor에 super()를 작성하면 슈퍼 클래스의 constructor가 호출됩니다.)</p>
<h1 id="static-키워드"><a href="#static-키워드" class="headerlink" title="static 키워드"></a>static 키워드</h1><p>static 키워드는 클래스를 위한 정적(static) 메소드를 정의합니다. 정적 메소드는 prototype에 연결되지 않고 클래스에 직접 연결되기 때문에 클래스의 인스턴스화(instantiating) 없이 호출되며, 클래스의 인스턴스에서는 호출할 수 없습니다. 동일한 클래스 내의 다른 정적 메서드 내에서 정적 메서드를 호출하는 경우 키워드 this를 사용할 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Noise~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Lion.speak();</span><br><span class="line"></span><br><span class="line">[결과]</span><br><span class="line">Noise~</span><br></pre></td></tr></table></figure>

<p>정적 메소드는 어플리케이션(application)을 위한 유틸리티(utility) 함수를 생성하는데 주로 사용됩니다.</p>
<hr>
<h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>ES6의 Class 문법에 대해 정리해 보았다. JavaScript 언어를 약 1년전 Node.js 를 시작하며 처음 접하게 되었는데 사실 그 당시 Prototype과 상속에 대해 크게 다룰일이 없었다. (어쩌면 너무 무지해서 사용 필요성을 느끼지 못했을 수도…) 그 후 Node.js 버전을 올리고 ES6를 공부하며 Class 문법을 접하게 되었는데 JavaScript의 Prototype에 대한 이해와 지식이 부족하다 보니 이전에 공부했던 C++과 Java의 Class 처럼 이해했던 것 같다. 그래도 그 후 Prototype과 더불이 Class까지 공부하며 지금은 어느정도 이해하게 된것 같다. 결론은… 역시나 JavaScript에서 Prototype을 이해하는건 중요한것 같다.</p>
<blockquote>
<p>참고<br><a target="_blank" rel="external nofollow noopener noreferrer" href="https://gomugom.github.io/is-class-only-a-syntactic-sugar/">ES6 Class는 단지 prototype 상속의 문법설탕일 뿐인가?</a><br><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes">MDN - Classes</a><br><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain">MDN - 상속과 프로토타입</a></p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-06-13T15:00:00.000Z" title="6/14/2017, 12:00:00 AM">2017-06-14</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-22T13:01:16.906Z" title="3/22/2021, 10:01:16 PM">2021-03-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/JavaScript/">JavaScript</a></span><span class="level-item">11분안에 읽기 (약 1702 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/06/14/JavaScript/memoization/">메모이제이션 (Memoization)</a></h1><div class="content"><p><img src="/images/post/2017-06-14/bg.jpg"></p>
<h1 id="메모이제이션-이란"><a href="#메모이제이션-이란" class="headerlink" title="메모이제이션 이란?"></a>메모이제이션 이란?</h1><p>자바 스크립트에서 함수는 객체이기 때문에 프로퍼티를 가질 수 있습니다. 그리고 언제든지 함수에 사용자 정의 프로퍼티를 추가할 수도 있습니다. 함수에 프로퍼티를 추가하여 <strong>결과(반환 값)을 캐시</strong>하면 다음 호출 시점에 복잡한 연산을 반복하지 않을 수 있습니다. 이런 활용 방법을 **<code>메모이제이션 패턴</code>**이라고 합니다.</p>
<p>다음 코드에서는 myFunc 함수에 cache 프로퍼티를 생성합니다. 이 프로퍼티는 일반적인 프로퍼티처럼 myFunc.cache와 같은 형태로 접근할 수 있습니다. cache 프로퍼티는 함수로 전달된 param 매개변수를 키로 사용해서 계산의 결과를 값으로 가지는 객체(해시)입니다. 결과 값은 필요에 따라 복잡한 데이터 구조로 저장할 수도 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!myFunc.cache[param]) &#123;</span><br><span class="line">        <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 비용이 많이 드는 수행 후 result에 결과 저장</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        myFunc.cache[param] = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myFunc.cache[param];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 캐시 저장공간</span></span><br><span class="line">myFunc.cache = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="메모이제이션-적용하기"><a href="#메모이제이션-적용하기" class="headerlink" title="메모이제이션 적용하기"></a>메모이제이션 적용하기</h1><p>메모이제이션을 공부한 후 현재 진행중인 <a href="https://jongmin92.github.io/2017/03/10/Emily/1-start-emily/">에밀리(개인 프로젝트)</a>에 적용해 보았습니다. 어느 부분에 적용했는지 적용 전과 적용 후 얼마나 효율이 올라갔는지를 알아보겠습니다.</p>
<h2 id="수정할-부분"><a href="#수정할-부분" class="headerlink" title="수정할 부분"></a>수정할 부분</h2><p>메모이제이션 패턴을 적용할 코드가 현재 하고 있는 기능은 다음과 같습니다. 사용자의 요청(학생식당, 카페테리아, 사범대식당, 기숙사식당, 교직원식당)에 따라 미리 크롤링 후 DB에 저장되어 있는 데이터(메뉴)를 가져와 응답합니다.<br><img src="/images/post/2017-06-14/description_1.png" alt="카카오톡 플러스친구 자동응답 봇"><br>메모이제이션 패턴을 사용함으로써 얻을 수 있는 이점은 <strong>비용이 많이 드는 결과를 캐싱하고 그 이후에 재사용함으로써 비용을 줄일 수 있다는 것입니다.</strong> 현재 코드에서 비용이 많이 드는 작업은 <strong>DB를 조회</strong>하는 부분입니다. DB에는 다음과 같이 미리 크롤링한 데이터가 날짜별로 저장되어 있습니다.</p>
<p><img src="/images/post/2017-06-14/db-table.png" alt="DB 메뉴 table"></p>
<p>사용자의 요청에 따라 해당 날짜의 데이터를 조회한 후 사용자가 요청한 식당에 맞는 데이터를 결과로 반환합니다. 그렇기 때문에 <strong>해당 날짜의 최초 요청이 이루어진 후 그 하루 동안에는 계속해서 DB에 같은 쿼리를 통해 같은 결과</strong>를 얻게 됩니다. 이 부분이 비용이 많이 드는 작업이기 때문에 메모이제이션 패턴을 통해 개선해보았습니다.</p>
<h2 id="메모이제이션-적용-전"><a href="#메모이제이션-적용-전" class="headerlink" title="메모이제이션 적용 전"></a>메모이제이션 적용 전</h2><p>먼저 메모이제이션 패턴을 적용하기 전 코드입니다. menuHandler 클래스의 <strong>getMenu</strong> 함수는 menuService를 통해 DB에서 해당 날짜의 식당 메뉴를 가져와 매개변수로 전달받은 식당의 이름을 사용하여 결과로 반환하는 역할을 합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dateUtil = <span class="built_in">require</span>(<span class="string">&#x27;util/dateUtil&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> menuService = <span class="built_in">require</span>(<span class="string">&#x27;services/menuService&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">menuHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getMenu</span>(<span class="params">place</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">_s, _f</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>().yyyymmdd();</span><br><span class="line">      <span class="keyword">let</span> menu = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      menuService.show(today)</span><br><span class="line">        .then(<span class="function"><span class="params">menuList</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!menuList) &#123;</span><br><span class="line">            menu = <span class="string">&#x27;데이터가 없습니다. 관리자에게 문의해주세요&#x27;</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">switch</span> (place) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;학생식당&#x27;</span>:</span><br><span class="line">              menu = menuList.student.join(<span class="string">&#x27;\n\n&#x27;</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;카페테리아&#x27;</span>:</span><br><span class="line">              menu = menuList.cafeteria.join(<span class="string">&#x27;\n\n&#x27;</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;사범대식당&#x27;</span>:</span><br><span class="line">              menu = menuList.education.join(<span class="string">&#x27;\n\n&#x27;</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;기숙사식당&#x27;</span>:</span><br><span class="line">              menu = menuList.dormitory.join(<span class="string">&#x27;\n\n&#x27;</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;교직원식당&#x27;</span>:</span><br><span class="line">              menu = menuList.staff.join(<span class="string">&#x27;\n\n&#x27;</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          _s(menu);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          _f(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = menuHandler;</span><br></pre></td></tr></table></figure>

<h2 id="3-메모이제이션-적용-후"><a href="#3-메모이제이션-적용-후" class="headerlink" title="3. 메모이제이션 적용 후"></a>3. 메모이제이션 적용 후</h2><p>메모이제이션 패턴을 적용 한 후 코드입니다. <strong>setCache, getCache, pickMenu</strong> 함수가 추가되었고, getMenu 함수의 코드도 조금 변경되었습니다. 기존 코드의 getMenu 함수에서는 바로 DB를 조회하여 결과를 반환하였지만, 변경된 코드에서는 <strong>getCache</strong> 함수를 통해 캐시에 저장된 데이터가 있는지 확인 후 분기하여 처리합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dateUtil = <span class="built_in">require</span>(<span class="string">&#x27;util/dateUtil&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> menuService = <span class="built_in">require</span>(<span class="string">&#x27;services/menuService&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">menuHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">setCache</span>(<span class="params">param, menuList</span>)</span> &#123;</span><br><span class="line">    menuHandler.cache[param] = menuList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getCache</span>(<span class="params">param</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (menuHandler.cache[param]) &#123;</span><br><span class="line">      <span class="keyword">return</span> menuHandler.cache[param];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">pickMenu</span>(<span class="params">menuList, place</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> menu = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (place) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;학생식당&#x27;</span>:</span><br><span class="line">        menu = menuList.student.join(<span class="string">&#x27;\n\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;카페테리아&#x27;</span>:</span><br><span class="line">        menu = menuList.cafeteria.join(<span class="string">&#x27;\n\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;사범대식당&#x27;</span>:</span><br><span class="line">        menu = menuList.education.join(<span class="string">&#x27;\n\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;기숙사식당&#x27;</span>:</span><br><span class="line">        menu = menuList.dormitory.join(<span class="string">&#x27;\n\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;교직원식당&#x27;</span>:</span><br><span class="line">        menu = menuList.staff.join(<span class="string">&#x27;\n\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> menu;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getMenu</span>(<span class="params">place</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">_s, _f</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>().yyyymmdd();</span><br><span class="line">      <span class="keyword">const</span> cachedMenuList = <span class="built_in">this</span>.getCache(today);</span><br><span class="line">      <span class="keyword">let</span> menu = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cachedMenuList) &#123;</span><br><span class="line">        menu = <span class="built_in">this</span>.pickMenu(cachedMenuList, place);</span><br><span class="line">        _s(menu);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        menuService.show(today)</span><br><span class="line">          .then(<span class="function"><span class="params">menuList</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!menuList) &#123;</span><br><span class="line">              menu = <span class="string">&#x27;데이터가 없습니다. 관리자에게 문의해주세요&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.setCache(today, menuList);</span><br><span class="line"></span><br><span class="line">            menu = <span class="built_in">this</span>.pickMenu(menuList, place);</span><br><span class="line">            _s(menu);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            _f(err);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuHandler.cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = menuHandler;</span><br></pre></td></tr></table></figure>

<p>Line:70 에서 선언한 menuHandler의 <strong>cache Object</strong>에는 다음과 같이 데이터가 <strong>캐싱</strong>될 것입니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#96;2017-06-13&#96;: &#123; ... menuList ...&#125;</span><br><span class="line">    &#96;2017-06-14&#96;: &#123; ... menuList ...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="결과-비교"><a href="#결과-비교" class="headerlink" title="결과 비교"></a>결과 비교</h1><p>메모이제이션 패턴을 적용하기 전과 적용한 후의 성능 차이는 아래 보이는것처럼 눈에 띄게 차이가 납니다. 메모이제이션 패턴을 적용한 코드는 첫번째 요청(캐싱 하기 전)때는 메모이제이션 패턴 적용 전과 응답속도가 비슷하지만 그 이후의 응답은 캐싱된 데이터를 이용하기 때문에 비교될 정도로 빨라졌습니다.</p>
<p><img src="/images/post/2017-06-14/result1.png" alt="메모이제이션 적용 전"></p>
<p><img src="/images/post/2017-06-14/result2.png" alt="메모이제이션 적용 후"></p>
<h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>메모이제이션을 적용하기 전과 후 모두 같은 기능을 결과를 만들어내는 코드이지만 코드를 작성하는 방법에 따라 더욱 더 빠른 효율적인 서비스를 만들 수 있다는 것을 느끼게 되었습니다.<br>현재 제 상황에서는 캐싱된 데이터도 하루가 지나게되면 쓰이지 않고 계속 메모리에 남아있게 되는데 그 부분에 대한 처리를 추가해야할것 같습니다. 이번에 적용한 코드 뿐만 아니라 아직 프로잭트 내에 메모이제이션 패턴을 적용할 수 있는 부분이 더 있습니다. 앞으로 디자인패턴 공부를 계속하여 새로운 패턴들을 적용시키며 리팩토링을 해야겠습니다. </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-06-09T15:00:00.000Z" title="6/10/2017, 12:00:00 AM">2017-06-10</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-22T13:01:54.305Z" title="3/22/2021, 10:01:54 PM">2021-03-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/JavaScript/">JavaScript</a></span><span class="level-item">10분안에 읽기 (약 1540 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/06/10/JavaScript/promise/">다시 공부하는 Promise</a></h1><div class="content"><h1 id="Promise란"><a href="#Promise란" class="headerlink" title="Promise란?"></a>Promise란?</h1><p>자바스크립트에서는 비동기 프로그래밍 해결을 위해 하나의 패턴으로 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://openwiki.kr/tech/callback">콜백</a>을 사용했다. 그러나 콜백 패턴은 비동기 처리 중 발생한 오류를 예외 처리하기 힘들고 여러 개의 비동기 로직을 한꺼번에 처리하는 데도 한계가 있다. 즉 콜백 패턴은 그다지 유용한 패턴이 아니다. 이때 비동기 프로그래밍을 위한 또 다른 패턴으로 Promise가 등장했다.</p>
<p>**<code>Promise</code>**는 <strong>비동기  처리 로직을 추상화한 객체와 그것을 조작하는 방식</strong>을 말한다. Promise를 지원하는 함수는 비동기 처리 로직을 추상화한 promise 객체를 반환 한다. 그리고 객체를 변수에 대입하고 성공 시 동작할 함수와 실패 시 동작할 함수 를 등록해 사용한다.</p>
<p>함수를 작성하는 방법은 promise 객체의 인터페이스에 의존 한다. 즉, promise 객체에서 제공하는 메서드만 사용해야 하므로 전통적인 콜백 패턴처럼 인자가 자유롭게 결정되는 게 아니라 같은 방식으로 통일된다. Promise 라고 부르는 하나의 인터페이스를 이용해 다양한 비동기 처리 문제를 해결할 수 있다. 복잡한 비동기 처리를 쉽게 패턴화할 수 있다는 뜻이다. 이것이 Promise의 역할이며 Promise를 사용하는 많은 이유 중 하나다.</p>
<h1 id="Promise-사용법"><a href="#Promise-사용법" class="headerlink" title="Promise 사용법"></a>Promise 사용법</h1><p>Promise는 new 연산자를 선언하여 Promise 인스턴스 객체를 생성한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 비동기 처리 로직 후 resolve 또는 reject를 호출</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>new  연산자로 생성된 Promise 인스턴스 객체에는 성공(resolve), 실패(reject)했을 때 호출될 콜백 함수를 등록할 수 있는 Promise.then()이라고 하는 인스턴스 메서드가 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>
<p>성공했을 때는 onFulfilled가 호출되고 실패했을 때는 onRejected가 호출된다. promise.then()으로 성공 혹은 실패 시의 동작을 동시에 등록할 수 있다. 만약 오류 처리만 한다면 promise.then(undefined, onRejected)와 같은 의미인 promise.catch(onRejected)를 사용하면 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.catch(onRejected)</span><br></pre></td></tr></table></figure>

<h1 id="Promise-상태"><a href="#Promise-상태" class="headerlink" title="Promise 상태"></a>Promise 상태</h1><p>생성자 함수를 new 연산하여 생성된 <strong>Promise 인스턴스 객체에는 3가지 상태가 존재</strong>한다. promise 객체는 Pending 상태로 시작해 Fulfilled나 Rejected 상태가 되면 다시는 변화하지 않는다. (Event 리스너와는 다르게 then()으로 등록된 콜백함수는 한 번만 호출된다.)</p>
<ul>
<li><strong>Pending</strong> : 성공도 실패도 아닌 상태, Promise 인스턴스 객체가 생성된 초기상태</li>
<li><strong>Fulfilled</strong> : 성공(resolve)했을 때의 상태, onFulfilled가 호출된다.</li>
<li><strong>Rejected</strong> : 실패(reject))했을 때의 상태, onRejected 호출된다.</li>
</ul>
<h1 id="Promise-resolve-Promise-reject"><a href="#Promise-resolve-Promise-reject" class="headerlink" title="Promise.resolve, Promise.reject"></a>Promise.resolve, Promise.reject</h1><p>Promise의 정적 메서드인 **<code>Promise.resolve()</code>**를 사용하면 new Promise() 구문을 단축해 표기할 수 있다. Promise.resolve()는 Fulfilled 상태인 promise 객체를 반환한다. 또한, Promise. resolve()는 <strong>thenable</strong> 객체를 promise 객체로 변환할 수 있다. 이것은 Promise.resolve()의 중요한 특징 중 하나다.</p>
<p>thenable은 ES6 Promises 사양에 정의된 개념이다. then()을 가진 객체 즉, 유사 promise 객체를 의미한다. length 프로퍼티를 갖고 있지만, 배열이 아닌 유사 배열 객체 Array-like Object와 같다. Promise.resolve()는 thenable 객체의 then() 이 Promise의 then()과 같은 동작을 할 것이라 기대하고 promise 객체로 변환한다.</p>
<p>**<code>Promise.reject()</code>**도 promise 객체를 반환한다. 따라서 에러 객체와 함께 catch()를 이용해 등록한 콜백 함수가 호출된다.</p>
<h1 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h1><p>Promise에서는 <strong>메서드를 체인하여 코드를 작성할 수 있다.</strong> then()은 콜백 함수를 동록하기만 하는것이 아니라 콜백에서 반환된 값을 기준으로 새로운 promise 객체를 생성하여 전달하는 기능도 갖고 있다.</p>
<h1 id="Promise-all-Promise-race"><a href="#Promise-all-Promise-race" class="headerlink" title="Promise.all, Promise.race"></a>Promise.all, Promise.race</h1><p>**<code>Promise.all()</code>**은 Promise 객체를 배열로 전달받고 객체의 상태가 모두 Fulfilled 됐을 때 then()으로 등록한 함수를 호출한다.<br>**<code>Promise.race()</code>**는 Promise.all()과 마찬가지로 promise 객체를 배열로 전달한다. Promise.all()과 달리 전달한 객체의 상태가 모두 Fulfilled가 될 때까지 기다리지 않고 전달한 객체 중 하나만 완료(Fulfilled, Rejected)되어도 다음 동작으로 넘어간다. Promise.race는 먼저 완료된 promise 객체가 있더라도 다른 promise 객체를 취소하지 않는다. (ES6 Promise 사양에는 취소라는 개념이 없다.)</p>
<h1 id="Promise-특징"><a href="#Promise-특징" class="headerlink" title="Promise 특징"></a>Promise 특징</h1><h2 id="Promise는-항상-비동기로-처리된다"><a href="#Promise는-항상-비동기로-처리된다" class="headerlink" title="Promise는 항상 비동기로 처리된다."></a>Promise는 항상 비동기로 처리된다.</h2><p>Promise.resolve()나 resolve()를 사용하면 promise 객체는 바로 Fulfilled 상태가 되기 때문에 then()으로 등록한 콜백 함수가 동기적으로 호출될 것이라 생각할 수 있다. 하지만 실제로는 then()으로 등록한 <strong>콜백 함수는 비동기적으로 호출</strong>된다.<br>동기적으로 처리 가능한 상황에서도 비동기적으로 처리하는 이유는 동기와 비동기가 혼재될때 발생하는 문제를 막기 위함이다.</p>
<h2 id="새로운-promise-객체를-반환하는-then"><a href="#새로운-promise-객체를-반환하는-then" class="headerlink" title="새로운 promise 객체를 반환하는 then"></a>새로운 promise 객체를 반환하는 then</h2><p>promise.then(), catch()는 최초의 promise 객체에 메서드를 체인하는 것처럼 보이지만 실제로는 then()과 catch()는 <strong>새로운 promise 객체를 생성해 반환</strong>한다.<br>Promise.all()과 Promise.race() 또한 새로운 promise 객체를 생성해 반환한다.</p>
<h2 id="콜백-헬과-무관한-Promise"><a href="#콜백-헬과-무관한-Promise" class="headerlink" title="콜백-헬과 무관한 Promise"></a>콜백-헬과 무관한 Promise</h2><p>Promise는 callback-hell 을 해결할수는 없고 완화할 수 있을 뿐이다. 완화할 수 있는 이유는 <strong>단일 인터페이스와 명확한 비동기 시점 표현, 강력한 에러 처리 메커니즘</strong> 때문이다. 이는 비동기 처리 자체를 손쉽게 다룰 수 있도록 하는 것이므로 callback-hell 을 해결하는 방법으로 여기는건 바람직하지 않다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-06-05T15:00:00.000Z" title="6/6/2017, 12:00:00 AM">2017-06-06</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-22T12:45:29.733Z" title="3/22/2021, 9:45:29 PM">2021-03-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/JavaScript/">JavaScript</a></span><span class="level-item">20분안에 읽기 (약 2954 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/06/06/JavaScript/client-side-rendering-vs-server-side-rendering/">[번역] Client-side rendering VS. Server-sde rendering</a></h1><div class="content"><blockquote>
<p>해당 포스팅은 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.com/@adamzerner/client-side-rendering-vs-server-side-rendering-a32d2cf3bfcc">Adam Zerner - Client-side rendering vs. server-side rendering</a>의 글을 번역하였습니다.</p>
</blockquote>
<p>초기에, 웹 프레임워크들은 서버(Server)에서 렌더링된 뷰를 갖고있었습니다. 현재는 클라이언트(Client)에서도 렌더링된 뷰를 가집니다. 지금부터 각각의 장점과 단점에 대해 알아보겠습니다.</p>
<h1 id="성능-Performance"><a href="#성능-Performance" class="headerlink" title="성능(Performance)"></a>성능(Performance)</h1><p>**<code>서버 측(Server-side)에서 렌더링</code>**을 할 경우, 새로운 웹 페이지를 보고 싶을 때마다 다음과 같이 새로운 페이지 요청이 필요합니다.</p>
<p><img src="/images/post/2017-06-06/server_side_rendering_1.png" alt="서버 측 렌더링 작동 방식 다이어그램"></p>
<p>이것은 먹고 싶은 것이 있을 때마다 슈퍼마켓에 가는것과 비슷합니다. </p>
<p>그러나 **<code>클라이언트 측(Client-side) 렌더링</code>**을 사용할 경우, 슈퍼마켓에 한 번 방문하고 좀 더 시간을 들여 꽤 오랜 기간동안 먹을 음식을 구매합니다. 그런 다음, 먹고 싶은 것이 있을 때마다 슈퍼마켓에 가지 않고 냉장고에서 찾게됩니다.</p>
<p><img src="/images/post/2017-06-06/client_side_rendering_1.png" alt="클라이언트 측 렌더링 작동 방식 다이어그램"></p>
<p>각 접근법에서는 성능면에서 장점과 단점이 있습니다.</p>
<ul>
<li><strong>클라이언트 측 렌더링</strong>을 사용하면 초기 페이지로드가 느려집니다. 네트워크를 통한 통신이 느리므로 사용자에게 콘텐츠를 표시하기 전에 서버를 두 번 왕복해야합니다. 그러나 그 후에는 이후의 모든 페이지로드가 엄청나게 빠릅니다.</li>
<li><strong>서버 쪽 렌더링</strong>을 사용하면 초기 페이지로드가 크게 느려지지 않습니다. 그렇다고 크게 빠르지는 않을 것입니다. 그리고 이후의 다른 요청도 마찬가지입니다.</li>
</ul>
<p>보다 구체적으로 말하자면, <strong>클라이언트 측 렌더링</strong>을 사용하면 <strong>초기 페이지</strong>는 다음과 같이 보입니다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;client-side-framework.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>app.js</strong>는 JavaScript의 모든 HTML 페이지를 다음과 같이 문자열로 유지합니다. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pages = &#123;</span><br><span class="line">  <span class="string">&#x27;/&#x27;</span>: <span class="string">&#x27;&lt;html&gt; ... &lt;/html&gt;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/foo&#x27;</span>: <span class="string">&#x27;&lt;html&gt; ... &lt;/html&gt;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/bar&#x27;</span>: <span class="string">&#x27;&lt;html&gt; ... &lt;/html&gt;&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>그런 다음 페이지가 로드되면 프레임워크는 URL 표시줄을 보고 [ ‘/‘] 페이지에서 문자열을 가져 와서 <code>div class = &quot;container&quot;&gt; &lt;/ div&gt;</code>에 삽입합니다. 또한 링크를 클릭하면 프레임워크가 이벤트를 가로 채고 컨테이너에 새 문자열 (예 : 페이지 [ ‘/ foo’])을 삽입하고 브라우저가 정상적으로하는 것처럼 HTTP 요청을 실행하지 못하게 합니다.</p>
<h1 id="검색-엔진-최적화-SEO"><a href="#검색-엔진-최적화-SEO" class="headerlink" title="검색 엔진 최적화(SEO)"></a>검색 엔진 최적화(SEO)</h1><div class="video-container"><iframe src="https://www.youtube.com/embed/BNHR6IQJGZs" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<p><strong>웹 크롤러</strong>가 <em>reddit.com</em> 을 요청하기 시작했다고 가정해봅시다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">&#x27;request&#x27;</span>);</span><br><span class="line">request.get(<span class="string">&#x27;reddit.com&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body looks something like this:</span></span><br><span class="line">  <span class="comment">// &lt;html&gt;</span></span><br><span class="line">  <span class="comment">//   &lt;head&gt; ... &lt;/head&gt;</span></span><br><span class="line">  <span class="comment">//   &lt;body&gt;</span></span><br><span class="line">  <span class="comment">//     &lt;a href=&quot;espn.com&quot;&gt;ESPN&lt;/a&gt;</span></span><br><span class="line">  <span class="comment">//     &lt;a href=&quot;news.ycombinator.com&quot;&gt;Hacker News&lt;/a&gt;</span></span><br><span class="line">  <span class="comment">//     ... other &lt;a&gt; tags ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>그러면 크롤러는 응답 본문에있는 <code>&lt;a href&gt;</code> 항목을 사용해서 새 요청을 생성합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">&#x27;request&#x27;</span>);</span><br><span class="line">request.get(<span class="string">&#x27;reddit.com&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body looks something like this:</span></span><br><span class="line">  <span class="comment">// &lt;html&gt;</span></span><br><span class="line">  <span class="comment">//   &lt;head&gt; ... &lt;/head&gt;</span></span><br><span class="line">  <span class="comment">//   &lt;body&gt;</span></span><br><span class="line">  <span class="comment">//     &lt;a href=&quot;espn.com&quot;&gt;ESPN&lt;/a&gt;</span></span><br><span class="line">  <span class="comment">//     &lt;a href=&quot;news.ycombinator.com&quot;&gt;Hacker News&lt;/a&gt;</span></span><br><span class="line">  <span class="comment">//     ... other &lt;a&gt; tags ...</span></span><br><span class="line">  </span><br><span class="line">  request.get(<span class="string">&#x27;espn.com&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;);</span><br><span class="line">  request.get(<span class="string">&#x27;news.ycombinator.com&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>그 후 크롤러는 <em>espn.com</em> 및 _news.ycombinator.com_의 링크를 사용하여 크롤링을 계속함으로써 프로세스를 계속 진행합니다.</p>
<p>결국 다음과 같은 재귀 코드처럼 동작합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">&#x27;request&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crawlUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  request.get(url, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> linkUrls = getLinkUrls(body);</span><br><span class="line">    linkUrls.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">linkUrl</span>) </span>&#123;</span><br><span class="line">      crawlUrl(linkUrl);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">crawlUrl(<span class="string">&#x27;reddit.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>그렇다면 만약 요청에 의한 응답이 다음과 같은경우는 어떻게 될까요?</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;client-side-framework.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>위의 코드는 <code>&lt;a href&gt;</code> 태그가 없습니다. 또한 웹 페이지의 내용이 없기 때문에 검색 결과를 표시 할 때 우선순위를 지정하지 않을 것입니다.</p>
<p>크롤러는 거의 알지 못하지만, 클라이언트 측 프레임워크는 멋진 콘텐츠로 <code>&lt;div class = &quot;container&quot;&gt; &lt;/div&gt;&quot;</code>를 채우려합니다.</p>
<p>이러한 이유가 클라이언트 측 렌더링이 SEO에 좋지 않은 이유입니다.</p>
<hr>
<h1 id="사전-렌더링-Prerendering"><a href="#사전-렌더링-Prerendering" class="headerlink" title="사전 렌더링(Prerendering)"></a>사전 렌더링(Prerendering)</h1><p>2009년에 Google은 이 문제를 해결할 수 있는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://webmasters.googleblog.com/2009/10/proposal-for-making-ajax-crawlable.html">방법</a>을 소개했습니다.</p>
<p><img src="/images/post/2017-06-06/prerendering.png"></p>
<p>크롤러가 <code>www.example.com/page?query#!mystate</code> 를 방문하면 <code>www.example.com/page?query&amp;_escaped_fragment_=mystate</code> 로 변환됩니다. 이렇게하면 서버가 <code>_escaped_fragment_</code>를 사용하여 요청을 받으면 사람이 아닌 크롤러에서 요청을 받는다는 것을 알 수 있습니다.</p>
<p>그렇기때문에 요청이 크롤러에서 온 경우 <code>&lt;div class = &quot;container&quot;&gt; ... &lt;/ div&gt;</code>를 제공할 수 있습니다.<br>일반적인 요청 인 경우 <code>&lt;div class = &quot;container&quot;&gt; &lt;/ div&gt;</code>를 제공하고 JavaScript가 내용을 내부에 삽입하도록 할 수 있습니다.</p>
<p>그러나 문제가 있습니다. 서버가 <code>&lt;div class = &quot;container&quot;&gt; &lt;/ div&gt;</code>안에 무엇이 들어가는지 알지 못하기 때문입니다. 내부에 무엇이 들어가는지 파악하려면 JavaScript를 실행하고 DOM을 만들고 DOM을 조작해야합니다. 전통적인 웹 서버는 이를 수행하는 방법을 모르기 때문에 <strong>Headless Browser</strong>로 알려진 서비스를 사용합니다.</p>
<p><img src="/images/post/2017-06-06/headless_browser.png"></p>
<h1 id="더-똑똑해진-크롤러"><a href="#더-똑똑해진-크롤러" class="headerlink" title="더 똑똑해진 크롤러"></a>더 똑똑해진 크롤러</h1><p>6년 후, Google은 크롤러가 한층 더 똑똑해 졌다고 발표했습니다. <strong>Crawler 2.0</strong>에서 <code>&lt;script&gt;</code> 태그를 볼 때 웹 브라우저처럼 실제로 요청을하고 코드를 실행하고 DOM을 조작한다는 것입니다.</p>
<p>그래서 다음과 같은 코드가</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>이제는 이렇게 보이는 것입니다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://support.google.com/webmasters/answer/6066468?hl=en">Fetch as Google</a>를 사용하여 Google 크롤러가 특정 URL을 방문했을 때 어떤 내용을 볼지 결정할 수 있습니다.</p>
<p>관련된 발표문의 내용 일부를 첨부합니다.</p>
<blockquote>
<p>당시 우리 시스템은 자바 스크립트를 사용하여 사용자에게 콘텐츠를 제공하는 페이지를 렌더링하고 이해할 수 없었습니다. <a target="_blank" rel="external nofollow noopener noreferrer" href="https://developers.google.com/webmasters/ajax-crawling/docs/learn-more">크롤러는 동적으로 생성 된 콘텐츠를 볼 수 없었기 때문에</a> 웹 마스터가 AJAX 기반 애플리케이션을 검색 엔진으로 인덱싱 할 수 있도록 일련의 방법을 제안했습니다.<br><br>시대가 바뀌 었습니다. 현재 Googlebot이 자바 스크립트 또는 CSS 파일을 크롤링하는 것을 차단하지 않는 한 일반적으로 최신 브라우저와 같이 웹 페이지를 렌더링하고 이해할 수 있습니다.</p>
</blockquote>
<h1 id="덜-똑똑한-크롤러"><a href="#덜-똑똑한-크롤러" class="headerlink" title="덜 똑똑한 크롤러"></a>덜 똑똑한 크롤러</h1><p>불행히도 Google 만이 유일한 검색 엔진이 아닙니다. Bing, Yahho, Duck Duck Go, Baidu 등도 있으며 실제로 사람들은 이러한 검색 엔진도 빈번하게 사용합니다.</p>
<p><img src="/images/post/2017-06-06/search_engine.png"></p>
<p>다른 검색 엔진은 JavaScript를 잘 처리하지 못합니다. 다음 글을 참고해보세요. <a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.freecodecamp.com/seo-vs-react-is-it-neccessary-to-render-react-pages-in-the-backend-74ce5015c0c9">SEO vs. React: Web Crawlers are Smarter Than You Think</a></p>
<h1 id="두-세계의-장점"><a href="#두-세계의-장점" class="headerlink" title="두 세계의 장점"></a>두 세계의 장점</h1><p>두 세계(서버 측 렌더링, 클라이언트 측 렌더링)의 장점을 최대한 활용하려면 다음의 방법이 있습니다.</p>
<ol>
<li>첫 번째 페이지 로드에는 서버 측 렌더링을 사용.</li>
<li>그 후 모든 후속 페이지 로드에는 클라이언트 측 렌더링을 사용.</li>
</ol>
<p><img src="/images/post/2017-06-06/both_worlds.png"></p>
<p>이것이 의미하는 바를 생각해보세요.</p>
<ul>
<li>첫 번째 페이지 로드의 경우 사용자가 콘텐츠를 보기 전에 두 번 왕복하지 않습니다.</li>
<li>후속 페이지 로드가 빨라집니다.</li>
<li>크롤러는 간단한 HTML을 얻습니다. 옛날처럼 JavaScript를 실행하거나 _escaped_fragment_를 처리할 필요가 없습니다.</li>
</ul>
<p>그러나 이를 위한 설정을 하기위해서는 서버에서 약간의 작업이 필요합니다. Angular, React 및 Ember 모두 이 접근 방식으로 변경했습니다.</p>
<h1 id="토론"><a href="#토론" class="headerlink" title="토론"></a>토론</h1><p>먼저 고려해야 할 몇 가지 사항은 다음과 같습니다.</p>
<ul>
<li>약 2%의 사용자가 JavaScript를 사용할 수 없게 설정되어 있는 경우 클라이언트 측 렌더링이 전혀 작동하지 않습니다.</li>
<li>웹 검색의 약 1/4은 Google 이외의 엔진으로 수행됩니다.</li>
<li>모두가 빠른 인터넷 연결을 사용하는 것은 아닙니다.</li>
<li>휴대 전화 사용자는 대개 빠른 인터넷 연결이 필요하지 않습니다.</li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.nngroup.com/articles/too-fast-ux/">너무 빠른 UI는 혼란 스러울 수 있습니다.</a> 사용자가 링크를 클릭한다고 가정 해보세요. 앱에서 새로운 뷰로 이동합니다. 그러나 새로운 뷰는 이전의 뷰와 미묘하게 다릅니다. 그리고 변경 사항은 즉시 발생했습니다 (클라이언트 측 렌더링의 장점). 새로운 뷰가 실제로 로드 된 것을 사용자가 알지 못할 수도 있습니다. 또는 사용자가 주의를 기울 였지만 상대적으로 미묘하기 때문에 사용자는 전환이 실제로 발생했는지 여부를 감지하기 위해 약간의 노력을 기울여야합니다. 때로는 약간의 로딩 스피너와 전체 페이지 재 렌더링을 하는 것이 좋습니다.</li>
<li>캐싱이 중요합니다. 따라서 서버 측 렌더링을 사용하면 실제로 사용자가 실제로 모든 것을 서버로 가져갈 필요가 없습니다. 때로는 바다 건너편의 “공식”서버가 아닌 근처의 서버에 가면됩니다.</li>
<li>실제로 성과와 관련하여 때로는 중요하지 않습니다. 때로는 속도가 좋고 속도가 약간 올라가더라도 삶이 더 좋아지지는 않습니다.</li>
</ul>
<p>대부분의 사용자는 인터넷 연결 상태가 좋으며 충분히 빠릅니다. 특히 Macbook Pro로 yuppies를 타겟팅하는 경우. 초기로드 시간이 너무 길어서 사용자를 잃을 염려가 없습니다. 사용자가 링크를 클릭 할 때 실제로 새 페이지가 로드된다는 사실을 사용자가 알지 못하는 사용성 문제에 대해 걱정할 필요가 없습니다.</p>
<p>그러나 초기 페이지 로드시 서버 측 렌더링을 사용하는 클라이언트 측 렌더링을위한 사용 사례는 확실합니다. 큰 회사의 경우 #perfMatters, 인터넷 연결 속도가 느린 사용자가 있고 최적화에 충분한 시간을 할애 할 수있는 충분한 엔지니어링 팀이있는 경우가 종종 있습니다.</p>
<p>앞으로 이 같은 형태의 웹 프레임 워크 (초기 페이지 로드시 서버 쪽 렌더링을 사용하고 후에는 클라이언트 측 렌더링을 수행)가 보다 안정되고 사용하기 쉬워지기를 기대합니다. 이 시점에서 추가 된 복잡성은 최소화 될 것입니다. 그러나 오늘날,이 모든 것은 매우 새롭고, 많은 추상화가있을 것으로 기대합니다. 앞으로 더 나아가 클라이언트 측 렌더링이 필요하지 않은 곳에 인터넷 연결이 충분해지기 때문에 추세가 다시 서버 측 렌더링으로 되돌아 갈 것으로 예상됩니다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-04-07T15:00:00.000Z" title="4/8/2017, 12:00:00 AM">2017-04-08</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-22T13:09:33.461Z" title="3/22/2021, 10:09:33 PM">2021-03-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/Node/">Node</a></span><span class="level-item">16분안에 읽기 (약 2383 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/04/08/Node/sequelize/">Sequelize 사용하기</a></h1><div class="content"><h1 id="ORM-이란"><a href="#ORM-이란" class="headerlink" title="ORM 이란?"></a>ORM 이란?</h1><p>**관계형 데이터베이스(RDB)**를 사용할때 데이터베이스의 데이터 조작(CRUD)를 위해서는 <strong>SQL 문</strong>을 작성해야합니다. SQL 문은 비즈니스 로직을 구성하고 있는 코드와 함께 작성하게 되는데 이는 코드의 가독성을 떨어뜨릴뿐만 아니라, 사용하는 관계형 데이터베이스에 따라 조금씩의 차이가 존재하기 때문에 문제가 발생할 수 있습니다. 이를 해결하기 위해 ORM을 사용합니다.</p>
<p>**<code>ORM(Object Relational Mapping)</code>**은 객체(Object)와 관계(Relation)를 맵핑(Mapping)하여 <strong>비즈니스 로직에 집중</strong>할 수 있도록 데이터 처리 로직을 추상화시킵니다.</p>
<p>객체와 관계를 매핑한다는 것은 <strong>데이터베이스에 저장된 레코드를 객체로 바꿔표현한다는 의미</strong>하며, 비즈니스 로직에 집중할 수 있도록 데이터 처리 로직을 추상화한다는 것은 쿼리를 사용하지 않고도 데이터베이스를 사용할 수 있음을 뜻합니다.</p>
<p>ORM을 사용할 경우 특정 DBMS에 종속되지 않으며 생산성, 독립성, 가독성(SQL문이 코드에 들어가지 않기때문) 및 유지보수 측면에서의 장점이 있지만 반대로 RAW query에 비해 퍼포먼스가 떨어지고, query가 복잡해 질수록 오히려 생산성이 저하될 수 있다는 단점도 존재합니다.</p>
<p><img src="/images/post/2017-04-08/orm.png" alt="ORM"></p>
<h1 id="Sequelize-설치하기"><a href="#Sequelize-설치하기" class="headerlink" title="Sequelize 설치하기"></a>Sequelize 설치하기</h1><p>**<a target="_blank" rel="external nofollow noopener noreferrer" href="http://docs.sequelizejs.com/en/v3/">Sequelize</a>**는 Node에서 가장 많이 사용되는 ORM 입니다.</p>
<p><strong>RDS로  PostgresSQL, MySQL, MariaDB, SQLite, MSSQL</strong>을 지원하고 transaction, read replication등 다양한 기능을 제공하고 있으며. 또한 <strong>Promise</strong>를 기본으로 동작하기 때문에 비동기 코드를 보기좋게 작성할 수 있습니다.</p>
<p>실습을 위해 express-generator를 통해 Express 프로젝트를 생성후 <code>sequelize</code>와 <code>mysql</code> module을 설치합니다. (Express 프로젝트를 생성하는 부분은 생략합니다.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save sequelize mysql</span><br></pre></td></tr></table></figure>

<p>**<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/sequelize/cli">Sequelize Command Line Interface(CLI)</a>**를 사용하기 위해서 <code>sequelize-cli</code> module을 설치합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g sequelize-cli</span><br></pre></td></tr></table></figure>

<h1 id="Sequelize-CLI-사용하기"><a href="#Sequelize-CLI-사용하기" class="headerlink" title="Sequelize CLI 사용하기"></a>Sequelize CLI 사용하기</h1><p><strong>sequelize cli</strong>를 통해서 **<code>migration(마이그레이션), seeder(시더), model(모델)</code>**의 초기 설정을 손쉽게 할 수 있습니다. 이번 포스팅에서는 <strong>model</strong>에 관해서 알아보겠습니다.</p>
<p>RDB의 테이블을 model로 정의를 하면 해당 model을 통해 데이터 처리가 가능하게 됩니다.<br>먼저 생성한 express 프로젝트에 sequelize cli 명령어를 통해 sequelize 설정 파일을 생성 후 model을 정의해 보겠습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sequelize init:config --config config&#x2F;sequelize.json</span><br><span class="line">sequelize init:models</span><br></pre></td></tr></table></figure>

<p>sequelize cli의 <strong>sequelize init:config</strong>라는 명령어로 sequelize관련 config 파일을 자동으로 생성할 수 있습니다. 아무런 옵션을 주지 않는다면 <strong>config/config.json</strong> 파일이 생성됩니다.</p>
<p><strong>sequelize init:models</strong> 명령어를 통해서는 models 정의에 관련된 기본 구조를 생성할 수 있습니다.</p>
<p>위 2개의 명령어를 실행하면 다음과 같은 폴더와 파일이 생성됩니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── config&#x2F;</span><br><span class="line">  └── sequelize.json</span><br><span class="line">├── models&#x2F;</span><br><span class="line">  └── index.js</span><br></pre></td></tr></table></figure>

<h1 id="Sequelize-config-설정하기"><a href="#Sequelize-config-설정하기" class="headerlink" title="Sequelize config 설정하기"></a>Sequelize config 설정하기</h1><p>sequelize cli를 통해 생성한 <code>config/sequelize.json</code>파일에 데이터베이스에 관련된 설정 값을 입력합니다.</p>
<p> <strong><code>NODE_ENV</code></strong> 에 따라 각기 다른 값을 사용하기 때문에 상황에 맞게 설정할 수 있습니다. NODE_ENV에 대해 잘 알지 못한다면 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://inspiredjw.com/entry/Nodejs-%EC%97%90%EC%84%9C-NODEENV-%EA%B0%92%EC%9C%BC%EB%A1%9C-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0">이곳</a>을 참고하세요.</p>
<p>데이터베이스를 사용한 프로젝트 경험이 있다면 대부분의 config 값은 입력할 수 있습니다. config 값중 <code>dialect</code>에는 사용하는 RDB 이름을 입력해야 합니다. diaect에 사용 가능한 값은 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://docs.sequelizejs.com/en/1.7.0/docs/usage/">sequelize docs</a>를 참고하세요. 현재 사용 가능한 RDB 로는 ‘mysql’, ‘sqlite’, ‘postgress’, ‘mariadb’가 있습니다.</p>
<p>추가적으로 커넥션 풀과 로깅 기능을 사용한다면 해당 값을 추가합니다. 추가적으로 필요한 옵션은 docs를 참고하세요.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;pool&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;max&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;min&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;idle&quot;</span>: <span class="number">5000</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;logging&quot;</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="Model-정의하기"><a href="#Model-정의하기" class="headerlink" title="# Model 정의하기"></a># Model 정의하기</h1><p>Model을 생성하기 전 sequelize cli를 통해 생성한 <code>models/index.js</code>파일을 살펴보겠습니다. index.js 의 역할은 <strong>config/sequelize.json</strong>의 설정값을 읽어 sequelize를 생성한 후 <strong>models 폴더</strong> 아래에 정의한 model 관련 js 파일을 모두 로딩하여 db 객체에 Model을 정의한 후 반환합니다.</p>
<p>sequelize config 관련 파일을 sequelize.json으로 생성하였다면 config 파일을 불러오는 <strong>require 부분의 경로를 수정</strong>해주어야 합니다.</p>
<p>이제 models 폴더 아래에 간단한 모델을 정의해 보겠습니다. **<code>user.js</code>**를 생성 후 다음의 코드를 입력합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">sequelize, DataTypes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = sequelize.define(<span class="string">&#x27;User&#x27;</span>, &#123;</span><br><span class="line">    userID: &#123; <span class="attr">field</span>: <span class="string">&#x27;user_id&#x27;</span>, <span class="attr">type</span>: DataTypes.STRING(<span class="number">50</span>), <span class="attr">unique</span>: <span class="literal">true</span>, <span class="attr">allowNull</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    password: &#123; <span class="attr">field</span>: <span class="string">&#x27;password&#x27;</span>, <span class="attr">type</span>: DataTypes.STRING(<span class="number">30</span>), <span class="attr">allowNull</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="comment">// don&#x27;t use camelcase for automatically added attributes but underscore style</span></span><br><span class="line">    <span class="comment">// so updatedAt will be updated_at</span></span><br><span class="line">    underscored: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable the modification of tablenames; By default, sequelize will automatically</span></span><br><span class="line">    <span class="comment">// transform all passed model names (first parameter of define) into plural.</span></span><br><span class="line">    <span class="comment">// if you don&#x27;t want that, set the following</span></span><br><span class="line">    freezeTableName: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// define the table&#x27;s name</span></span><br><span class="line">    tableName: <span class="string">&#x27;user&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Sequelize 참고</span></span><br><span class="line"><span class="comment"> DataTypes =&gt; http://docs.sequelizejs.com/en/v3/api/datatypes/</span></span><br><span class="line"><span class="comment"> Associations =&gt; http://docs.sequelizejs.com/en/v3/api/associations/</span></span><br><span class="line"><span class="comment"> Model Function =&gt; http://docs.sequelizejs.com/en/v3/api/model/</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>Model을 생성하며 사용된 옵션은 주석과 docs를 참고합니다. 이제 모델에 대한 정의가 끝났습니다. 데이터베이스에 <strong>user</strong>라는 테이블은 <strong>User</strong>라는 Object로 매핑되었고 <strong>user_id, password</strong>라는 칼럼은 User Object의 속성으로 매핑되었습니다.</p>
<h1 id="Sequelize-Sync-사용하기"><a href="#Sequelize-Sync-사용하기" class="headerlink" title="Sequelize Sync 사용하기"></a>Sequelize Sync 사용하기</h1><p>Sequeliz에서는 **입력(INSERT), 수정(UPDATE), 조회(SELECT), 삭제(DELETE)**의 **<code>데이터 조작(DML: Data Manipulation Language)</code>**뿐만 아니라 데이터베이스의 <strong>스키마 객체를 생성(CREATE), 변경(ALERT), 제거(DROP)</strong> 할 수 있는 **<code>데이터 정의(DDL: Data Definition Language)</code>**도 지원합니다.<br>따라서 이미 만들어진 데이터베이스 테이블에 모델을 매핑할 수 있을 뿐만 아니라, <strong>정의한 모델을 바탕으로 테이블을 생성할 수도 있습니다.(동기화)</strong></p>
<p>해당 기능을 사용하기 위해서는 Sequelize의 <strong><code>sync</code></strong> 메서드를 사용합니다. **<code>app.js</code>**에 다음의 코드를 추가합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// connect To DB</span></span><br><span class="line"><span class="keyword">const</span> models = <span class="built_in">require</span>(<span class="string">&#x27;./models&#x27;</span>);</span><br><span class="line">models.sequelize.sync()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;✓ DB connection success.&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;  Press CTRL-C to stop\n&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;✗ DB connection error. Please make sure DB is running.&#x27;</span>;</span><br><span class="line">    process.exit();</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>sync 메서드를 호출하여 실패했을 경우에는 에러 메시지를 출력 후 프로세스를 종료합니다.</p>
<p>sync 메서드는 모델에서 정의한 이름의 테이블이 존재하지 않을 경우에만 동작합니다. 이미 테이블이 존재할 경우에는 <strong><code>models.sequelize.sync(&#123;force: true&#125;)</code></strong> 과 같이 force 옵션을 주어 강제적으로 테이블을 제거 후 다시 생성이 가능하지만 매우 위험한 옵션이므로 주의를 기울여 사용해야 합니다.</p>
<h1 id="Sequelize-예제-SELECT"><a href="#Sequelize-예제-SELECT" class="headerlink" title="Sequelize 예제 (SELECT)"></a>Sequelize 예제 (SELECT)</h1><p>이제 Sequelize를 사용하여 SELECT를 사용해보겠습니다. 유저 리스트를 가져오는 query는 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">models.User.findAll()</span><br><span class="line">  .then(results) &#123;</span><br><span class="line">     res.json(results);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>User 테이블에 있는 모든 row를 가져오는 query입니다. Sequelize는 결과를 Promise로 리턴하기 때문에 <strong><code>findAll</code></strong> 메서드 역시 Promise를 리턴합니다. 따라서 query의 결과는 then에서 받고, catch문에서 상황에 맞게 error 처리(handling)를 하면됩니다.</p>
<p>findAll의 더 자세한 사용법은 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://sequelize.readthedocs.io/en/latest/api/model/#findalloptions-promisearrayinstance">Sequelize-model-findAll 설명</a>을 참고합니다.</p>
<h1 id="Sequelize-예제-INSERT"><a href="#Sequelize-예제-INSERT" class="headerlink" title="Sequelize 예제 (INSERT)"></a>Sequelize 예제 (INSERT)</h1><p>Sequelize를 사용하여 INSERT를 하는 방법은 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">models.User.create(&#123;<span class="attr">userID</span>: <span class="string">&#x27;유저ID&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;유저PW&#x27;</span>&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">     res.json(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p><strong><code>create</code></strong> 메서드의 매개변수에 model에서 매핑한 내용을 토대로 데이터를 넣으면 query를 실행 후 insert된 row정보가 반환됩니다.</p>
<p>create의 더 자세한 사용법은 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://sequelize.readthedocs.io/en/latest/api/model/#createvalues-options-promiseinstance">Sequelize-model-create 설명</a>을 참고합니다.</p>
<h1 id="Sequelize-예제-UPDATE"><a href="#Sequelize-예제-UPDATE" class="headerlink" title="Sequelize 예제 (UPDATE)"></a>Sequelize 예제 (UPDATE)</h1><p>User 테이블의 데이터를 수정할때는 다음과 같이 사용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">models.User.update(&#123;<span class="attr">password</span>: <span class="string">&#x27;새로운 유저PW&#x27;</span>&#125;, &#123;<span class="attr">where</span>: &#123;<span class="attr">userID</span>: <span class="string">&#x27;유저ID&#x27;</span>&#125;&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">     res.json(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p><strong><code>update</code></strong> 메서드의 매개변수에는 update할 데이터를 입력합니다.</p>
<p>update 더 자세한 사용법은 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://sequelize.readthedocs.io/en/latest/api/model/#updatevalues-options-promisearrayaffectedcount-affectedrows">Sequelize-model-update 설명</a>을 참고합니다.</p>
<h1 id="Sequelize-예제-DELETE"><a href="#Sequelize-예제-DELETE" class="headerlink" title="Sequelize 예제 (DELETE)"></a>Sequelize 예제 (DELETE)</h1><p>User 테이블의 데이터를 삭제할때는 다음과 같이 사용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">models.User.destroy(&#123;<span class="attr">where</span>: &#123;<span class="attr">userID</span>: <span class="string">&#x27;유저ID&#x27;</span>&#125;&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">     res.json(&#123;&#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p><strong><code>destroy</code></strong> 메서드의 매개변수에는 where 조건을 입력합니다.<strong>(where 조건을 입력하지 않을 경우 테이블의 모든 row가 삭제되기 때문에 주의해야 합니다.)</strong></p>
<p>destroy 더 자세한 사용법은 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://sequelize.readthedocs.io/en/latest/api/model/#destroyoptions-promiseinteger">Sequelize-model-update 설명</a>을 참고합니다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-03-13T15:15:30.000Z" title="3/14/2017, 12:15:30 AM">2017-03-14</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-22T13:02:34.088Z" title="3/22/2021, 10:02:34 PM">2021-03-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/JavaScript/">JavaScript</a></span><span class="level-item">16분안에 읽기 (약 2363 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/03/14/JavaScript/understand-prototype/">Prototype 이제는 이해하자</a></h1><div class="content"><h1 id="prototype은-왜-어려울까"><a href="#prototype은-왜-어려울까" class="headerlink" title="prototype은 왜 어려울까?"></a>prototype은 왜 어려울까?</h1><p>C++, Java와 같은 <code>클래스</code> 기반 객체지향 언어와 달리 자바스크립트는 <code>프로토타입</code> 기반 객체지향 언어입니다. 프로토타입을 사용하여 객체지향을 추구하기 때문에 자바스크립트를 사용함에 있어 프로토타입을 이해하는 것은 중요합니다. 최근 ECMA6 표준에서 <code>Class</code> 문법이 추가되었지만 C++, Java에서 말하는 클래스가 아닌 <code>프로토타입</code>을 기반으로 하여 만들어진 문법입니다.</p>
<p>자바스크립트의 프로토타입을 처음 공부하면서 <strong>prototype, [[prototype]], _<em>proto_</em>, 객체, 함수, prototype chain</strong> 과 같은 용어들을 접하게 되는데 공부할수록 서로 뒤엉켜지고, 모르는 것도 아닌 그렇다고 제대로 알고 있는것도 아닌 어중간한 상태가 됩니다.</p>
<p>자바스크립트를 사용한 경험이 있으시다면 아래의 코드와 같은 형태를 경험한적이 있으실겁니다. 지금부터 아래의 코드가 어떤 원리로 동작하게 되는지 알아보겠습니다.</p>
<p><img src="/images/post/2017-03-14/prototype_example_1.png" alt="prototype에 property 추가"></p>
<p>먼저 프로토타입에 대해 이해하기 위해서는 <code>객체(object)는 함수(function)로부터 시작된다</code>라는 것을 알아야 합니다. 이는 prototype을 이해하는데 많은 도움을 줍니다.</p>
<h1 id="객체-object-는-함수-function-로부터-시작된다"><a href="#객체-object-는-함수-function-로부터-시작된다" class="headerlink" title="객체(object)는 함수(function)로부터 시작된다"></a>객체(object)는 함수(function)로부터 시작된다</h1><p><strong>자바스크립트에서 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/ko/docs/Glossary/Primitive">primitive</a>를 제외하고는 모두 객체(object)입니다.</strong><br> <strong>앞으로 등장하는 Object와 Function은 function(즉, 생성자)입니다. object는 객체를 의미합니다.</strong></p>
<p>다음의 코드를 분석하기 전 <code>객체(object)는 함수(function)로부터 시작된다</code>라는걸 다시한번 기억하겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Book</span>(<span class="params"></span>) </span>&#123; &#125;                <span class="comment">// 함수</span></span><br><span class="line"><span class="keyword">var</span> jsBook = <span class="keyword">new</span> Book();           <span class="comment">// 객체 생성</span></span><br></pre></td></tr></table></figure>

<p>위의 코드에서 <strong>Book이라는 함수를 통해서 jsBook이라는 객체</strong>를 생성했습니다. 이때 Book 함수를 <code>생성자</code>라고 합니다. 생성자는 새로 생성된 객체를 초기화하는 역할을 합니다. 코어 자바스크립트는 기본 타입에 대한 생성자를 내장하고 있는데 이는 다음 코드를 통해 확인이 가능합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cssBook = &#123;&#125;;                  <span class="comment">// 생성자 선언 없이 객체 생성</span></span><br></pre></td></tr></table></figure>
<p>위에서는 리터럴 방식을 사용하여 객체를 생성하였습니다. 리터럴 방식 또한 결과적으로는 함수를 통하여 객체를 생성하게 됩니다. <strong>자바스크립트 엔진</strong>이 해당 리터럴을 다음과 같이 해석합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cssBook = <span class="keyword">new</span> <span class="built_in">Object</span>();        <span class="comment">// 객체 생성</span></span><br></pre></td></tr></table></figure>
<p>따라서 결과적으로는 리터럴 방식으로 객체를 생성할때도 Object라는 함수(생성자)를 통해서 객체를 생성하게 됩니다. <strong>Object 뿐만 아니라 Array, Function, Date, RegExp 모두 함수입니다.</strong></p>
<p><img src="/images/post/2017-03-14/various_function.png" alt="Object, Array, Function, Date, RegExp - 모두 함수(function)이다"></p>
<p>배열도 객체이기 때문에(자바스크립트 배열은 객체의 특별한 형태입니다. 프로퍼티 이름이 정수로 사용되며, length 프로퍼티를 가집니다.) 객체를 생성할때와 마찬가지로 배열(객체)의 생성에도 함수가 관여하게 됩니다. 따라서 무심코 사용했던 배열의 리터럴 표현도 결국에는 자바스크립트 엔진이 다음과 같이 해석합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> books = [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;js&#x27;</span>];                  <span class="comment">// 배열(객체) 생성</span></span><br><span class="line"><span class="comment">// 엔진이 다음과 같이 해석합니다.</span></span><br><span class="line"><span class="keyword">var</span> books = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;js&#x27;</span>);         <span class="comment">// 배열(객체) 생성</span></span><br></pre></td></tr></table></figure>

<p>이제 <code>객체(object)는 함수(function)로부터 시작된다</code>라는 것을 알 수 있습니다.</p>
<h1 id="함수-function-생성시-발생하는-일"><a href="#함수-function-생성시-발생하는-일" class="headerlink" title=" 함수(function) 생성시 발생하는 일"></a><span style="color:red"> 함수(function) 생성시 발생하는 일</span></h1><p>객체(object)는 함수(function)로부터 시작되기 때문에 사용자가 객체를 생성하기 위해 먼저 함수를 정의하게 됩니다. 이때 <strong>발생하는 일</strong>에 대해 알아보겠습니다. 여기서는 2가지를 기억해야 합니다.</p>
<p>1.<strong>함수를 정의하면 함수가 생성되며 <code>Prototype object</code>가 같이 생성 됩니다. 생성된 Prototype object는 함수의 <code>prototype</code> 속성을 통해 접근할 수 있습니다.</strong> (Prototype object같은 경우 함수 생성시에만 됩니다. 일반 객체 생성시에는 생성되지 않습니다.)</p>
<p><img src="/images/post/2017-03-14/function_property.png" alt="함수 prototype property"></p>
<p>2.함수의 생성과 함께 생성된 <code>Prototype object</code>는 <code>constructor</code>와 <code>__proto__</code>를 갖고 있습니다. (cover property를 추가한것 처럼 사용자 임의로 추가 가능합니다.) <strong>constructor</strong>는 생성된 함수를 가리키며(여기서는 function Book을 가리킵니다.) **_<em>proto_</em>**는 <code>Prototype Link</code>로서 <strong>객체가 생성될 때 사용된 생성자(함수)의 Prototype object를 가리킵니다.</strong> Prototype Link는 뒤에서 자세하게 알아보겠습니다.</p>
<p><img src="/images/post/2017-03-14/prototype_object.png" alt="함수와 함께 생성된 Prototype object"></p>
<p>다이어그램을 통해 확인하면 다음과 같습니다.</p>
<p><img src="/images/post/2017-03-14/make_function_diagram.png" alt="함수와 Prototype object의 관계"></p>
<h1 id="객체-object-생성시-발생하는-일"><a href="#객체-object-생성시-발생하는-일" class="headerlink" title="객체(object) 생성시 발생하는 일"></a>객체(object) 생성시 발생하는 일</h1><p>이번에는 객체 생성시 발생하는 일에 대해 알아보겠습니다. 조금 전에 정의한 Book 함수(생성자)를 사용하여 jsBook이라는 객체를 생성해 보겠습니다.</p>
<p><img src="/images/post/2017-03-14/make_object.png" alt="Book 함수로 생성한 객체"></p>
<p>생성자(함수)의 몸체 부분에 어떠한 코드도 작성하지 않았는데 이를 통해 생성한 jsBook 객체가 <code>__proto__</code>라는 프로퍼티를 갖고있습니다.</p>
<p>여기서 <strong>_<em>proto_</em></strong> 는 <code>Prototype Link</code>로서 **객체의 생성에 쓰인 생성자 함수의 <code>Prototype object</code>**를 가리키고 있습니다. 그렇기 때문에 Book 생성자 함수와 함께 생성된 Prototype object에 추가한 cover라는 프로퍼티가 보이는것을 확인할 수 있습니다.</p>
<p>조금 더 이해하기 쉽게 다이어그램으로 확인하면 다음과 같습니다.</p>
<p><img src="/images/post/2017-03-14/make_object_diagram.png" alt="함수, Prototype object, 객체의 관계"></p>
<p>다이어그램에서도 확인할 수 있다시피 <code>prototype</code> property(함수 생성시 함께 생성된 Prototype object를 가리킴)는 함수객체만 가지며 <code>__proto__</code>는 객체라면 모두 갖고 있습니다.</p>
<p>이제 프로토타입 체인(Prototype Chain)에 대해 이해할 수 있는 준비가 되었습니다.</p>
<h1 id="프로토타입-체인-Prototype-Chain"><a href="#프로토타입-체인-Prototype-Chain" class="headerlink" title="프로토타입 체인(Prototype Chain)"></a>프로토타입 체인(Prototype Chain)</h1><p>결론부터 말씀드리면 <code>프로토타입 체인</code>은 객체의 property를 사용할때 해당 property가 없다면, <code>__proto__</code> property를 이용해 자신의 생성에 관여한 함수(생성자 함수)의 <code>Prototype object</code>에서 property를 찾습니다. 만약 Prototype object에도 해당 property가 없다면 다시 Prototype object의 <strong>_<em>proto_</em></strong> property를 이용해 Prototype object에서 property를 찾습니다. 이렇게 계속 반복이 이루어지며 해당 property를 찾게 된다면 <strong>값을 반환</strong>하고 찾지 못한다면 <strong>undefined</strong>를 반환합니다. 이렇게 <strong><code>__proto__</code> property를 통해 상위 프로토타입과 연결되어 있는 형태를 프로토타입 체인(Chain)이라고 합니다.</strong></p>
<p>프로토타입 체인에 대해 알게되었으니 다시한번 처음 코드를 살펴보겠습니다.</p>
<p><img src="/images/post/2017-03-14/prototype_example_1.png" alt="프로토타입 체인 예제"></p>
<p>이제 어떻게 jsBook에 cover라는 property를 추가하지 않았는데도 결과가 출력되는지 이해할 수 있습니다. 다음과 같이 동작할 것입니다.</p>
<p><img src="/images/post/2017-03-14/prototype_diagram_1.png" alt="프로토타입 체인 예제(cover property 찾는 과정)"></p>
<p>또한 다음과 같이 <strong>프로토타입 체인의 최상위는 Object이기 때문에 Object.prototype의 property들을 모두 사용할 수 있습니다.</strong> 자주 사용하는 toString()과 valueOf() 모두 Object.prototype에 선언되어 있습니다.<br>(Book Prototype object는 <strong>객체</strong>이기 때문에 Object 생성자가 사용될 것입니다. 따라서 Book Prototype object의 **_<em>proto_</em>**는 Object Prototype object를 가리키게 됩니다.)</p>
<p><img src="/images/post/2017-03-14/prototype_diagram_2.png" alt="프로토타입 체인의 최상위 object"><br><img src="/images/post/2017-03-14/Object_prototype.png" alt="Object.prototype"></p>
<p><code>Prototype object</code>와 <code>__proto__</code> 그리고 <code>프로토타입 체인</code>에 대해 이해하였으니 다음과 같은 코드도 이해할 수 있습니다. 잘 이해가 되지 않는다면 위의 다이어그램을 참고해보시기 바랍니다.</p>
<p><img src="/images/post/2017-03-14/prototype_chain_test.png" alt="__proto__와 Prototype object의 관계"></p>
<h1 id="번외"><a href="#번외" class="headerlink" title="번외"></a>번외</h1><p><img src="/images/post/2017-03-14/prototype_diagram_2_check.png" alt="프로토타입 체인의 최상위 object"><br>혹시 다이어그램을 보면서 function Book의 <strong>_<em>proto_</em></strong> 는 무엇을 가리키고 있는지 궁금해 하셨을 분들을 위해 추적해보았습니다.</p>
<p><img src="/images/post/2017-03-14/function_proto.png" alt="function(생성자)의 __proto__ 추적"></p>
<p>다음 코드를 도식화 하면 다음과 같은 다이어그램이 나오게 됩니다.</p>
<p><img src="/images/post/2017-03-14/function_proto_diagram.png" alt="function(생성자)의 __proto__ 추적"></p>
<p>간단하게 포스팅을 하려했는데 주제가 주제인지라 길어졌습니다. 저도 프로토타입을 처음 공부하면서 어려움을 많이 겪었는데 조금이나마 도움이 되었으면 좋겠습니다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-02-25T15:00:00.000Z" title="2/26/2017, 12:00:00 AM">2017-02-26</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-22T13:04:43.676Z" title="3/22/2021, 10:04:43 PM">2021-03-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/Linux-Ubuntu/">Linux &amp; Ubuntu</a></span><span class="level-item">6분안에 읽기 (약 970 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/02/26/Linux%20&amp;%20Ubuntu/screen/">Screen 사용하기</a></h1><div class="content"><h1 id="Screen-이란"><a href="#Screen-이란" class="headerlink" title="Screen 이란?"></a>Screen 이란?</h1><p><strong>terminal</strong> 또는 <strong>putty</strong>를 이용해 원격에서 작업하다 보면 여러개의 창을 띄우고 싶을 때가 많습니다. 이럴때 보통 여러개의 terminal을 띄워서 작업합니다. (저는 screen을 알기 전까지 그랬습니다…) 그런데 창을 하나, 둘 여러개 띄우고 작업을 하다보면 어느 창에서 어떤 작업을 하고 있었는지도 헷갈리기 시작하면서 관리의 어려움이 생기게 됩니다.</p>
<p><img src="/images/post/2017-02-26/description1.png" alt="description"><br>**<code>screen</code>**은 한 terminal로 한번만 로그인 한 후에 여러 쉘과 프로그램을 사용할 수 있습니다. 또한 **<code>세션관리 기능</code>**도 지원합니다. 세션관리 기능은 상당히 유용합니다. 예를 들면, 터미널을 통해 원격 서버에 접속하여 작업을 하다가 네트워크 장애로 연결이 끊어진다면 매우 난감할 수 있습니다. 이때 screen을 사용해서 작업중이 였다면 **<code>세션을 유지</code>**할 수 있기 때문에 해당 작업은 로컬에서 계속 진행되고 있으며 언제든지 다시 해당 세션을 통해 작업을 계속 할 수 있습니다. 더불어 하나의 서버에 여러명의 사용자가 접속하여 **<code>해당 스크린을 공유</code>**하여 같은 화면을 공유할 수도 있습니다.</p>
<p><img src="/images/post/2017-02-26/description2.png" alt="description"><br><br><br><img src="/images/post/2017-02-26/description3.png" alt="description"><br>screen은 <strong>하나의 프로세스</strong> 입니다. 따라서 무분별하게 생성하기 보다는 필요한 용도에 맞게 <strong>적당한 개수를 유지</strong>하며 사용하는것이 중요합니다.</p>
<h1 id="Screen-실행-명령어"><a href="#Screen-실행-명령어" class="headerlink" title="Screen 실행 명령어"></a>Screen 실행 명령어</h1><p>screen 관련 <code>명령어</code>에 대해 알아보겠습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; screen 을 시작하는 기본 명령어 입니다. 기본 세션명으로 시작합니다.</span><br><span class="line">$ screen</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 해당 세션명으로 스크린을 시작합니다.</span><br><span class="line">$ screen -S 세션명</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 이전에 작업 했던 screen 목록을 불러와 세션명과 함께 보여 줍니다.</span><br><span class="line">$ screen -list</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 이전에 작업 했던 세션이 있을 경우 해당 세션을 불러옵니다.</span><br><span class="line">&#x2F;&#x2F; 세션명을 주지 않았을 경우에는 이전 세션이 한개일 경우 그 작업을 불러오고, 여러개 일 경우에는 작업 리스트를 보여 줍니다.</span><br><span class="line">$ screen -R 세션명</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 스크린을 삭제합니다.</span><br><span class="line">$ screen -S 세션명 -X quit</span><br></pre></td></tr></table></figure>

<h1 id="Screen-실행-후-명렁어"><a href="#Screen-실행-후-명렁어" class="headerlink" title="Screen 실행 후 명렁어"></a>Screen 실행 후 명렁어</h1><p>Screen 실행 후의 명령어는 **<code>Ctrl-a로 시작</code>**합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 새로운 쉘을 생성(create) 하여 그 쉘로 이동합니다.</span><br><span class="line">$ Ctrl-a, c</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 바로 전(previous) 창으로 이동합니다.</span><br><span class="line">$ Ctrl-a, p</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 바로 다음(next) 창으로 이동합니다.</span><br><span class="line">$ Ctrl-a, n</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 숫자에 해당하는 창으로 이동합니다.</span><br><span class="line">$ Ctrl-a, 숫자</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 창번호 또는 창이름으로 이동합니다. (&#39; &#x3D;&gt; 싱글 쿼테이션)</span><br><span class="line">$ Ctrl-a, &#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 창목록을 보여 줍니다. (방향키와 Enter를 통해 창 선택 후 이동가능, &quot; &#x3D;&gt; 더블 쿼테이션)</span><br><span class="line">$ Ctrl-a, &quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 현재 창의 title을 수정합니다.</span><br><span class="line">$ Ctrl-a, A</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; screen의 명령행 모드로 전환합니다. (: &#x3D;&gt; 콜론)</span><br><span class="line">$ Ctrl-a, :</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 현재 작업을 유지하면서 screen 세션에서 빠져나옵니다.(detach)  세션이 종료 되지 않습니다.</span><br><span class="line">$ Ctrl-a, d</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 해당 스크린을 삭제합니다.</span><br><span class="line">$ Ctrl-a, k</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 해당 스크린에 lock을 겁니다. (해당 유저의 비밀번호를 입력해야 해제할 수 있다.)</span><br><span class="line">$ Ctrl-a, x</span><br></pre></td></tr></table></figure>

<p>다음은 <strong>창 관련</strong> 명령어입니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 창을 분할합니다(split).</span><br><span class="line">$ Ctrl-a, S</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 분할된 창으로 이동합니다.</span><br><span class="line">$ Ctrl-a, Tab</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 분할된 구역중 현재 구역을 제외하고 나머지를 숨깁니다.</span><br><span class="line">$ Ctrl-a, Q</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Ctrl-a, d(세션 유지) 와는 달리 세션을 완전히 종료합니다.</span><br><span class="line">$ exit</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-02-11T15:00:00.000Z" title="2/12/2017, 12:00:00 AM">2017-02-12</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-22T13:16:31.416Z" title="3/22/2021, 10:16:31 PM">2021-03-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/React-Native/">React Native</a></span><span class="level-item">30분안에 읽기 (약 4545 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/02/12/ReactNative/redux-for-starter/">Redux 사용하기</a></h1><div class="content"><p>공부하고 반복해서 복습하고 마지막에는 스스로 정리해보는 시간을 갖는것이 스스로에게 많은 도움이 되는것 같습니다. 그래서 이번에는 **<code>ReactNative에서 Redux를 사용하기</code>**라는 주제로 포스팅을 하려합니다. Flux에서 Redux 그리고 ReactNative까지 정말 자세하고 친절하게 설명해주신 분들이 많습니다. 제가 공부하며 참고했던 좋은 글들과 강의는 <a href="https://jongmin92.github.io/reactnative/2017/02/10/React-Native-%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0-%EC%9D%BD%EA%B8%B0-%EC%A2%8B%EC%9D%80-%EA%B8%80-%EB%AA%A8%EC%9D%8C/">React Native 글 모음</a>에 따로 정리를 하였습니다. <strong>이 글에서는 제가 그동안 Redux 공부하며 이해가 잘 되지 않았던 부분들에 중점을 맞춰서 정리해보고 React Native에 Redux를 적용시키는 것으로 마무리하려 합니다.</strong> 아직은 Redux에 대해 잘 안다고 말할 수 없지만, 이번 기회로 정리하며 다시 다잡으려 합니다. 혹시나 제가 잘못이하거나 틀린 부분이 있다면 댓글로 알려주시면 감사하겠습니다.</p>
<h1 id="Flux와-Redux"><a href="#Flux와-Redux" class="headerlink" title="Flux와 Redux"></a>Flux와 Redux</h1><h2 id="Redux의-시작은-Flux"><a href="#Redux의-시작은-Flux" class="headerlink" title="Redux의 시작은 Flux"></a>Redux의 시작은 Flux</h2><p><code>Redux</code>는 페이스북에서 MVC 패턴의 단점을 보완하고자 만든 아키텍처인 <strong>Flux의 구현체중 하나</strong>입니다. Flux의 구현체는 Redux 외에도 Reflux, rx-flux 등… 여러 구현체가 있지만 그중 Redux가 가장 널리 사용되고 있습니다.</p>
<p>저는 Redux를 처음 접했을때 Flux와 많이 혼동했습니다. Redux와 Flux의 <strong>구성 요소와 역할</strong>에 대해 혼란스러웠고 정리가 잘 되지 않았는데 이는 Redux와 Flux의 다른점에 대해 집중하지 않았기 때문입니다. Redux는 Flux와 마찬가지로 <strong>애플리케이션의 상태를 예측 가능</strong>하게 합니다. 그러나 Redux는 Flux와 다른 특징이 있습니다. 바로 **<code>핫 리로딩(hot reloading)</code>**과 **<code>시간 여행 디버깅(time travel debugging)</code>**입니다. 이 두가지의 특징으로 인해 Redux는 Flux의 구성요소에는 없는 <code>리듀서(reducer)</code>가 생겨나고, <code>스토어(Store)의 역할</code>이 조금 변하게 됩니다.</p>
<h2 id="리듀서-Reducer"><a href="#리듀서-Reducer" class="headerlink" title="리듀서(Reducer)"></a>리듀서(Reducer)</h2><p>Flux에서 스토어는 <strong>(1) 상태 변환을 위한 로직, (2) 현재 애플리케이션의 상태를 포함</strong>하고 있습니다. 스토어가 이 두 가지를 모두 갖고 있기 때문에 핫 리로딩시 문제가 발생합니다. 상태 변환을 위한 로직을 수정하기 위해 스토어 객체를 리로딩하면 스토어에 저장된 기존의 상태와 뷰를 비롯한 나머지 시스템과의 이벤트 구독이 사라지게 되어 문제가되기 때문입니다. 이를 해결하기 위해 Redux에서는 <code>리듀서(reducer)</code>가 새로운 구성요소로 추가됩니다.</p>
<p><strong>리듀서는 스토어가 갖고 있던 상태 변환을 위한 로직을 대신 갖게됩니다.</strong> 따라서 스토어는 액션이 발생했을 때 어떤 상태 변화를 만들어야 하는지 알기위해 리듀서에게 요청합니다. 이렇게 기존 스토어에서 상태 변환을 위한 로직이 분리되었기 때문에 이제 <code>핫 리로딩</code>이 가능하게 됩니다.</p>
<p>리듀서는 첫 번째 인수로 기존 상태의 값 두 번째 인수로는 액션을 가집니다. 리듀서를 작성할 때는 주의사항이 있는데, <strong>첫 번째 인수로서 기존 상태를 갖고 있는 state는 수정하지 않고 상태를 수정할 때는 새롭게 생성</strong>하여야 합니다. 이 주의사항으로 지킴으로써 각각의 액션이 발생할 때마다 새로운 상태의 객체가 생성되어 결과적으로는 Redux의 특징인 <code>시간 여행 디버깅</code>이 가능하게 됩니다.</p>
<h2 id="스토어-Store"><a href="#스토어-Store" class="headerlink" title="스토어(Store)"></a>스토어(Store)</h2><p>Redux의 스토어는 Flux의 스토어와는 다소 차이가 있습니다. 먼저 Flux에서는 다수의 스토어를 가질 수 있었고, 각 스토어는 자신의 범위에 있는 애플리케이션의 상태를 변환할 수 있는 로직을 포함하고 있었습니다. 그러나 <strong>Redux는 하나의 스토어만</strong>을 가집니다. 또한 Redux의 스토어는 <strong>상태 트리(state tree) 전체를 유지</strong>하는 책임을 가지며, Flux의 <strong>디스패쳐(dispatcher)의 역할</strong>도 대신합니다.(Flux의 디스패쳐는 모든 스토어를 갖고 있고, 액션 생성자로부터 액션을 넘겨받으면 스토어에 전달합니다.) 따라서 Redux에서는 스토어에서 제공하는 dispatch 함수로 디스패쳐의 동작을 대신합니다.</p>
<h1 id="Redux-구성요소"><a href="#Redux-구성요소" class="headerlink" title="Redux 구성요소"></a>Redux 구성요소</h1><p>지금까지 Flux와 Redux의 차이점과 그로 인해 Redux가 가질 수 있게된 특징에 대해 알아보았습니다. 지금부터는 Redux의 구성요소를 살펴보겠습니다.</p>
<h2 id="액션-Action"><a href="#액션-Action" class="headerlink" title="액션(Action)"></a>액션(Action)</h2><p><code>액션</code>은 애플리케이션의 상태를 갖고 있는 스토어로 전달하는 <strong>데이터 묶음</strong>입니다. <code>store.dispatch()</code> 를 통해 스토어에 액션을 전달할 수 있습니다.</p>
<p>액션은 평범한 자바스크립트 객체이며, <strong>type</strong> 속성을 갖고 있습니다. 이 type 속성은 액션을 전달받은 스토어가 애플리케이션의 상태변환 로직을 갖고 있는 리듀서를 참조할때 사용하게 됩니다.</p>
<h2 id="액션-생성자-Action-Creator"><a href="#액션-생성자-Action-Creator" class="headerlink" title="액션 생성자(Action Creator)"></a>액션 생성자(Action Creator)</h2><p><code>액션 생성자</code>는 액션을 만드는 함수입니다. Flux에서는 함수 내부에서 dispatch 함수를 통해 액션을 전달하지만 Redux의 액션 생성자는 단지 <strong>액션을 반환</strong>하기만 합니다. 실제 액션을 전달할때는 결과값을 dispatch 함수에 전달하거나 생성된 액션을 자동으로 보내주는 <strong>바인드된 액션 생성자</strong>를 만듭니다.</p>
<h2 id="리듀서-Reducer-1"><a href="#리듀서-Reducer-1" class="headerlink" title="리듀서(Reducer)"></a>리듀서(Reducer)</h2><p>액션은 무언가 일어나 상태가 변할것이라는 사실을 말할뿐, 그 결과 실제 애플리케이션의 상태가 어떻게 바뀌는지는 리듀서가 담당합니다. <code>리듀서</code>는 이전 상태와 액션을 받아서 다음 상태를 반환하는 역할을 하는 <strong>순수 함수</strong>입니다.  따라서 항상 다음 상태를 계산해서 반환하는 역할만 합니다. API 호출이라던가, Date.now()나 Math.random() 과 같은 순수하지 않은 함수를 호출하는 일은 해서는 안됩니다.</p>
<p>Redux는 처음에 리듀서를 undefined 상태로 호출하여 초기 상태를 반환합니다. 리듀서는 서로 독립적으로 수행된다면 분리될 수 있고, 이 분리된 리듀서는 *<em>루트 리듀서</em>라는 하나의 객체로 조합될 수 있습니다. 결과적으로 처음에 undefined 상태로 호출되면 각각의 자식 리듀서들이 초기 상태를 반환하게 되고, 각각의 리듀서는 전체 상태에서 자신의 부분만을 관리합니다. 모든 리듀서의 state 매개변수는 서로 다르고, 자신이 관리하는 상태 부분에 해당합니다.</p>
<h2 id="스토어-Store-1"><a href="#스토어-Store-1" class="headerlink" title="스토어(Store)"></a>스토어(Store)</h2><p><code>스토어</code>는 “무엇이 일어날지”를 표현하는 <strong>액션</strong>과 이 액션에 따라 애플리케이션의 상태를 어떻게 수정할지를 나타는 <strong>리듀서</strong>를 함께 가져오는 객체입니다. 스토어는 다음과 같은 일들을 합니다.</p>
<ul>
<li>애플리케이션의 상태를 저장</li>
<li>getState()를 통해 상태에 접근</li>
<li>dispatch(action)을 통해 상태를 수정할 수 있게 함</li>
<li>subscribe(listener)를 통해 리스너를 등록</li>
</ul>
<p>Redux의 스토어는 Flux와는 달리 하나의 스토어만을 가질 수 있기 때문에 데이터를 다루는 로직을 나누고 싶다면 여러개의 리듀서를 조합하여 대신할 수 있습니다.</p>
<h2 id="뷰-레이어-바인딩-The-view-layer-binding"><a href="#뷰-레이어-바인딩-The-view-layer-binding" class="headerlink" title="뷰 레이어 바인딩(The view layer binding)"></a>뷰 레이어 바인딩(The view layer binding)</h2><p><code>뷰 레이어 바인딩</code>은 생성된 <strong>스토어를 뷰에 연결하기 위해 필요</strong>합니다. 뷰 레이어 바인딩은 <strong>connect()</strong> 을 통해 컴포넌트(뷰)가 애플리케이션의 상태 업데이트를 받을 수 있도록 모든 연결을 만들어줍니다.</p>
<h2 id="루트-컴포넌트-Root-component"><a href="#루트-컴포넌트-Root-component" class="headerlink" title="루트 컴포넌트(Root component)"></a>루트 컴포넌트(Root component)</h2><p>모든 React 애플리케이션은 루트 컴포넌트를 가집니다. 루트 컴포넌트는 계층 구조에서 가장 위에 위치하는 컴포넌트이며, 스토어를 생성하고 어떤 리듀서를 사용할지 알려주며 뷰 레이어 바인딩과 뷰를 불러옵니다.</p>
<h1 id="Redux-사용-준비"><a href="#Redux-사용-준비" class="headerlink" title="Redux 사용 준비"></a>Redux 사용 준비</h1><p>애플리케이션을 생성하며 Redux의 구성요소들이 서로 연결됩니다.</p>
<ol>
<li>**combineReducers()**를 통해 다수의 리듀서를 하나로 묶은 후 루트 컴포넌트가 **createStore()**를 이용해 스토어를 생성할때 전달합니다.</li>
<li>루트 컴포넌트는 공급 컴포넌트와 스토어 사이를 연결함으로써 스토어와 컴포넌트 사이의 커뮤니케이션을 준비합니다. (이후 컴포넌트에서 connect()를 통해 상태 업데이트를 받을 수 있습니다.)</li>
</ol>
<h1 id="Redux-데이터-흐름"><a href="#Redux-데이터-흐름" class="headerlink" title="Redux 데이터 흐름"></a>Redux 데이터 흐름</h1><p>Redux의 아키텍쳐는 <strong>엄격한 일방향 데이터 흐름</strong>에 따라 전개되며 데이터의 흐름은 4단계에 따라 진행됩니다.</p>
<p><strong>1. 액션 생성 후 스토어에 전달</strong><br>액션은 무언가 일어나 상태가 변할 것이라는 내용을 담고 있는 객체입니다. 액션 생성자를 통해 액션을 생성한 후 <code>store.dispatch(action)</code>을 통해 스토어에 전달합니다.</p>
<p><strong>2. 스토어가 리듀서를 호출</strong><br>스토어는 리듀서에 현재의 상태 트리와 전달받은 액션을 두 가지 인수로 전달합니다.</p>
<p><strong>3. 루트 리듀서가 각 리듀서의 출력을 합쳐 하나의 상태 트리 생성</strong><br>각각의 상태를 다루는 리듀서에 의해 생성된 결과를 하나로 합쳐 <strong>루트 리듀서가 하나의 상태 트리를 생성</strong>합니다.</p>
<p><strong>4. Redux 스토어가 루트 리듀서에 의해 반환된 상태 트리를 저장</strong><br>새로운 상태 트리가 앱의 다음 상태입니다. store.subscribe(listener)를 통해 등록된 모든 리스너가 불러내지고 이들은 현재 상태를 얻기 위해 store.getState()를 호출합니다. connect()를 통해 컴포넌트에 스토어가 연결되어 있다면 컴포넌트는 이를 반영하고 자신의 setState()나 forceUpdate() 메소드를 실행해 <strong>자동적으로 <code>render()</code> 메소드를 호출</strong>합니다.</p>
<h1 id="React-Native에서-Redux-사용하기"><a href="#React-Native에서-Redux-사용하기" class="headerlink" title="React Native에서 Redux 사용하기"></a>React Native에서 Redux 사용하기</h1><p>이제 React Native에서 Redux를 사용해보겠습니다. React Native를 위한 개발환경 설정은 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://facebook.github.io/react-native/docs/getting-started.html">공식홈페이지</a>를 참조하시기 바랍니다. 이 예제 프로젝트에서는 간단하게 Redux를 사용하는 법에 초점을 맞춰 진행해보겠습니다.<br>간단히 카운팅하는 앱을 만들어보려 합니다. 완성 화면은 다음과 같습니다.<br><img src="/images/post/2017-02-12/result.png" alt="result"></p>
<h2 id="프로젝트-생성"><a href="#프로젝트-생성" class="headerlink" title="프로젝트 생성"></a>프로젝트 생성</h2><p> 먼저 React Native 프로젝트를 생성합니다. (현재 버전은 0.41.2 입니다)<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init example</span><br></pre></td></tr></table></figure></p>
<p>다음으로 redux를 사용하기 위해 필요한 모듈들을 설치합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redux react-redux --save</span><br></pre></td></tr></table></figure>

<p>이제 Redux의 구성요소를 참고하여 다음과 같이 새로운 폴더 구조를 생성합니다. (앞으로 사용할 폴더와 파일만 명시하였습니다.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example</span><br><span class="line">    ├── __tests__&#x2F;</span><br><span class="line">    ├── android&#x2F;</span><br><span class="line">    ├── ios&#x2F;</span><br><span class="line">    ├── node_modules&#x2F;</span><br><span class="line">    └── src&#x2F;</span><br><span class="line">        ├── actions&#x2F;</span><br><span class="line">            ├── index.js</span><br><span class="line">            ├── countAction.js</span><br><span class="line">            └── types.js</span><br><span class="line">        ├── components&#x2F;</span><br><span class="line">            └── Count.js</span><br><span class="line">        ├── reducers&#x2F;</span><br><span class="line">            ├── index.js</span><br><span class="line">            └── countReducer.js</span><br><span class="line">        └── app.js</span><br><span class="line">    ├── index.android.js</span><br><span class="line">    ├── index.ios.js</span><br><span class="line">    └── package.json</span><br></pre></td></tr></table></figure>

<h2 id="루트-컴포넌트-생성-amp-설정"><a href="#루트-컴포넌트-생성-amp-설정" class="headerlink" title="루트 컴포넌트 생성 &amp; 설정"></a>루트 컴포넌트 생성 &amp; 설정</h2><p>먼저 <code>app.js</code> 파일을 작성합니다. App 컴포넌트는 루트 컴포넌트로 사용될 것이며, 액션과 리듀서 파일을 작성후 스토어를 추가할것입니다.</p>
<script src="https://gist.github.com/jongmin92/f0938ac4c479af82dedc715d6e40efdd.js"></script>

<p>다음은 Android와 iOS의 진입파일인 <code>index.android.js</code>와 <code>index.ios.js</code>을 수정하여 App 컴포넌트를 <strong>루트 컴포넌트</strong>로 등록합니다.</p>
<script src="https://gist.github.com/jongmin92/05d571340819d8d1fcfdbfec6ae21465.js"></script>

<p>지금까지의 코드를 작성한 후 화면은 다음과 같습니다.<br><img src="/images/post/2017-02-12/result1.png" alt="result1"></p>
<h2 id="Count-컴포넌트-생성"><a href="#Count-컴포넌트-생성" class="headerlink" title="Count 컴포넌트 생성"></a>Count 컴포넌트 생성</h2><p>이제 <code>Count.js</code> 파일을 작성하여 Count 컴포넌트를 생성하겠습니다. Count 컴포넌트는 현재 카운트 되고 있는 숫자를 보여주는 텍스트와 카운트를 증가시키는 버튼으로 구성됩니다.</p>
<script src="https://gist.github.com/jongmin92/3457f6cc230bdb380578e8141b2d13a5.js"></script>

<p>Count 컴포넌트를 <code>app.js</code>에서 사용합니다.</p>
<script src="https://gist.github.com/jongmin92/092b3138decf73c3be088c495d2f2b8a.js"></script>

<p>Count 컴포넌트를 추가한 후 화면입니다.<br><img src="/images/post/2017-02-12/result2.png" alt="result2"></p>
<h2 id="Count-액션-생성"><a href="#Count-액션-생성" class="headerlink" title="Count 액션 생성"></a>Count 액션 생성</h2><p><code>액션</code>은 애플리케이션의 상태를 갖고 있는 스토어로 전달하는 <strong>데이터 묶음</strong>이라고 했습니다. 이 카운팅 앱에서는 액션 객체의 <code>type</code>을 통해서 <strong>증가인지 감소인지</strong>, <code>payload</code>를 통해서는 <strong>증가 혹은 감소할 값</strong>을 전달할 것입니다.</p>
<p>먼저 <code>actions/types.js</code>를 작성합니다. types.js 에는 액션의 타입으로 사용될 값을 상수로 정의합니다. 타입은 후에 리듀서에서도 사용되기 때문에 미리 상수로 정의하는것이 실수를 줄일수도 있고, 후에 액션을 관리하는데에도 유용합니다.</p>
<script src="https://gist.github.com/jongmin92/2116596bb8ef6e851212cc03833b8532.js"></script>

<p>이제 <code>countAction.js</code>를 작성합니다. type과 payload로 이루어진 액션 객체 액션 생성자를 통해 생성되어 스토어로 전달됩니다.</p>
<script src="https://gist.github.com/jongmin92/fa28375571a544ea49edfedf27f18595.js"></script>

<p>마지막으로 <code>index.js</code>를 작성합니다. index.js 에서는 여러개의 액션을 하나의 객체로 묶어 컴포넌트 파일에서 쉽게 사용할 수 있도록 해주는 역할을 합니다.</p>
<script src="https://gist.github.com/jongmin92/d17d6cee53c084bd27be749062afca2a.js"></script>

<h2 id="Count-리듀서-생성"><a href="#Count-리듀서-생성" class="headerlink" title="Count 리듀서 생성"></a>Count 리듀서 생성</h2><p>액션을 전달받은 스토어가 상태를 변경하기 위해 리듀서에게 어떠한 상태변환을 해야하는지 요청합니다. 리듀서에서는 이 요청을 처리할 수 있도록 코드를 작성해야 합니다.<br><code>countReducer.js</code>를 작성합니다. 리듀서는 함수입니다. 첫 번째 인자로 <strong>이전의 상태</strong>를 전달받고, 두 번째 인자로는 <strong>액션</strong>을 전달받습니다. 전달 받은 액션의 type을 통해 새로운 상태를 반환하는것이 리듀서의 역할입니다.<br>애플리케이션 실행 후 Redux는 처음에 리듀서를 undefined 상태로 호출합니다. swtich문에서 default인 상태에서 초기 상태를 설정합니다.</p>
<script src="https://gist.github.com/jongmin92/efd6d626ad9e2ee4bc0c547fa22693f5.js"></script>

<p>액션과 마찬가지로 <code>index.js</code>를 작성합니다. 여러개의 리듀서를 묶어 컴포넌트 파일에서 쉽게 사용할 수 있도록 해주는 역할입니다.<br>redux 모듈의  <strong>combineReducer</strong>는 트리 구조로 분리된 여러개의 상태를 하나의 단일 상태 트리로 조합합니다.</p>
<script src="https://gist.github.com/jongmin92/b50a64d390ca615a4839ac9cf741a23a.js"></script>

<h2 id="루트-컴포넌트에-스토어-연결"><a href="#루트-컴포넌트에-스토어-연결" class="headerlink" title="루트 컴포넌트에 스토어 연결"></a>루트 컴포넌트에 스토어 연결</h2><p>생성한 액션과 리듀서를 애플리케이션에서 사용할 수 있도록 루트 컴포넌트에 설정해주어야 합니다. 처음 작성했던 <code>app.js</code>를 다음과 같이 수정합니다.<br><code>redux</code> 모듈에 있는 <strong>createStore</strong>를 통해 스토어를 생성할 수 있습니다. store 생성시 인자로 리듀서를 필요로 합니다.<br>생성된 스토어를 React 에서 사용하기 위해 <code>react-redux</code> 모듈에서 <strong>Provider</strong>를 사용합니다.</p>
<script src="https://gist.github.com/jongmin92/d042325f829d326a47ae3f8c1173acbe.js"></script>

<h2 id="Count-컴포넌트-바인딩"><a href="#Count-컴포넌트-바인딩" class="headerlink" title="Count 컴포넌트 바인딩"></a>Count 컴포넌트 바인딩</h2><p>뷰 레이어 바인딩은 생성된 스토어를 뷰에 연결하기 위해 필요하다고 설명했습니다. 이제 생성한 액션과 리듀서를 Count 컴포넌트에서 사용할 수 있도록 <strong>connect</strong>를 통해 연결을 만들어줍니다.<br>connect 메서드는 Store의 state를 컴포넌트의 props로 전달하고 상태의 변화가 있을 때 자동으로 컴포넌트의 render를 재호출합니다. connect 메서드는 다음의 인자를 가집니다.</p>
<ul>
<li><strong>mapStateToProps</strong> : 스토어의 state를 해당 컴포넌트의 props로 전달(mapping)합니다.</li>
<li><strong>mapDispatchToProps</strong> : 스토어의 dispatch를 props에 전달합니다. dispatch를 통해 액션생성자에서 생성한 액션을 스토어로 전달할 수 있습니다.</li>
</ul>
<script src="https://gist.github.com/jongmin92/9197ec9dc499b6fa89cf1d8570d77bda.js"></script>

<p>간단한 카운팅앱이 완성되었습니다. 버튼을 통해 count의 값을 변경할 수 있습니다.</p>
<h1 id="포스팅을-마치며"><a href="#포스팅을-마치며" class="headerlink" title="포스팅을 마치며"></a>포스팅을 마치며</h1><p>MVC 패턴에 익숙해져있던 저에게 Redux는 머리로는 이해할 수 있었지만 가슴으로는? 이해기 쉽지 않았었습니다. 이번 기회에 다시 하번 정리를 하며 제가 처음에 혼란스러워했던 부분들을 최대한 설명해드리려 노력했습니다. 위의 예제가 좋은 예제라고는 말할 수 없지만 그래도 React Native에서 Redux가 어떻게 사용되는지 전체적인 구조를 보는데에는 나쁘지 않다고 생각합니다.<br>액션과 리듀서를 생성하고 사용하는 부분에 있어서는 여러가지의 방법이 있지만 최대한 Redux를 쉽게 이해할 수 있도록 작성해보았습니다. 좀 더 효율적으로 작성하는 법은 다음에 기회가 된다면 포스팅해보겠습니다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-02-09T15:00:00.000Z" title="2/10/2017, 12:00:00 AM">2017-02-10</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-22T13:16:49.033Z" title="3/22/2021, 10:16:49 PM">2021-03-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/React-Native/">React Native</a></span><span class="level-item">3분안에 읽기 (약 488 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/02/10/ReactNative/useful-post-collection/">시작하며 읽기 좋은 글 모음</a></h1><div class="content"><p>React Native를 공부하고 사용하면서 도움이 되었던 글들을 모아놓았습니다. 각 카테고리별로 분류하였으며 처음 공부하시는 분들은 카테고리에서 <strong>위에서 아래로 순서대로</strong> 읽으시면 많은 도움이 될거라 생각합니다. 앞으로도 지속적으로 업데이트 할 예정입니다.</p>
<hr>
<p><strong>최근 업데이트 -  2017 / 05 / 30</strong></p>
<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><ul>
<li><strong><a target="_blank" rel="external nofollow noopener noreferrer" href="https://velopert.com/reactjs-tutorials">Velopert님의 React Tutorial</a> - velopert’s dev blog</strong><br>React를 처음 공부할때 큰 도움이 됩니다.</li>
</ul>
<hr>
<h1 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h1><ul>
<li><strong><a target="_blank" rel="external nofollow noopener noreferrer" href="http://bestalign.github.io/2015/10/06/cartoon-guide-to-flux/">Flux로의 카툰 안내서</a> - bestalign’s dev blog</strong><br>Redux는 Flux 아키텍처의 구현체중 하나 입니다. Redux를 공부하기전 Flux에 대해 알아볼 수 있습니다.</li>
</ul>
<hr>
<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><ul>
<li><strong><a target="_blank" rel="external nofollow noopener noreferrer" href="http://redux.js.org/">Redux 공식홈페이지(영문)</a> - redux.js.org</strong></li>
<li><strong><a target="_blank" rel="external nofollow noopener noreferrer" href="http://dobbit.github.io/redux/">Redux 공식홈페이지(한글 번역)</a> - dobbit</strong></li>
<li><strong><a target="_blank" rel="external nofollow noopener noreferrer" href="http://bestalign.github.io/2015/10/26/cartoon-intro-to-redux/">Redux로의 카툰 안내서</a> - bestalign’s dev blog</strong><br>React Native를 시작하며 Redux를 처음 공부할때 도움이 많이 되었습니다. Redux의 시스템을 잘게 나누어 여러 캐릭터로 비유하여 설명하신 부분이 인상깊었습니다.</li>
<li><strong><a target="_blank" rel="external nofollow noopener noreferrer" href="https://taegon.kim/archives/5288">Flux와 Redux(MVC의 한계를 극복한 단순한 데이터 모델)</a> - 코드쓰는사람(taegon.kim)</strong><br>MVC 패턴의 문제점 부터 시작하여 Flux가 어떻게 나오게 되었는지 마지막으로 Redux 까지 정리해주셨습니다.</li>
<li><strong><a target="_blank" rel="external nofollow noopener noreferrer" href="http://d2.naver.com/helloworld/1848131">React 적용 가이드 - React와 Redux</a> - NAVER D2</strong></li>
<li><strong><a target="_blank" rel="external nofollow noopener noreferrer" href="http://huns.me/development/1953">리덕스(Redux) 애플리케이션 설계에 대한 생각</a> - 김코딩님이 코딩 잘하고 싶어서 만든 블로그</strong><br>Redux를 사용하여 애플리케이션을 개발하시면서 고민하셨던 생각을 정리한 글. Redux를 사용한다면 읽어보기에 정말 좋은 글입니다.</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/Programming/archives/7/">이전</a></div><div class="pagination-next"><a href="/categories/Programming/archives/9/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/Programming/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/Programming/archives/7/">7</a></li><li><a class="pagination-link is-current" href="/categories/Programming/archives/8/">8</a></li><li><a class="pagination-link" href="/categories/Programming/archives/9/">9</a></li><li><a class="pagination-link" href="/categories/Programming/archives/10/">10</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpeg" alt="JongMin"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">JongMin</p><p class="is-size-6 is-block">생각을 기록하자</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">125</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">22</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">201</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/jongmin92" target="_blank" rel="external nofollow noopener noreferrer">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/jongmin92"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Facebook" href="https://www.facebook.com/jongmin.kim.7796420"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/BOJ/"><span class="level-start"><span class="level-item">BOJ</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Concept/"><span class="level-start"><span class="level-item">Concept</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Book/"><span class="level-start"><span class="level-item">Book</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">97</span></span></a><ul><li><a class="level is-mobile" href="/categories/Programming/AWS/"><span class="level-start"><span class="level-item">AWS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Gradle/"><span class="level-start"><span class="level-item">Gradle</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/HTML/"><span class="level-start"><span class="level-item">HTML</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Linux-Ubuntu/"><span class="level-start"><span class="level-item">Linux &amp; Ubuntu</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Node/"><span class="level-start"><span class="level-item">Node</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/RaspberryPi/"><span class="level-start"><span class="level-item">RaspberryPi</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/React-Native/"><span class="level-start"><span class="level-item">React Native</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Project/"><span class="level-start"><span class="level-item">Project</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Project/Emily/"><span class="level-start"><span class="level-item">Emily</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Tip/"><span class="level-start"><span class="level-item">Tip</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-20T15:17:42.000Z">2021-03-21</time></p><p class="title"><a href="/2021/03/21/Kotlin/coroutines/">코루틴 이해하기</a></p><p class="categories"><a href="/categories/Programming/">Programming</a> / <a href="/categories/Programming/Kotlin/">Kotlin</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2020-03-30T15:44:27.000Z">2020-03-31</time></p><p class="title"><a href="/2020/03/31/Java/use-assertthat/">Unit Test에서 AssertThat을 사용하자</a></p><p class="categories"><a href="/categories/Programming/">Programming</a> / <a href="/categories/Programming/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2020-01-02T13:29:00.000Z">2020-01-02</time></p><p class="title"><a href="/2020/01/02/Java/rsa/">Encryption - RSA</a></p><p class="categories"><a href="/categories/Programming/">Programming</a> / <a href="/categories/Programming/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-12-26T13:23:00.000Z">2019-12-26</time></p><p class="title"><a href="/2019/12/26/Programming/2019-retrospect/">2년차 LINE 서버 개발자의 2019년 회고</a></p><p class="categories"><a href="/categories/Programming/">Programming</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-12-23T14:37:00.000Z">2019-12-23</time></p><p class="title"><a href="/2019/12/23/Programming/hmac/">HMAC을 이용한 무결성 보장</a></p><p class="categories"><a href="/categories/Programming/">Programming</a></p></div></article></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">광고</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-3921438651818825" data-ad-slot="3015269677" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="92Hz" height="28"></a><p class="is-size-7"><span>&copy; 2021 KimJongMin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>