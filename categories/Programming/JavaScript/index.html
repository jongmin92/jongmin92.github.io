<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8">

<meta name="generator" content="Hexo 3.9.0">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<title>카테고리: JavaScript - 92Hz</title>

<!-- For SEO -->
<link rel="canonical" href="https://jongmin92.github.io/categories/programming/javascript/">


    <meta property="og:type" content="website">
<meta property="og:title" content="92Hz">
<meta property="og:url" content="https://jongmin92.github.io/categories/Programming/JavaScript/index.html">
<meta property="og:site_name" content="92Hz">
<meta property="og:locale" content="ko">
<meta property="og:image" content="https://jongmin92.github.io/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="92Hz">
<meta name="twitter:image" content="https://jongmin92.github.io/images/og_image.png">





<link rel="alternative" href="rss2.xml" title="92Hz" type="application/atom+xml">



<link rel="icon" href="/images/favicon.png">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90389042-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-90389042-1');
</script>

    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.png" alt="92Hz" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item" href="/">Home</a>
                
                <a class="navbar-item" href="/archives">Archives</a>
                
                <a class="navbar-item" href="/categories">Categories</a>
                
                <a class="navbar-item" href="/tags">Tags</a>
                
                <a class="navbar-item" href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="검색" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/categories">카테고리</a></li>
            
            <li><a href="/categories/Programming/">Programming</a></li>
            
            <li class="is-active"><a href="#" aria-current="page">JavaScript</a></li>
        </ul>
        </nav>
    </div>
</div>

    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-06-17T15:00:00.000Z">2017-06-18</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    15분 읽기 (대략 2239 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/06/18/JavaScript/class/">ES6 Class 파헤치기</a>
            
        </h1>
        <div class="content">
            <h2 id="index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><ol>
<li><a href="#1">ES6 Class 문법</a></li>
<li><a href="#2">Class 정의</a></li>
<li><a href="#3">constructor</a></li>
<li><a href="#4">Prototype 기반 상속(ES5)과 Class 기반 상속(ES6) 비교</a></li>
<li><a href="#5">super 키워드</a></li>
<li><a href="#6">static 키워드</a></li>
<li><a href="#7">마치며</a></li>
</ol>
<hr>
<p><span id="1"></span></p>
<h2 id="es6-class-문법"><a href="#ES6-Class-문법" class="headerlink" title="ES6 Class 문법"></a>ES6 Class 문법</h2><p>JavaScript <strong><code>Class</code></strong>는 ECMAScript 6을 통해 소개되었습니다. ES6의 Class는 기존 <strong><code>prototype</code></strong> 기반의 상속을 보다 명료하게 사용할 수 있도록 문법을 제공합니다. 이를  <strong>Syntatic Sugar</strong>라고 부르기도 합니다.</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Syntactic_sugar" rel="external nofollow noopener noreferrer" target="_blank">Syntatic Sugar</a> : 읽고 표현하는것을 더 쉽게 하기 위해서 고안된 프로그래밍 언어 문법을 말합니다.</p>
</blockquote>
<p>JavaScript를 ES6를 통해 처음 접하시는 분들은 알아두셔야할 것이 JavaScript의 Class는 다른 객체지향 언어(C++, C#, Java, Python, Ruby 등…)에서 사용되는 Class 문법과는 다르다는 것입니다. JavaScript에는 Class라는 개념이 없습니다.<br>Class가 없기 때문에 기본적으로 Class 기반의 상속도 불가능합니다. 대신 다른 언어에는 존재하지 않는 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain" rel="external nofollow noopener noreferrer" target="_blank">프로토타입(Prototype)</a>이라는 것이 존재합니다. JavaScript는 이 <strong>prototype을 기반으로 상속을 흉내내도록 구현해 사용</strong>합니다. Prototype을 처음 접하시는 분은 <a href="https://jongmin92.github.io/2017/03/14/JavaScript/understand-prototype/">“Prototype 이제는 이해하자”</a>를 참고하시면 도움이 될것같습니다.</p>
<hr>
<p><span id="2"></span></p>
<h2 id="class-정의"><a href="#Class-정의" class="headerlink" title="Class 정의"></a>Class 정의</h2><p>JavaScript에서 Class는 사실 <strong>함수</strong>입니다. 함수를 <strong>함수 선언</strong>과 <strong>함수 표현식</strong>으로 정의할 수 있듯이 class 문법도 <strong>class 선언</strong>과 <strong>class 표현식</strong> 두가지 방법으로 정의가 가능합니다.</p>
<p>JavaScript 엔진은 function 키워드를 만나면 Function 오브젝트를 생성하듯, class 키워드를 만나면 Class 오브젝트를 생성합니다. class는 클래스를 선언하는 키워드이고 Class 오브젝트는 엔진이 class 키워드로 생성한 오브젝트입니다.</p>
<h4 id="class-선언"><a href="#Class-선언" class="headerlink" title="Class 선언"></a>Class 선언</h4><p>함수 선언과 달리 클래스 선언은 <strong>호이스팅</strong>이 일어나지 않기 때문에, 클래스를 사용하기 위해서는 먼저 선언을 해야합니다. 그렇지 않으면 <strong>ReferenceError</strong> 가 발생합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    say() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'My name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="class-표현식"><a href="#Class-표현식" class="headerlink" title="Class 표현식"></a>Class 표현식</h4><p>Class 표현식은 이름을 가질 수도 있고 갖지 않을 수도 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> People = <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    say() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'My name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> People = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    say() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'My name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><span id="3"></span></p>
<h2 id="constructor"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>constructor는 클래스 인스턴스를 생성하고 생성한 인스턴스를 초기화하는 역할을 합니다. <strong>new People()</strong> 코드를 실행하면 <strong>People.prototype.constructor</strong>가 호출됩니다. 이를 default constructor라고 하며 constructor가 없으면 인스턴스를 생성할 수 없습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">'KimJongMin'</span>);</span><br></pre></td></tr></table></figure>
<p>new People(‘KimJongMin’)을 실행하면 People 클래스에 작성한 constructor가 자동으로 호출되고 파라미터 값으로 ‘KimJongMin’을 넘겨 줍니다.</p>
<p>new 연산자가 인스턴스를 생성하는 것처럼 보이지만, 사실 new 연산자는 constructor를 호출하면서 파라미터를 넘겨주는 역할만 합니다. 호출된 constructor가 인스턴스를 생성하여 반환하면 new 연산자가 받아 new를 실행한 곳으로 반환합니다. 과정은 다음과 같습니다.</p>
<ol>
<li>new People(‘KimJongMin’)을 실행</li>
<li>new 연산자가 constructor를 호출하면서 파라미터 전달</li>
<li>constructor에 작성한 코드를 실행하기 전에 빈 Object 를 생성</li>
<li>constructor 코드를 실행</li>
<li>생성한 Object(인스턴스)에 property 할당 (인스턴스를 먼저 생성했기 때문에 this로 Object 참조 가능</li>
<li>생성한 Object 반환</li>
</ol>
<p>다음은 생성된 인스턴스의 구조입니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(people);</span><br></pre></td></tr></table></figure>
<p><img src="/images/post/2017-06-18/instance-structure.png" alt=""></p>
<p>people 인스턴스의 <strong>__proto__</strong>는 People Class 오브젝트와 함께 생성된 <strong>Prototype object</strong>를 가리키고 있습니다. 결국 Class 문법을 이용한 코드를 prototype 기반의 코드로 변경하면 다음과 같습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">People.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><span id="4"></span></p>
<h2 id="prototype-기반-상속es5과-class-기반-상속es6-비교"><a href="#Prototype-기반-상속-ES5-과-Class-기반-상속-ES6-비교" class="headerlink" title="Prototype 기반 상속(ES5)과 Class 기반 상속(ES6) 비교"></a>Prototype 기반 상속(ES5)과 Class 기반 상속(ES6) 비교</h2><p>먼저 ES5에서 Prototype을 사용하여 상속을 구현하는 방법을 살펴보고, 그 후 ES6에서 Class로 상속을 구현하는 형태를 보겠습니다.</p>
<h4 id="es5-prototype-기반-상속"><a href="#ES5-Prototype-기반-상속" class="headerlink" title="ES5 Prototype 기반 상속"></a>ES5 Prototype 기반 상속</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' makes a noise.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Lion</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// `super()` 호출</span></span><br><span class="line">  Cat.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Cat` 클래스 상속</span></span><br><span class="line">Lion.prototype = <span class="built_in">Object</span>.create(Cat.prototype);</span><br><span class="line">Lion.prototype.constructor = Lion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `speak()` 메서드 오버라이드</span></span><br><span class="line">Lion.prototype.speak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Cat.prototype.speak.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' roars.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lion = <span class="keyword">new</span> Lion(<span class="string">'Samba'</span>);</span><br><span class="line">lion.speak();</span><br><span class="line"></span><br><span class="line">[결과]</span><br><span class="line">Sambda makes a noise.</span><br><span class="line">Sambda roars.</span><br></pre></td></tr></table></figure>
<p>new Lion()을 실행하면 Lion()이 호출되고, default constructor를 호출합니다. 그래서 Lion()을 생성자(constructor) 함수라고 합니다.</p>
<p>생성자 함수가 있으면 Cat.prototype.speak와 같이 prototype에 메서드를 연결한 코드가 있습니다. 이와 같이 prototype에 작성하지 않으면 각각의 인스턴스에 메서드가 생성되게 됩니다. 이 형태가 ES5에서 인스턴스를 구현하는 기본 형태 입니다.</p>
<p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/create" rel="external nofollow noopener noreferrer" target="_blank">Object.create()</a>를 통해 Cat.prototype에 연결된 메서드를 Lion.prototype.__proto__에 첨부합니다. Lion.prototype에는 constructor가 연결되어 있는데 prototype을 재 할당했기 때문에 지워진 constructor를 다시 할당해 줍니다.</p>
<p>결과적으로 Lion 생성자 함수의 구조는 다음과 같습니다.</p>
<p><img src="/images/post/2017-06-18/instance-structure2.png" alt=""></p>
<h4 id="es6-class-기반-상속"><a href="#ES6-Class-기반-상속" class="headerlink" title="ES6 Class 기반 상속"></a>ES6 Class 기반 상속</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' makes a noise.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="keyword">super</span>.speak();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' roars.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lion = <span class="keyword">new</span> Lion(<span class="string">'Samba'</span>);</span><br><span class="line">lion.speak();</span><br><span class="line"></span><br><span class="line">[결과]</span><br><span class="line">Sambda makes a noise.</span><br><span class="line">Sambda roars.</span><br></pre></td></tr></table></figure>
<p>ES6에서는 <strong><code>extends</code></strong> 키워드로 상속을 구현합니다. Cat 클래스를 상속받은 Lion 클래스의 구조는 다음과 같습니다.</p>
<p><img src="/images/post/2017-06-18/instance-structure3.png" alt=""></p>
<p>위의 prototype을 통해 상속을 구현한 Lion 생성자 함수의 구조와 비교했을때 일치합니다. 추가적으로 new Lion(‘Samba’) 를 실행하면 다음의 과정을 거치게됩니다.</p>
<ol>
<li>Lion 클래스의 constructor를 호출</li>
<li>Lion 클래스에 constructor를 작성하지 않았기 때문에 슈퍼 클래스의(Cat) constructor가 호출됨 (내부적으로 프로토타입 체인으로 인해)</li>
<li>슈퍼 클래스의 constructor에서 this는 현재의 인스턴스를 참조하므로 인스턴스의 name 프로퍼티에 파라미터로 전달받은 값을 설정</li>
<li>생성한 인스턴스를 lion에 할당</li>
</ol>
<hr>
<p><span id="5"></span></p>
<h2 id="super-키워드"><a href="#super-키워드" class="headerlink" title="super 키워드"></a>super 키워드</h2><p>서브 클래스와 슈퍼 클래스에 같은 이름의 메서드가 존재하면 슈퍼 클래스의 메서드는 호출되지 않습니다. 이때 <strong><code>super</code></strong> 키워드를 사용해서 슈퍼 클래스의 메서드를 호출할 수 있습니다. (서브 클래스의 constructor에 super()를 작성하면 슈퍼 클래스의 constructor가 호출됩니다.)</p>
<hr>
<p><span id="6"></span></p>
<h2 id="static-키워드"><a href="#static-키워드" class="headerlink" title="static 키워드"></a>static 키워드</h2><p>static 키워드는 클래스를 위한 정적(static) 메소드를 정의합니다. 정적 메소드는 prototype에 연결되지 않고 클래스에 직접 연결되기 때문에 클래스의 인스턴스화(instantiating) 없이 호출되며, 클래스의 인스턴스에서는 호출할 수 없습니다. 동일한 클래스 내의 다른 정적 메서드 내에서 정적 메서드를 호출하는 경우 키워드 this를 사용할 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> speak() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Noise~'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Lion.speak();</span><br><span class="line"></span><br><span class="line">[결과]</span><br><span class="line">Noise~</span><br></pre></td></tr></table></figure>
<p>정적 메소드는 어플리케이션(application)을 위한 유틸리티(utility) 함수를 생성하는데 주로 사용됩니다.</p>
<hr>
<p><span id="7"></span></p>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>ES6의 Class 문법에 대해 정리해 보았다. JavaScript 언어를 약 1년전 Node.js 를 시작하며 처음 접하게 되었는데 사실 그 당시 Prototype과 상속에 대해 크게 다룰일이 없었다. (어쩌면 너무 무지해서 사용 필요성을 느끼지 못했을 수도…) 그 후 Node.js 버전을 올리고 ES6를 공부하며 Class 문법을 접하게 되었는데 JavaScript의 Prototype에 대한 이해와 지식이 부족하다 보니 이전에 공부했던 C++과 Java의 Class 처럼 이해했던 것 같다. 그래도 그 후 Prototype과 더불이 Class까지 공부하며 지금은 어느정도 이해하게 된것 같다. 결론은… 역시나 JavaScript에서 Prototype을 이해하는건 중요한것 같다.</p>
<blockquote>
<p>참고<br><a href="https://gomugom.github.io/is-class-only-a-syntactic-sugar/" rel="external nofollow noopener noreferrer" target="_blank">ES6 Class는 단지 prototype 상속의 문법설탕일 뿐인가?</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes" rel="external nofollow noopener noreferrer" target="_blank">MDN - Classes</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain" rel="external nofollow noopener noreferrer" target="_blank">MDN - 상속과 프로토타입</a></p>
</blockquote>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-06-13T15:00:00.000Z">2017-06-14</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12분 읽기 (대략 1728 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/06/14/JavaScript/memoization/">메모이제이션 (Memoization)</a>
            
        </h1>
        <div class="content">
            <p><img src="/images/post/2017-06-14/bg.jpg" alt=""></p>
<h2 id="index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><ol>
<li><a href="#1">메모이제이션 이란?</a></li>
<li><a href="#2">메모이제이션 적용하기</a></li>
<li><a href="#3">결과 비교</a></li>
<li><a href="#4">마치며</a></li>
</ol>
<hr>
<p><span id="1"></span></p>
<h2 id="메모이제이션-이란"><a href="#메모이제이션-이란" class="headerlink" title="메모이제이션 이란?"></a>메모이제이션 이란?</h2><p>자바 스크립트에서 함수는 객체이기 때문에 프로퍼티를 가질 수 있습니다. 그리고 언제든지 함수에 사용자 정의 프로퍼티를 추가할 수도 있습니다. 함수에 프로퍼티를 추가하여 <strong>결과(반환 값)을 캐시</strong>하면 다음 호출 시점에 복잡한 연산을 반복하지 않을 수 있습니다. 이런 활용 방법을 <strong><code>메모이제이션 패턴</code></strong>이라고 합니다.</p>
<p>다음 코드에서는 myFunc 함수에 cache 프로퍼티를 생성합니다. 이 프로퍼티는 일반적인 프로퍼티처럼 myFunc.cache와 같은 형태로 접근할 수 있습니다. cache 프로퍼티는 함수로 전달된 param 매개변수를 키로 사용해서 계산의 결과를 값으로 가지는 객체(해시)입니다. 결과 값은 필요에 따라 복잡한 데이터 구조로 저장할 수도 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!myFunc.cache[param]) &#123;</span><br><span class="line">        <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 비용이 많이 드는 수행 후 result에 결과 저장</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        myFunc.cache[param] = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myFunc.cache[param];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 캐시 저장공간</span></span><br><span class="line">myFunc.cache = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><span id="2"></span></p>
<h2 id="메모이제이션-적용하기"><a href="#메모이제이션-적용하기" class="headerlink" title="메모이제이션 적용하기"></a>메모이제이션 적용하기</h2><p>메모이제이션을 공부한 후 현재 진행중인 <a href="https://jongmin92.github.io/2017/03/10/Emily/1-start-emily/">에밀리(개인 프로젝트)</a>에 적용해 보았습니다. 어느 부분에 적용했는지 적용 전과 적용 후 얼마나 효율이 올라갔는지를 알아보겠습니다.</p>
<h4 id="1-수정할-부분"><a href="#1-수정할-부분" class="headerlink" title="1. 수정할 부분"></a>1. 수정할 부분</h4><p>메모이제이션 패턴을 적용할 코드가 현재 하고 있는 기능은 다음과 같습니다. 사용자의 요청(학생식당, 카페테리아, 사범대식당, 기숙사식당, 교직원식당)에 따라 미리 크롤링 후 DB에 저장되어 있는 데이터(메뉴)를 가져와 응답합니다.<br><img src="/images/post/2017-06-14/description_1.png" alt="카카오톡 플러스친구 자동응답 봇"><br>메모이제이션 패턴을 사용함으로써 얻을 수 있는 이점은 <strong>비용이 많이 드는 결과를 캐싱하고 그 이후에 재사용함으로써 비용을 줄일 수 있다는 것입니다.</strong> 현재 코드에서 비용이 많이 드는 작업은 <strong>DB를 조회</strong>하는 부분입니다. DB에는 다음과 같이 미리 크롤링한 데이터가 날짜별로 저장되어 있습니다.</p>
<p><img src="/images/post/2017-06-14/db-table.png" alt="DB 메뉴 table"></p>
<p>사용자의 요청에 따라 해당 날짜의 데이터를 조회한 후 사용자가 요청한 식당에 맞는 데이터를 결과로 반환합니다. 그렇기 때문에 <strong>해당 날짜의 최초 요청이 이루어진 후 그 하루 동안에는 계속해서 DB에 같은 쿼리를 통해 같은 결과</strong>를 얻게 됩니다. 이 부분이 비용이 많이 드는 작업이기 때문에 메모이제이션 패턴을 통해 개선해보았습니다.</p>
<h4 id="2-메모이제이션-적용-전"><a href="#2-메모이제이션-적용-전" class="headerlink" title="2. 메모이제이션 적용 전"></a>2. 메모이제이션 적용 전</h4><p>먼저 메모이제이션 패턴을 적용하기 전 코드입니다. menuHandler 클래스의 <strong>getMenu</strong> 함수는 menuService를 통해 DB에서 해당 날짜의 식당 메뉴를 가져와 매개변수로 전달받은 식당의 이름을 사용하여 결과로 반환하는 역할을 합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dateUtil = <span class="built_in">require</span>(<span class="string">'util/dateUtil'</span>);</span><br><span class="line"><span class="keyword">const</span> menuService = <span class="built_in">require</span>(<span class="string">'services/menuService'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">menuHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> getMenu(place) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">_s, _f</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>().yyyymmdd();</span><br><span class="line">      <span class="keyword">let</span> menu = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">      menuService.show(today)</span><br><span class="line">        .then(<span class="function"><span class="params">menuList</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!menuList) &#123;</span><br><span class="line">            menu = <span class="string">'데이터가 없습니다. 관리자에게 문의해주세요'</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">switch</span> (place) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'학생식당'</span>:</span><br><span class="line">              menu = menuList.student.join(<span class="string">'\n\n'</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'카페테리아'</span>:</span><br><span class="line">              menu = menuList.cafeteria.join(<span class="string">'\n\n'</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'사범대식당'</span>:</span><br><span class="line">              menu = menuList.education.join(<span class="string">'\n\n'</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'기숙사식당'</span>:</span><br><span class="line">              menu = menuList.dormitory.join(<span class="string">'\n\n'</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'교직원식당'</span>:</span><br><span class="line">              menu = menuList.staff.join(<span class="string">'\n\n'</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          _s(menu);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          _f(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = menuHandler;</span><br></pre></td></tr></table></figure>
<h4 id="3-메모이제이션-적용-후"><a href="#3-메모이제이션-적용-후" class="headerlink" title="3. 메모이제이션 적용 후"></a>3. 메모이제이션 적용 후</h4><p>메모이제이션 패턴을 적용 한 후 코드입니다. <strong>setCache, getCache, pickMenu</strong> 함수가 추가되었고, getMenu 함수의 코드도 조금 변경되었습니다. 기존 코드의 getMenu 함수에서는 바로 DB를 조회하여 결과를 반환하였지만, 변경된 코드에서는 <strong>getCache</strong> 함수를 통해 캐시에 저장된 데이터가 있는지 확인 후 분기하여 처리합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dateUtil = <span class="built_in">require</span>(<span class="string">'util/dateUtil'</span>);</span><br><span class="line"><span class="keyword">const</span> menuService = <span class="built_in">require</span>(<span class="string">'services/menuService'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">menuHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> setCache(param, menuList) &#123;</span><br><span class="line">    menuHandler.cache[param] = menuList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getCache(param) &#123;</span><br><span class="line">    <span class="keyword">if</span> (menuHandler.cache[param]) &#123;</span><br><span class="line">      <span class="keyword">return</span> menuHandler.cache[param];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> pickMenu(menuList, place) &#123;</span><br><span class="line">    <span class="keyword">let</span> menu = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (place) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'학생식당'</span>:</span><br><span class="line">        menu = menuList.student.join(<span class="string">'\n\n'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'카페테리아'</span>:</span><br><span class="line">        menu = menuList.cafeteria.join(<span class="string">'\n\n'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'사범대식당'</span>:</span><br><span class="line">        menu = menuList.education.join(<span class="string">'\n\n'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'기숙사식당'</span>:</span><br><span class="line">        menu = menuList.dormitory.join(<span class="string">'\n\n'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'교직원식당'</span>:</span><br><span class="line">        menu = menuList.staff.join(<span class="string">'\n\n'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> menu;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getMenu(place) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">_s, _f</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>().yyyymmdd();</span><br><span class="line">      <span class="keyword">const</span> cachedMenuList = <span class="keyword">this</span>.getCache(today);</span><br><span class="line">      <span class="keyword">let</span> menu = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cachedMenuList) &#123;</span><br><span class="line">        menu = <span class="keyword">this</span>.pickMenu(cachedMenuList, place);</span><br><span class="line">        _s(menu);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        menuService.show(today)</span><br><span class="line">          .then(<span class="function"><span class="params">menuList</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!menuList) &#123;</span><br><span class="line">              menu = <span class="string">'데이터가 없습니다. 관리자에게 문의해주세요'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.setCache(today, menuList);</span><br><span class="line"></span><br><span class="line">            menu = <span class="keyword">this</span>.pickMenu(menuList, place);</span><br><span class="line">            _s(menu);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            _f(err);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">menuHandler.cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = menuHandler;</span><br></pre></td></tr></table></figure>
<p>Line:70 에서 선언한 menuHandler의 <strong>cache Object</strong>에는 다음과 같이 데이터가 <strong>캐싱</strong>될 것입니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    `2017-06-13`: &#123; ... menuList ...&#125;</span><br><span class="line">    `2017-06-14`: &#123; ... menuList ...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><span id="3"></span></p>
<h2 id="결과-비교"><a href="#결과-비교" class="headerlink" title="결과 비교"></a>결과 비교</h2><p>메모이제이션 패턴을 적용하기 전과 적용한 후의 성능 차이는 아래 보이는것처럼 눈에 띄게 차이가 납니다. 메모이제이션 패턴을 적용한 코드는 첫번째 요청(캐싱 하기 전)때는 메모이제이션 패턴 적용 전과 응답속도가 비슷하지만 그 이후의 응답은 캐싱된 데이터를 이용하기 때문에 비교될 정도로 빨라졌습니다.</p>
<p><img src="/images/post/2017-06-14/result1.png" alt="메모이제이션 적용 전"></p>
<p><img src="/images/post/2017-06-14/result2.png" alt="메모이제이션 적용 후"></p>
<hr>
<p><span id="4"></span></p>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>메모이제이션을 적용하기 전과 후 모두 같은 기능을 결과를 만들어내는 코드이지만 코드를 작성하는 방법에 따라 더욱 더 빠른 효율적인 서비스를 만들 수 있다는 것을 느끼게 되었습니다.<br>현재 제 상황에서는 캐싱된 데이터도 하루가 지나게되면 쓰이지 않고 계속 메모리에 남아있게 되는데 그 부분에 대한 처리를 추가해야할것 같습니다. 이번에 적용한 코드 뿐만 아니라 아직 프로잭트 내에 메모이제이션 패턴을 적용할 수 있는 부분이 더 있습니다. 앞으로 디자인패턴 공부를 계속하여 새로운 패턴들을 적용시키며 리팩토링을 해야겠습니다.</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-06-09T15:00:00.000Z">2017-06-10</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    10분 읽기 (대략 1564 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/06/10/JavaScript/promise/">다시 공부하는 Promise</a>
            
        </h1>
        <div class="content">
            <h2 id="index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><ol>
<li><a href="#1">Promise란?</a></li>
<li><a href="#2">Promise 사용법</a></li>
<li><a href="#3">Promise 상태</a></li>
<li><a href="#4">Promise.resolve, Promise.reject</a></li>
<li><a href="#5">Promise.prototype.then</a></li>
<li><a href="#6">Promise.all, Promise.race</a></li>
<li><a href="#7">Promise 특징</a></li>
</ol>
<hr>
<p><span id="1"></span></p>
<h2 id="promise란"><a href="#Promise란" class="headerlink" title="Promise란?"></a>Promise란?</h2><p>자바스크립트에서는 비동기 프로그래밍 해결을 위해 하나의 패턴으로 <a href="http://openwiki.kr/tech/callback" rel="external nofollow noopener noreferrer" target="_blank">콜백</a>을 사용했다. 그러나 콜백 패턴은 비동기 처리 중 발생한 오류를 예외 처리하기 힘들고 여러 개의 비동기 로직을 한꺼번에 처리하는 데도 한계가 있다. 즉 콜백 패턴은 그다지 유용한 패턴이 아니다. 이때 비동기 프로그래밍을 위한 또 다른 패턴으로 Promise가 등장했다.</p>
<p><strong><code>Promise</code></strong>는 <strong>비동기  처리 로직을 추상화한 객체와 그것을 조작하는 방식</strong>을 말한다. Promise를 지원하는 함수는 비동기 처리 로직을 추상화한 promise 객체를 반환 한다. 그리고 객체를 변수에 대입하고 성공 시 동작할 함수와 실패 시 동작할 함수 를 등록해 사용한다.</p>
<p>함수를 작성하는 방법은 promise 객체의 인터페이스에 의존 한다. 즉, promise 객체에서 제공하는 메서드만 사용해야 하므로 전통적인 콜백 패턴처럼 인자가 자유롭게 결정되는 게 아니라 같은 방식으로 통일된다. Promise 라고 부르는 하나의 인터페이스를 이용해 다양한 비동기 처리 문제를 해결할 수 있다. 복잡한 비동기 처리를 쉽게 패턴화할 수 있다는 뜻이다. 이것이 Promise의 역할이며 Promise를 사용하는 많은 이유 중 하나다.</p>
<hr>
<p><span id="2"></span></p>
<h2 id="promise-사용법"><a href="#Promise-사용법" class="headerlink" title="Promise 사용법"></a>Promise 사용법</h2><p>Promise는 new 연산자를 선언하여 Promise 인스턴스 객체를 생성한다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 비동기 처리 로직 후 resolve 또는 reject를 호출</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>new  연산자로 생성된 Promise 인스턴스 객체에는 성공(resolve), 실패(reject)했을 때 호출될 콜백 함수를 등록할 수 있는 Promise.then()이라고 하는 인스턴스 메서드가 있다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p>
<p>성공했을 때는 onFulfilled가 호출되고 실패했을 때는 onRejected가 호출된다. promise.then()으로 성공 혹은 실패 시의 동작을 동시에 등록할 수 있다. 만약 오류 처리만 한다면 promise.then(undefined, onRejected)와 같은 의미인 promise.catch(onRejected)를 사용하면 된다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.catch(onRejected)</span><br></pre></td></tr></table></figure></p>
<hr>
<p><span id="3"></span></p>
<h2 id="promise-상태"><a href="#Promise-상태" class="headerlink" title="Promise 상태"></a>Promise 상태</h2><p>생성자 함수를 new 연산하여 생성된 <strong>Promise 인스턴스 객체에는 3가지 상태가 존재</strong>한다. promise 객체는 Pending 상태로 시작해 Fulfilled나 Rejected 상태가 되면 다시는 변화하지 않는다. (Event 리스너와는 다르게 then()으로 등록된 콜백함수는 한 번만 호출된다.)</p>
<ul>
<li><strong>Pending</strong> : 성공도 실패도 아닌 상태, Promise 인스턴스 객체가 생성된 초기상태</li>
<li><strong>Fulfilled</strong> : 성공(resolve)했을 때의 상태, onFulfilled가 호출된다.</li>
<li><strong>Rejected</strong> : 실패(reject))했을 때의 상태, onRejected 호출된다.</li>
</ul>
<hr>
<p><span id="4"></span></p>
<h2 id="promiseresolve-promisereject"><a href="#Promise-resolve-Promise-reject" class="headerlink" title="Promise.resolve, Promise.reject"></a>Promise.resolve, Promise.reject</h2><p>Promise의 정적 메서드인 <strong><code>Promise.resolve()</code></strong>를 사용하면 new Promise() 구문을 단축해 표기할 수 있다. Promise.resolve()는 Fulfilled 상태인 promise 객체를 반환한다. 또한, Promise. resolve()는 <strong>thenable</strong> 객체를 promise 객체로 변환할 수 있다. 이것은 Promise.resolve()의 중요한 특징 중 하나다.</p>
<p>thenable은 ES6 Promises 사양에 정의된 개념이다. then()을 가진 객체 즉, 유사 promise 객체를 의미한다. length 프로퍼티를 갖고 있지만, 배열이 아닌 유사 배열 객체 Array-like Object와 같다. Promise.resolve()는 thenable 객체의 then() 이 Promise의 then()과 같은 동작을 할 것이라 기대하고 promise 객체로 변환한다.</p>
<p><strong><code>Promise.reject()</code></strong>도 promise 객체를 반환한다. 따라서 에러 객체와 함께 catch()를 이용해 등록한 콜백 함수가 호출된다.</p>
<hr>
<p><span id="5"></span></p>
<h2 id="promiseprototypethen"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h2><p>Promise에서는 <strong>메서드를 체인하여 코드를 작성할 수 있다.</strong> then()은 콜백 함수를 동록하기만 하는것이 아니라 콜백에서 반환된 값을 기준으로 새로운 promise 객체를 생성하여 전달하는 기능도 갖고 있다.</p>
<hr>
<p><span id="6"></span></p>
<h2 id="promiseall-promiserace"><a href="#Promise-all-Promise-race" class="headerlink" title="Promise.all, Promise.race"></a>Promise.all, Promise.race</h2><p><strong><code>Promise.all()</code></strong>은 Promise 객체를 배열로 전달받고 객체의 상태가 모두 Fulfilled 됐을 때 then()으로 등록한 함수를 호출한다.<br><strong><code>Promise.race()</code></strong>는 Promise.all()과 마찬가지로 promise 객체를 배열로 전달한다. Promise.all()과 달리 전달한 객체의 상태가 모두 Fulfilled가 될 때까지 기다리지 않고 전달한 객체 중 하나만 완료(Fulfilled, Rejected)되어도 다음 동작으로 넘어간다. Promise.race는 먼저 완료된 promise 객체가 있더라도 다른 promise 객체를 취소하지 않는다. (ES6 Promise 사양에는 취소라는 개념이 없다.)</p>
<hr>
<p><span id="7"></span></p>
<h2 id="promise-특징"><a href="#Promise-특징" class="headerlink" title="Promise 특징"></a>Promise 특징</h2><h4 id="1-promise는-항상-비동기로-처리된다"><a href="#1-Promise는-항상-비동기로-처리된다" class="headerlink" title="1. Promise는 항상 비동기로 처리된다."></a>1. Promise는 항상 비동기로 처리된다.</h4><p>Promise.resolve()나 resolve()를 사용하면 promise 객체는 바로 Fulfilled 상태가 되기 때문에 then()으로 등록한 콜백 함수가 동기적으로 호출될 것이라 생각할 수 있다. 하지만 실제로는 then()으로 등록한 <strong>콜백 함수는 비동기적으로 호출</strong>된다.<br>동기적으로 처리 가능한 상황에서도 비동기적으로 처리하는 이유는 동기와 비동기가 혼재될때 발생하는 문제를 막기 위함이다.</p>
<h4 id="2-새로운-promise-객체를-반환하는-then"><a href="#2-새로운-promise-객체를-반환하는-then" class="headerlink" title="2. 새로운 promise 객체를 반환하는 then"></a>2. 새로운 promise 객체를 반환하는 then</h4><p>promise.then(), catch()는 최초의 promise 객체에 메서드를 체인하는 것처럼 보이지만 실제로는 then()과 catch()는 <strong>새로운 promise 객체를 생성해 반환</strong>한다.<br>Promise.all()과 Promise.race() 또한 새로운 promise 객체를 생성해 반환한다.</p>
<h4 id="3-콜백-헬과-무관한-promise"><a href="#3-콜백-헬과-무관한-Promise" class="headerlink" title="3. 콜백-헬과 무관한 Promise"></a>3. 콜백-헬과 무관한 Promise</h4><p>Promise는 callback-hell 을 해결할수는 없고 완화할 수 있을 뿐이다. 완화할 수 있는 이유는 <strong>단일 인터페이스와 명확한 비동기 시점 표현, 강력한 에러 처리 메커니즘</strong> 때문이다. 이는 비동기 처리 자체를 손쉽게 다룰 수 있도록 하는 것이므로 callback-hell 을 해결하는 방법으로 여기는건 바람직하지 않다.</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-06-05T15:00:00.000Z">2017-06-06</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    20분 읽기 (대략 2995 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/06/06/JavaScript/client-side-rendering-vs-server-side-rendering/">[번역] Client-side rendering VS. Server-sde rendering</a>
            
        </h1>
        <div class="content">
            <h2 id="index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><ol>
<li><a href="#1">성능(Performance)</a></li>
<li><a href="#2">검색 엔진 최적화(SEO)</a></li>
<li><a href="#3">사전 렌더링(Prerendering)</a></li>
<li><a href="#4">더 똑똑해진 크롤러</a></li>
<li><a href="#5">덜 똑똑한 크롤러</a></li>
<li><a href="#6">두 세계의 장점</a></li>
<li><a href="#7">토론</a></li>
</ol>
<hr>
<blockquote>
<p>해당 포스팅은 <a href="https://medium.com/@adamzerner/client-side-rendering-vs-server-side-rendering-a32d2cf3bfcc" rel="external nofollow noopener noreferrer" target="_blank">Adam Zerner - Client-side rendering vs. server-side rendering</a>의 글을 번역하였습니다.</p>
</blockquote>
<p>초기에, 웹 프레임워크들은 서버(Server)에서 렌더링된 뷰를 갖고있었습니다. 현재는 클라이언트(Client)에서도 렌더링된 뷰를 가집니다. 지금부터 각각의 장점과 단점에 대해 알아보겠습니다.</p>
<p><span id="1"></span></p>
<h2 id="성능performance"><a href="#성능-Performance" class="headerlink" title="성능(Performance)"></a>성능(Performance)</h2><p><strong><code>서버 측(Server-side)에서 렌더링</code></strong>을 할 경우, 새로운 웹 페이지를 보고 싶을 때마다 다음과 같이 새로운 페이지 요청이 필요합니다.</p>
<p><img src="/images/post/2017-06-06/server_side_rendering_1.png" alt="서버 측 렌더링 작동 방식 다이어그램"></p>
<p>이것은 먹고 싶은 것이 있을 때마다 슈퍼마켓에 가는것과 비슷합니다. </p>
<p>그러나 <strong><code>클라이언트 측(Client-side) 렌더링</code></strong>을 사용할 경우, 슈퍼마켓에 한 번 방문하고 좀 더 시간을 들여 꽤 오랜 기간동안 먹을 음식을 구매합니다. 그런 다음, 먹고 싶은 것이 있을 때마다 슈퍼마켓에 가지 않고 냉장고에서 찾게됩니다.</p>
<p><img src="/images/post/2017-06-06/client_side_rendering_1.png" alt="클라이언트 측 렌더링 작동 방식 다이어그램"></p>
<p>각 접근법에서는 성능면에서 장점과 단점이 있습니다.</p>
<ul>
<li><strong>클라이언트 측 렌더링</strong>을 사용하면 초기 페이지로드가 느려집니다. 네트워크를 통한 통신이 느리므로 사용자에게 콘텐츠를 표시하기 전에 서버를 두 번 왕복해야합니다. 그러나 그 후에는 이후의 모든 페이지로드가 엄청나게 빠릅니다.</li>
<li><strong>서버 쪽 렌더링</strong>을 사용하면 초기 페이지로드가 크게 느려지지 않습니다. 그렇다고 크게 빠르지는 않을 것입니다. 그리고 이후의 다른 요청도 마찬가지입니다.</li>
</ul>
<p>보다 구체적으로 말하자면, <strong>클라이언트 측 렌더링</strong>을 사용하면 <strong>초기 페이지</strong>는 다음과 같이 보입니다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"client-side-framework.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>app.js</strong>는 JavaScript의 모든 HTML 페이지를 다음과 같이 문자열로 유지합니다.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pages = &#123;</span><br><span class="line">  <span class="string">'/'</span>: <span class="string">'&lt;html&gt; ... &lt;/html&gt;'</span>,</span><br><span class="line">  <span class="string">'/foo'</span>: <span class="string">'&lt;html&gt; ... &lt;/html&gt;'</span>,</span><br><span class="line">  <span class="string">'/bar'</span>: <span class="string">'&lt;html&gt; ... &lt;/html&gt;'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>그런 다음 페이지가 로드되면 프레임워크는 URL 표시줄을 보고 [ ‘/‘] 페이지에서 문자열을 가져 와서 <code>div class = &quot;container&quot;&gt; &lt;/ div&gt;</code>에 삽입합니다. 또한 링크를 클릭하면 프레임워크가 이벤트를 가로 채고 컨테이너에 새 문자열 (예 : 페이지 [ ‘/ foo’])을 삽입하고 브라우저가 정상적으로하는 것처럼 HTTP 요청을 실행하지 못하게 합니다.</p>
<hr>
<p><span id="2"></span></p>
<h2 id="검색-엔진-최적화seo"><a href="#검색-엔진-최적화-SEO" class="headerlink" title="검색 엔진 최적화(SEO)"></a>검색 엔진 최적화(SEO)</h2><div class="video-container"><iframe src="//www.youtube.com/embed/BNHR6IQJGZs" frameborder="0" allowfullscreen></iframe></div>
<p><strong>웹 크롤러</strong>가 <em>reddit.com</em> 을 요청하기 시작했다고 가정해봅시다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line">request.get(<span class="string">'reddit.com'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body looks something like this:</span></span><br><span class="line">  <span class="comment">// &lt;html&gt;</span></span><br><span class="line">  <span class="comment">//   &lt;head&gt; ... &lt;/head&gt;</span></span><br><span class="line">  <span class="comment">//   &lt;body&gt;</span></span><br><span class="line">  <span class="comment">//     &lt;a href="espn.com"&gt;ESPN&lt;/a&gt;</span></span><br><span class="line">  <span class="comment">//     &lt;a href="news.ycombinator.com"&gt;Hacker News&lt;/a&gt;</span></span><br><span class="line">  <span class="comment">//     ... other &lt;a&gt; tags ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>그러면 크롤러는 응답 본문에있는 <code>&lt;a href&gt;</code> 항목을 사용해서 새 요청을 생성합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line">request.get(<span class="string">'reddit.com'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body looks something like this:</span></span><br><span class="line">  <span class="comment">// &lt;html&gt;</span></span><br><span class="line">  <span class="comment">//   &lt;head&gt; ... &lt;/head&gt;</span></span><br><span class="line">  <span class="comment">//   &lt;body&gt;</span></span><br><span class="line">  <span class="comment">//     &lt;a href="espn.com"&gt;ESPN&lt;/a&gt;</span></span><br><span class="line">  <span class="comment">//     &lt;a href="news.ycombinator.com"&gt;Hacker News&lt;/a&gt;</span></span><br><span class="line">  <span class="comment">//     ... other &lt;a&gt; tags ...</span></span><br><span class="line">  </span><br><span class="line">  request.get(<span class="string">'espn.com'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;);</span><br><span class="line">  request.get(<span class="string">'news.ycombinator.com'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>그 후 크롤러는 <em>espn.com</em> 및 <em>news.ycombinator.com</em>의 링크를 사용하여 크롤링을 계속함으로써 프로세스를 계속 진행합니다.</p>
<p>결국 다음과 같은 재귀 코드처럼 동작합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crawlUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  request.get(url, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> linkUrls = getLinkUrls(body);</span><br><span class="line">    linkUrls.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">linkUrl</span>) </span>&#123;</span><br><span class="line">      crawlUrl(linkUrl);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">crawlUrl(<span class="string">'reddit.com'</span>);</span><br></pre></td></tr></table></figure>
<p>그렇다면 만약 요청에 의한 응답이 다음과 같은경우는 어떻게 될까요?</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"client-side-framework.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 <code>&lt;a href&gt;</code> 태그가 없습니다. 또한 웹 페이지의 내용이 없기 때문에 검색 결과를 표시 할 때 우선순위를 지정하지 않을 것입니다.</p>
<p>크롤러는 거의 알지 못하지만, 클라이언트 측 프레임워크는 멋진 콘텐츠로 <code>&lt;div class = &quot;container&quot;&gt; &lt;/div&gt;&quot;</code>를 채우려합니다.</p>
<p>이러한 이유가 클라이언트 측 렌더링이 SEO에 좋지 않은 이유입니다.</p>
<hr>
<p><span id="3"></span></p>
<h2 id="사전-렌더링prerendering"><a href="#사전-렌더링-Prerendering" class="headerlink" title="사전 렌더링(Prerendering)"></a>사전 렌더링(Prerendering)</h2><p>2009년에 Google은 이 문제를 해결할 수 있는 <a href="https://webmasters.googleblog.com/2009/10/proposal-for-making-ajax-crawlable.html" rel="external nofollow noopener noreferrer" target="_blank">방법</a>을 소개했습니다.</p>
<p><img src="/images/post/2017-06-06/prerendering.png" alt=""></p>
<p>크롤러가 <code>www.example.com/page?query#!mystate</code> 를 방문하면 <code>www.example.com/page?query&amp;_escaped_fragment_=mystate</code> 로 변환됩니다. 이렇게하면 서버가 <code>_escaped_fragment_</code>를 사용하여 요청을 받으면 사람이 아닌 크롤러에서 요청을 받는다는 것을 알 수 있습니다.</p>
<p>그렇기때문에 요청이 크롤러에서 온 경우 <code>&lt;div class = &quot;container&quot;&gt; ... &lt;/ div&gt;</code>를 제공할 수 있습니다.<br>일반적인 요청 인 경우 <code>&lt;div class = &quot;container&quot;&gt; &lt;/ div&gt;</code>를 제공하고 JavaScript가 내용을 내부에 삽입하도록 할 수 있습니다.</p>
<p>그러나 문제가 있습니다. 서버가 <code>&lt;div class = &quot;container&quot;&gt; &lt;/ div&gt;</code>안에 무엇이 들어가는지 알지 못하기 때문입니다. 내부에 무엇이 들어가는지 파악하려면 JavaScript를 실행하고 DOM을 만들고 DOM을 조작해야합니다. 전통적인 웹 서버는 이를 수행하는 방법을 모르기 때문에 <strong>Headless Browser</strong>로 알려진 서비스를 사용합니다.</p>
<p><img src="/images/post/2017-06-06/headless_browser.png" alt=""></p>
<hr>
<p><span id="4"></span></p>
<h2 id="더-똑똑해진-크롤러"><a href="#더-똑똑해진-크롤러" class="headerlink" title="더 똑똑해진 크롤러"></a>더 똑똑해진 크롤러</h2><p>6년 후, Google은 크롤러가 한층 더 똑똑해 졌다고 발표했습니다. <strong>Crawler 2.0</strong>에서 <code>&lt;script&gt;</code> 태그를 볼 때 웹 브라우저처럼 실제로 요청을하고 코드를 실행하고 DOM을 조작한다는 것입니다.</p>
<p>그래서 다음과 같은 코드가<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>이제는 이렇게 보이는 것입니다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://support.google.com/webmasters/answer/6066468?hl=en" rel="external nofollow noopener noreferrer" target="_blank">Fetch as Google</a>를 사용하여 Google 크롤러가 특정 URL을 방문했을 때 어떤 내용을 볼지 결정할 수 있습니다.</p>
<p>관련된 발표문의 내용 일부를 첨부합니다.</p>
<blockquote>
<p>당시 우리 시스템은 자바 스크립트를 사용하여 사용자에게 콘텐츠를 제공하는 페이지를 렌더링하고 이해할 수 없었습니다. <a href="https://developers.google.com/webmasters/ajax-crawling/docs/learn-more" rel="external nofollow noopener noreferrer" target="_blank">크롤러는 동적으로 생성 된 콘텐츠를 볼 수 없었기 때문에</a> 웹 마스터가 AJAX 기반 애플리케이션을 검색 엔진으로 인덱싱 할 수 있도록 일련의 방법을 제안했습니다.<br><br>시대가 바뀌 었습니다. 현재 Googlebot이 자바 스크립트 또는 CSS 파일을 크롤링하는 것을 차단하지 않는 한 일반적으로 최신 브라우저와 같이 웹 페이지를 렌더링하고 이해할 수 있습니다.</p>
</blockquote>
<hr>
<p><span id="5"></span></p>
<h2 id="덜-똑똑한-크롤러"><a href="#덜-똑똑한-크롤러" class="headerlink" title="덜 똑똑한 크롤러"></a>덜 똑똑한 크롤러</h2><p>불행히도 Google 만이 유일한 검색 엔진이 아닙니다. Bing, Yahho, Duck Duck Go, Baidu 등도 있으며 실제로 사람들은 이러한 검색 엔진도 빈번하게 사용합니다.</p>
<p><img src="/images/post/2017-06-06/search_engine.png" alt=""></p>
<p>다른 검색 엔진은 JavaScript를 잘 처리하지 못합니다. 다음 글을 참고해보세요. <a href="https://medium.freecodecamp.com/seo-vs-react-is-it-neccessary-to-render-react-pages-in-the-backend-74ce5015c0c9" rel="external nofollow noopener noreferrer" target="_blank">SEO vs. React: Web Crawlers are Smarter Than You Think</a></p>
<hr>
<p><span id="6"></span></p>
<h2 id="두-세계의-장점"><a href="#두-세계의-장점" class="headerlink" title="두 세계의 장점"></a>두 세계의 장점</h2><p>두 세계(서버 측 렌더링, 클라이언트 측 렌더링)의 장점을 최대한 활용하려면 다음의 방법이 있습니다.</p>
<ol>
<li>첫 번째 페이지 로드에는 서버 측 렌더링을 사용.</li>
<li>그 후 모든 후속 페이지 로드에는 클라이언트 측 렌더링을 사용.</li>
</ol>
<p><img src="/images/post/2017-06-06/both_worlds.png" alt=""></p>
<p>이것이 의미하는 바를 생각해보세요.</p>
<ul>
<li>첫 번째 페이지 로드의 경우 사용자가 콘텐츠를 보기 전에 두 번 왕복하지 않습니다.</li>
<li>후속 페이지 로드가 빨라집니다.</li>
<li>크롤러는 간단한 HTML을 얻습니다. 옛날처럼 JavaScript를 실행하거나 _escaped<em>fragment</em>를 처리할 필요가 없습니다.</li>
</ul>
<p>그러나 이를 위한 설정을 하기위해서는 서버에서 약간의 작업이 필요합니다. Angular, React 및 Ember 모두 이 접근 방식으로 변경했습니다.</p>
<hr>
<p><span id="7"></span></p>
<h2 id="토론"><a href="#토론" class="headerlink" title="토론"></a>토론</h2><p>먼저 고려해야 할 몇 가지 사항은 다음과 같습니다.</p>
<ul>
<li>약 2%의 사용자가 JavaScript를 사용할 수 없게 설정되어 있는 경우 클라이언트 측 렌더링이 전혀 작동하지 않습니다.</li>
<li>웹 검색의 약 1/4은 Google 이외의 엔진으로 수행됩니다.</li>
<li>모두가 빠른 인터넷 연결을 사용하는 것은 아닙니다.</li>
<li>휴대 전화 사용자는 대개 빠른 인터넷 연결이 필요하지 않습니다.</li>
<li><a href="https://www.nngroup.com/articles/too-fast-ux/" rel="external nofollow noopener noreferrer" target="_blank">너무 빠른 UI는 혼란 스러울 수 있습니다.</a> 사용자가 링크를 클릭한다고 가정 해보세요. 앱에서 새로운 뷰로 이동합니다. 그러나 새로운 뷰는 이전의 뷰와 미묘하게 다릅니다. 그리고 변경 사항은 즉시 발생했습니다 (클라이언트 측 렌더링의 장점). 새로운 뷰가 실제로 로드 된 것을 사용자가 알지 못할 수도 있습니다. 또는 사용자가 주의를 기울 였지만 상대적으로 미묘하기 때문에 사용자는 전환이 실제로 발생했는지 여부를 감지하기 위해 약간의 노력을 기울여야합니다. 때로는 약간의 로딩 스피너와 전체 페이지 재 렌더링을 하는 것이 좋습니다.</li>
<li>캐싱이 중요합니다. 따라서 서버 측 렌더링을 사용하면 실제로 사용자가 실제로 모든 것을 서버로 가져갈 필요가 없습니다. 때로는 바다 건너편의 “공식”서버가 아닌 근처의 서버에 가면됩니다.</li>
<li>실제로 성과와 관련하여 때로는 중요하지 않습니다. 때로는 속도가 좋고 속도가 약간 올라가더라도 삶이 더 좋아지지는 않습니다.</li>
</ul>
<p>대부분의 사용자는 인터넷 연결 상태가 좋으며 충분히 빠릅니다. 특히 Macbook Pro로 yuppies를 타겟팅하는 경우. 초기로드 시간이 너무 길어서 사용자를 잃을 염려가 없습니다. 사용자가 링크를 클릭 할 때 실제로 새 페이지가 로드된다는 사실을 사용자가 알지 못하는 사용성 문제에 대해 걱정할 필요가 없습니다.</p>
<p>그러나 초기 페이지 로드시 서버 측 렌더링을 사용하는 클라이언트 측 렌더링을위한 사용 사례는 확실합니다. 큰 회사의 경우 #perfMatters, 인터넷 연결 속도가 느린 사용자가 있고 최적화에 충분한 시간을 할애 할 수있는 충분한 엔지니어링 팀이있는 경우가 종종 있습니다.</p>
<p>앞으로 이 같은 형태의 웹 프레임 워크 (초기 페이지 로드시 서버 쪽 렌더링을 사용하고 후에는 클라이언트 측 렌더링을 수행)가 보다 안정되고 사용하기 쉬워지기를 기대합니다. 이 시점에서 추가 된 복잡성은 최소화 될 것입니다. 그러나 오늘날,이 모든 것은 매우 새롭고, 많은 추상화가있을 것으로 기대합니다. 앞으로 더 나아가 클라이언트 측 렌더링이 필요하지 않은 곳에 인터넷 연결이 충분해지기 때문에 추세가 다시 서버 측 렌더링으로 되돌아 갈 것으로 예상됩니다.</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-03-13T15:15:30.000Z">2017-03-14</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    16분 읽기 (대략 2418 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/03/14/JavaScript/understand-prototype/">Prototype 이제는 이해하자</a>
            
        </h1>
        <div class="content">
            <h2 id="index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><ol>
<li><a href="#1">prototype은 왜 어려울까?</a></li>
<li><a href="#2">객체(object)는 함수(function)로부터 시작된다</a></li>
<li><a href="#3">함수(function) 생성시 발생하는 일</a></li>
<li><a href="#4">객체(object) 생성시 발생하는 일</a></li>
<li><a href="#5">프로토타입 체인(Prototype Chain)</a></li>
<li><a href="#6">번외</a></li>
</ol>
<hr>
<p><span id="1"></span></p>
<h2 id="prototype은-왜-어려울까"><a href="#prototype은-왜-어려울까" class="headerlink" title="prototype은 왜 어려울까?"></a>prototype은 왜 어려울까?</h2><p>C++, Java와 같은 <code>클래스</code> 기반 객체지향 언어와 달리 자바스크립트는 <code>프로토타입</code> 기반 객체지향 언어입니다. 프로토타입을 사용하여 객체지향을 추구하기 때문에 자바스크립트를 사용함에 있어 프로토타입을 이해하는 것은 중요합니다. 최근 ECMA6 표준에서 <code>Class</code> 문법이 추가되었지만 C++, Java에서 말하는 클래스가 아닌 <code>프로토타입</code>을 기반으로 하여 만들어진 문법입니다.</p>
<p>자바스크립트의 프로토타입을 처음 공부하면서 <strong>prototype, [[prototype]], __proto__, 객체, 함수, prototype chain</strong> 과 같은 용어들을 접하게 되는데 공부할수록 서로 뒤엉켜지고, 모르는 것도 아닌 그렇다고 제대로 알고 있는것도 아닌 어중간한 상태가 됩니다.</p>
<p>자바스크립트를 사용한 경험이 있으시다면 아래의 코드와 같은 형태를 경험한적이 있으실겁니다. 지금부터 아래의 코드가 어떤 원리로 동작하게 되는지 알아보겠습니다.</p>
<p><img src="/images/post/2017-03-14/prototype_example_1.png" alt="prototype에 property 추가"></p>
<p>먼저 프로토타입에 대해 이해하기 위해서는 <code>객체(object)는 함수(function)로부터 시작된다</code>라는 것을 알아야 합니다. 이는 prototype을 이해하는데 많은 도움을 줍니다.</p>
<hr>
<p><span id="2"></span></p>
<h2 id="객체object는-함수function로부터-시작된다"><a href="#객체-object-는-함수-function-로부터-시작된다" class="headerlink" title=" 객체(object)는 함수(function)로부터 시작된다"></a><span style="color:red"> 객체(object)는 함수(function)로부터 시작된다</span></h2><p><strong>자바스크립트에서 <a href="https://developer.mozilla.org/ko/docs/Glossary/Primitive" rel="external nofollow noopener noreferrer" target="_blank">primitive</a>를 제외하고는 모두 객체(object)입니다.</strong><br> <strong>앞으로 등장하는 Object와 Function은 function(즉, 생성자)입니다. object는 객체를 의미합니다.</strong></p>
<p>다음의 코드를 분석하기 전 <code>객체(object)는 함수(function)로부터 시작된다</code>라는걸 다시한번 기억하겠습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Book</span>(<span class="params"></span>) </span>&#123; &#125;                <span class="comment">// 함수</span></span><br><span class="line"><span class="keyword">var</span> jsBook = <span class="keyword">new</span> Book();           <span class="comment">// 객체 생성</span></span><br></pre></td></tr></table></figure></p>
<p>위의 코드에서 <strong>Book이라는 함수를 통해서 jsBook이라는 객체</strong>를 생성했습니다. 이때 Book 함수를 <code>생성자</code>라고 합니다. 생성자는 새로 생성된 객체를 초기화하는 역할을 합니다. 코어 자바스크립트는 기본 타입에 대한 생성자를 내장하고 있는데 이는 다음 코드를 통해 확인이 가능합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cssBook = &#123;&#125;;                  <span class="comment">// 생성자 선언 없이 객체 생성</span></span><br></pre></td></tr></table></figure></p>
<p>위에서는 리터럴 방식을 사용하여 객체를 생성하였습니다. 리터럴 방식 또한 결과적으로는 함수를 통하여 객체를 생성하게 됩니다. <strong>자바스크립트 엔진</strong>이 해당 리터럴을 다음과 같이 해석합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cssBook = <span class="keyword">new</span> <span class="built_in">Object</span>();        <span class="comment">// 객체 생성</span></span><br></pre></td></tr></table></figure></p>
<p>따라서 결과적으로는 리터럴 방식으로 객체를 생성할때도 Object라는 함수(생성자)를 통해서 객체를 생성하게 됩니다. <strong>Object 뿐만 아니라 Array, Function, Date, RegExp 모두 함수입니다.</strong></p>
<p><img src="/images/post/2017-03-14/various_function.png" alt="Object, Array, Function, Date, RegExp - 모두 함수(function)이다"></p>
<p>배열도 객체이기 때문에(자바스크립트 배열은 객체의 특별한 형태입니다. 프로퍼티 이름이 정수로 사용되며, length 프로퍼티를 가집니다.) 객체를 생성할때와 마찬가지로 배열(객체)의 생성에도 함수가 관여하게 됩니다. 따라서 무심코 사용했던 배열의 리터럴 표현도 결국에는 자바스크립트 엔진이 다음과 같이 해석합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> books = [<span class="string">'html'</span>, <span class="string">'css'</span>, <span class="string">'js'</span>];                  <span class="comment">// 배열(객체) 생성</span></span><br><span class="line"><span class="comment">// 엔진이 다음과 같이 해석합니다.</span></span><br><span class="line"><span class="keyword">var</span> books = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'html'</span>, <span class="string">'css'</span>, <span class="string">'js'</span>);         <span class="comment">// 배열(객체) 생성</span></span><br></pre></td></tr></table></figure></p>
<p>이제 <code>객체(object)는 함수(function)로부터 시작된다</code>라는 것을 알 수 있습니다.</p>
<hr>
<p><span id="3"></span></p>
<h2 id="함수function-생성시-발생하는-일"><a href="#함수-function-생성시-발생하는-일" class="headerlink" title=" 함수(function) 생성시 발생하는 일"></a><span style="color:red"> 함수(function) 생성시 발생하는 일</span></h2><p>객체(object)는 함수(function)로부터 시작되기 때문에 사용자가 객체를 생성하기 위해 먼저 함수를 정의하게 됩니다. 이때 <strong>발생하는 일</strong>에 대해 알아보겠습니다. 여기서는 2가지를 기억해야 합니다.</p>
<p>1.<strong>함수를 정의하면 함수가 생성되며 <code>Prototype object</code>가 같이 생성 됩니다. 생성된 Prototype object는 함수의 <code>prototype</code> 속성을 통해 접근할 수 있습니다.</strong> (Prototype object같은 경우 함수 생성시에만 됩니다. 일반 객체 생성시에는 생성되지 않습니다.)</p>
<p><img src="/images/post/2017-03-14/function_property.png" alt="함수 prototype property"></p>
<p>2.함수의 생성과 함께 생성된 <code>Prototype object</code>는 <code>constructor</code>와 <code>__proto__</code>를 갖고 있습니다. (cover property를 추가한것 처럼 사용자 임의로 추가 가능합니다.) <strong>constructor</strong>는 생성된 함수를 가리키며(여기서는 function Book을 가리킵니다.) <strong>__proto__</strong>는 <code>Prototype Link</code>로서 <strong>객체가 생성될 때 사용된 생성자(함수)의 Prototype object를 가리킵니다.</strong> Prototype Link는 뒤에서 자세하게 알아보겠습니다.</p>
<p><img src="/images/post/2017-03-14/prototype_object.png" alt="함수와 함께 생성된 Prototype object"></p>
<p>다이어그램을 통해 확인하면 다음과 같습니다.</p>
<p><img src="/images/post/2017-03-14/make_function_diagram.png" alt="함수와 Prototype object의 관계"></p>
<hr>
<p><span id="4"></span></p>
<h2 id="객체object-생성시-발생하는-일"><a href="#객체-object-생성시-발생하는-일" class="headerlink" title=" 객체(object) 생성시 발생하는 일"></a><span style="color:red"> 객체(object) 생성시 발생하는 일</span></h2><p>이번에는 객체 생성시 발생하는 일에 대해 알아보겠습니다. 조금 전에 정의한 Book 함수(생성자)를 사용하여 jsBook이라는 객체를 생성해 보겠습니다.</p>
<p><img src="/images/post/2017-03-14/make_object.png" alt="Book 함수로 생성한 객체"></p>
<p>생성자(함수)의 몸체 부분에 어떠한 코드도 작성하지 않았는데 이를 통해 생성한 jsBook 객체가 <code>__proto__</code>라는 프로퍼티를 갖고있습니다.</p>
<p>여기서 <strong>__proto__</strong> 는 <code>Prototype Link</code>로서 <strong>객체의 생성에 쓰인 생성자 함수의 <code>Prototype object</code></strong>를 가리키고 있습니다. 그렇기 때문에 Book 생성자 함수와 함께 생성된 Prototype object에 추가한 cover라는 프로퍼티가 보이는것을 확인할 수 있습니다.</p>
<p>조금 더 이해하기 쉽게 다이어그램으로 확인하면 다음과 같습니다.</p>
<p><img src="/images/post/2017-03-14/make_object_diagram.png" alt="함수, Prototype object, 객체의 관계"></p>
<p>다이어그램에서도 확인할 수 있다시피 <code>prototype</code> property(함수 생성시 함께 생성된 Prototype object를 가리킴)는 함수객체만 가지며 <code>__proto__</code>는 객체라면 모두 갖고 있습니다.</p>
<p>이제 프로토타입 체인(Prototype Chain)에 대해 이해할 수 있는 준비가 되었습니다.</p>
<hr>
<p><span id="5"></span></p>
<h2 id="프로토타입-체인prototype-chain"><a href="#프로토타입-체인-Prototype-Chain" class="headerlink" title=" 프로토타입 체인(Prototype Chain)"></a><span style="color:red"> 프로토타입 체인(Prototype Chain)</span></h2><p>결론부터 말씀드리면 <code>프로토타입 체인</code>은 객체의 property를 사용할때 해당 property가 없다면, <code>__proto__</code> property를 이용해 자신의 생성에 관여한 함수(생성자 함수)의 <code>Prototype object</code>에서 property를 찾습니다. 만약 Prototype object에도 해당 property가 없다면 다시 Prototype object의 <strong>__proto__</strong> property를 이용해 Prototype object에서 property를 찾습니다. 이렇게 계속 반복이 이루어지며 해당 property를 찾게 된다면 <strong>값을 반환</strong>하고 찾지 못한다면 <strong>undefined</strong>를 반환합니다. 이렇게 <strong><code>__proto__</code> property를 통해 상위 프로토타입과 연결되어 있는 형태를 프로토타입 체인(Chain)이라고 합니다.</strong></p>
<p>프로토타입 체인에 대해 알게되었으니 다시한번 처음 코드를 살펴보겠습니다.</p>
<p><img src="/images/post/2017-03-14/prototype_example_1.png" alt="프로토타입 체인 예제"></p>
<p>이제 어떻게 jsBook에 cover라는 property를 추가하지 않았는데도 결과가 출력되는지 이해할 수 있습니다. 다음과 같이 동작할 것입니다.</p>
<p><img src="/images/post/2017-03-14/prototype_diagram_1.png" alt="프로토타입 체인 예제(cover property 찾는 과정)"></p>
<p>또한 다음과 같이 <strong>프로토타입 체인의 최상위는 Object이기 때문에 Object.prototype의 property들을 모두 사용할 수 있습니다.</strong> 자주 사용하는 toString()과 valueOf() 모두 Object.prototype에 선언되어 있습니다.<br>(Book Prototype object는 <strong>객체</strong>이기 때문에 Object 생성자가 사용될 것입니다. 따라서 Book Prototype object의 <strong>__proto__</strong>는 Object Prototype object를 가리키게 됩니다.)</p>
<p><img src="/images/post/2017-03-14/prototype_diagram_2.png" alt="프로토타입 체인의 최상위 object"><br><img src="/images/post/2017-03-14/Object_prototype.png" alt="Object.prototype"></p>
<p><code>Prototype object</code>와 <code>__proto__</code> 그리고 <code>프로토타입 체인</code>에 대해 이해하였으니 다음과 같은 코드도 이해할 수 있습니다. 잘 이해가 되지 않는다면 위의 다이어그램을 참고해보시기 바랍니다.</p>
<p><img src="/images/post/2017-03-14/prototype_chain_test.png" alt="__proto__와 Prototype object의 관계"></p>
<hr>
<p><span id="6"></span></p>
<h2 id="번외"><a href="#번외" class="headerlink" title="번외"></a>번외</h2><p><img src="/images/post/2017-03-14/prototype_diagram_2_check.png" alt="프로토타입 체인의 최상위 object"><br>혹시 다이어그램을 보면서 function Book의 <strong>__proto__</strong> 는 무엇을 가리키고 있는지 궁금해 하셨을 분들을 위해 추적해보았습니다.</p>
<p><img src="/images/post/2017-03-14/function_proto.png" alt="function(생성자)의 __proto__ 추적"></p>
<p>다음 코드를 도식화 하면 다음과 같은 다이어그램이 나오게 됩니다.</p>
<p><img src="/images/post/2017-03-14/function_proto_diagram.png" alt="function(생성자)의 __proto__ 추적"></p>
<p>간단하게 포스팅을 하려했는데 주제가 주제인지라 길어졌습니다. 저도 프로토타입을 처음 공부하면서 어려움을 많이 겪었는데 조금이나마 도움이 되었으면 좋겠습니다.</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-29T17:10:32.000Z">2017-01-30</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    28분 읽기 (대략 4235 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/30/JavaScript/complete-guide-to-javascript-chapter-9/">자바스크립트 완벽가이드 9장 (클래스와 모듈)</a>
            
        </h1>
        <div class="content">
            <p><strong>자바스크립트에서 <code>클래스</code>는 프로토타입 기반의 상속 메커니즘을 기반으로 하고있다.</strong> 두 객체가 같은 프로토타입 객체로부터 프로퍼티를 상속받았다면, 둘은 같은 클래스의 인스턴스다. 자바스크립트의 클래스와 프로토타입 기반 상속 메커니즘은 자바나 그와 비슷한 언어의 클래스 상속과는 상당히 다르다. 자바스크립트 클래스의 중요한 특징 중 하나는 동적으로 확장될 수 있다는 것이다. 클래스를 정의한 다는 말은 모듈화되고 재사용 가능한 코드를 작성한다는 뜻이다.</p>
<h2 id="91-클래스와-프로토타입"><a href="#9-1-클래스와-프로토타입" class="headerlink" title="9.1 클래스와 프로토타입"></a>9.1 클래스와 프로토타입</h2><p>자바스크립트의 클래스는 같은 프로토타입 객체로부터 프로퍼티를 상속받은 객체의 집합이다. 따라서 프로토타입 객체는 클래스의 핵심이다.</p>
<hr>
<h2 id="92-클래스와-생성자"><a href="#9-2-클래스와-생성자" class="headerlink" title="9.2 클래스와 생성자"></a>9.2 <span style="color:red">클래스와 생성자</span></h2><p><strong><code>생성자</code>는 새로 생성된 객체를 초기화하는 용도로 사용되는 함수다.</strong> 생성자는 <code>new</code> 키워드를 사용하여 호출한다. 생성자를 호출하면 자동으로 새로운 객체가 생성되고, 생성자 함수 내부에서 새로 생성된 객체를 사용하기 때문에, 생성자 함수는 새 객체의 상태를 초기화하는 데만 신경 쓰면 된다. 생성자 호출의 핵심적인 특징은 <strong>생성자의 prototype 프로퍼티가 새 객체의 프로토타입으로 사용</strong>된다는 것이다. 이는 한 생성자를 통해 생성된 모든 객체는 같은 객체를 상속하고, 따라서 같은 클래스의 멤버임을 뜻한다.<br>클래스와 생성자 함수의 이름은 대문자로 시작하는 것은 매우 일반적은 코딩 규칙이다. 일반 함수와 메서드는 소문자로 이름을 시작한다.<br>새 객체는 생성자 함수가 실행되기 전에 자동으로 생성되고, 생성자 함수 내에서 this 값으로 접근할 수 있다. 생성자는 그저 새 객체를 초기화하기만 하면 되고 생성된 객체를 반환할 필요도 없다. 생성자를 호출하면 새 객체는 자동으로 생성되고, 새 객체의 메서드로서 생성자 함수가 호출된 다음, 초기화가 완료된 새 객체가 반환된다. 생성자 호출이 일반적인 함수 호출과 크게 다른것이 생성자 이름의 첫 글자를 대문자로 하는 또 하나의 이유다. 생성자는 <code>new</code> 키워드를 사용하여 호출된다고 가정하기 때문에, 일반적인 함수 호출처럼 호출하면 보통 제대로 작동하지 않는다.</p>
<h4 id="921-생성자와-클래스-구별"><a href="#9-2-1-생성자와-클래스-구별" class="headerlink" title="9.2.1 생성자와 클래스 구별"></a><span style="color:red">9.2.1 생성자와 클래스 구별</span></h4><p>프로토타입 객체는 클래스를 구별할 때 핵심적인 역할을 한다. 두 객체는 같은 프로토타입 객체를 상속한 경우에만 같은 클래스의 인스턴스다. 새로 생성된 객체의 상태를 초기화하는 생성자 함수는 클래스 구별의 핵심이 아니다. 서로 다른 두 생성자 함수라도 같은 프로토타입 객체를 가리키는 prototype 프로퍼티를 가질 수 있다. 그러면 두 생성자는 같은 클래스의 인스턴스를 만드는데 사용될 수 있다.<br>생성자가 prototype 만큼 객체 구별에 핵심적인 역할을 하지는 않더라도, 생성자는 클래스를 대표하는 역할을 한다. 생성자는 객체가 어떤 클래스에 속한 것인지 검사할 때 <code>instanceof</code> 연산자와 같이 사용된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r <span class="keyword">instanceof</span> Rnage            <span class="comment">// r이 Range.prototype을 상속했다면 true를 반환한다.</span></span><br></pre></td></tr></table></figure></p>
<p>instanceof 연산자는 실제로 r이 Range 생성자에 의해 초기화되었는지를 검사하지는 않고, r이 Range.prototype을 상속하는지를 검사한다.</p>
<h4 id="922-constructor-프로퍼티"><a href="#9-2-2-constructor-프로퍼티" class="headerlink" title="9.2.2 constructor 프로퍼티"></a><span style="color:red">9.2.2 constructor 프로퍼티</span></h4><p>모든 자바스크립트 함수는 생성자로 사용될 수 있는데, 함수가 생성자로 호출되려면 <code>prototype 프로퍼티</code>가 있어야 한다. 따라서 모든 자바스크립트 함수에는 자동으로 prototype 프로퍼티가 설정된다. 이 prototype 프로퍼티의 값은 <code>constructor</code> 프로퍼티 하나만 가진 객체다. constructor 프로퍼티는 열거되지 않으며 constructor 프로퍼티의 값은 해당 함수 객체다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;      <span class="comment">// 함수 객체다.</span></span><br><span class="line"><span class="keyword">var</span> p = F.prototype;        <span class="comment">// F와 연관이 있는 프로토타입 객체다.</span></span><br><span class="line"><span class="keyword">var</span> c = p.constructor;      <span class="comment">// 프로토타입과 관련한 함수 객체다.</span></span><br><span class="line">c === F                     <span class="comment">// =&gt; true: 모든 함수에 대해 F.prototype.constructor==F이다.</span></span><br></pre></td></tr></table></figure></p>
<p>미리 정의된 프로토타입 객체가 있고 이 프로토타입 객체가 constructor 프로퍼티를 갖고 있다는 말은, 일반적으로 어떤 객체가 자기 자신의 생성자를 가리키는 constructor 프로퍼티 또한 상속하고 있음을 뜻한다.<br>별도로 정의한 프로토타입 객체에는 <code>constructor</code> 프로퍼티가 없다. 따라서 해당 클래스의 인스턴스에도 constructor 프로퍼티는 없을 것이다. 이 문제는 명시적으로 프로토타입 객체에 constructor 프로퍼티를 추가함으로써 해결한다. 일반적인 또 다른 기법은 constructor 프로퍼티가 미리 정의되어 있는 prototype 객체를 사용하는 것이다. 거기에 하나씩 메서드를 추가해가면 된다.</p>
<hr>
<h2 id="93-자바-스타일-클래스"><a href="#9-3-자바-스타일-클래스" class="headerlink" title="9.3 자바 스타일 클래스"></a><span style="color:red">9.3 자바 스타일 클래스</span></h2><p>자바스크립트가 자바와 다른 점 한가지는 <strong>함수가 값</strong>이라는 점이고, 따라서 <strong>메서드와 필드 사이에는 뚜렷한 구분이 없다.</strong> 프로퍼티 값이 함수라면 그 프로퍼티는 메서드이고, 함수가 아니라면 보통의 프로퍼티나 ‘필드’일 뿐이다.<br>자바스크립트가 자바 스타일의 클래스 멤버를 흉내 낼 수 있지만, 자바의 중요한 특징 중 자바스크립트가 지원하지 않는 것이 몇 가지 있다. 먼저 자바는 인스턴스 메서드 안에서 인스턴스 필드를 메서드의 지역 변수처럼 사용할 수 있고, this를 비롯한 어떤 접두사도 붙일 필요가 없다. 자바스크립트는 이를 지원하지 않지만, <strong>with문</strong>을 사용하여 비슷한 효과를 얻을 수 있다.(권장X) 자바에서는 final을 사용하여 상수 필드를 정의할 수 있다. 그리고 클래스 내부에서만 사용하고 외부에서 볼 수 없는 필드나 메서드는 <code>private</code>으로 정의할 수 있다. 자바스크립트에는 이런 키워드들이 없다. 따라서 힌트를 제공하는 표기 규칙을 사용한다.(값이 변경되면 안 되는 프로퍼티들은 이름이 대문자이고, 밑줄로 시작하는 이름의 프로퍼티는 클래스 외부에서 사용하면 안된다는 뜻이다.)<br>private 프로퍼티는 클로저의 지역 변수로 흉내 낼 수 있고, 상수 프로퍼티는 ECMAScript 5에서는 사용 가능하다.</p>
<hr>
<h2 id="94-클래스-확장하기"><a href="#9-4-클래스-확장하기" class="headerlink" title="9.4 클래스 확장하기"></a>9.4 클래스 확장하기</h2><p>자바스크립트의 프로토타입 기반 상속 메커니즘은 <code>동적</code>이다. 객체는 자신의 프로토타입에서 프로퍼티를 상속받는데, 심지어 이는 객체가 생성된 이후에 프로토타입이 변경되더라도 마찬가지다. 다시말해 자바스크립트 객체의 프로토타입에 메서드를 추가함으로써 간단히 자바스크립트 클래스를 확장할 수 있다는 뜻이다.<br>Object.prototype에도 메서드를 추가할 수 있고, 그러면 모든 객체에서 추가된 메서드를 사용할 수 있지만 이 프로퍼티는 모든 for/in 루프에서 열거될 것이기 때문에 권장하지 않는다.<br>호스트 환경(웹브라우저 같은)에서 정의된 클래스를 이러한 방식으로 확장할 수 있는지는 호스트 환경의 구현체마다 다르다. 이 때문에 클라이언트 측 프로그래밍에서 이러한 기법의 사용은 몹시 제한받는다.</p>
<hr>
<h2 id="95-클래스와-자료형"><a href="#9-5-클래스와-자료형" class="headerlink" title="9.5 클래스와 자료형"></a>9.5 클래스와 자료형</h2><h4 id="951-instanceof-연산자"><a href="#9-5-1-instanceof-연산자" class="headerlink" title="9.5.1 instanceof 연산자"></a>9.5.1 instanceof 연산자</h4><p>왼쪽 피연산자는 클래스를 판별하려는 객체이며, 오른쪽 피연산자는 생성자 함수여야 하는데, 이 생성자 함수의 이름이 곧 해당 클래스의 이름이다. 표현식 <strong>o instanceof c</strong>는 만약 o가 c.prototype을 상속한다면 true다.(상속은 직접적일 필요없고, 만약 o가 c.prototype을 상속한 어떤 객체를 상속한다해도 이 표현식은 true이다.)<br>instanceof 연산자는 생성자 함수를 요구하지만, 실제로 instanceof 연산자는 객체가 어떤 프로토타입을 상속했는지를 검사하여 객체를 생성하는 데 어떤 생성자를 사용했는지 테스트하지는 않는다. 만약 생성자 함수를 검사의 기준으로 삼고 싶다면, <code>isPrototype()</code> 메서드를 대신 사용할 수 있다.</p>
<h4 id="952-constructor-프로퍼티"><a href="#9-5-2-constructor-프로퍼티" class="headerlink" title="9.5.2 constructor 프로퍼티"></a>9.5.2 constructor 프로퍼티</h4><p>어떤 객체의 클래스를 구별하는 또 다른 방법은 constructor 프로퍼티를 사용하는 것이다. constructor 프로퍼티를 사용하는 이 기법은 instanceof와 같은 문제가 있으며 자바스크립트 객체 가운데는 constructor 프로퍼티가 없는 것도 있을 수 있다.</p>
<hr>
<h2 id="96-자바스크립트의-객체-지향-기법"><a href="#9-6-자바스크립트의-객체-지향-기법" class="headerlink" title="9.6 자바스크립트의 객체 지향 기법"></a>9.6 자바스크립트의 객체 지향 기법</h2><h4 id="963-표준-변환-메서드"><a href="#9-6-3-표준-변환-메서드" class="headerlink" title="9.6.3 표준 변환 메서드"></a><span style="color:red">9.6.3 표준 변환 메서드</span></h4><p>객체 자료형을 변환하는 데 사용되는 중요한 메서드들이 있고, 이 중 몇 가지 형 변환이 푤아할 때 자바스크립트 인터프리터에 의해 자동으로 호출된다. 작성한 클래스에 변환 메서드를 구현하지 않았다면, 이는 단순히 술수로 구현하지 않은 것이 아니라 의도적인 것이어야 한다.<br>먼저, 가장 중요한 메서드는 <code>toString()</code>이다. 이 메서드의 <strong>목적은 객체의 문자열 표현을 반환하는 것</strong>이다. 자바스크립트는 필요할 때 자동으로 이 메서드를 호출한다. 프로퍼티 이름 같이 문자열을 요구하는 곳에 객체를 사용했을 때 또는 문자열 결합을 위해 + 연산자를 사용했을 때 toString() 메서드가 호출된다. 만약 이 메서드를 구현하지 않으면, 클래스는 Object.prototype의 기본 구현을 상속할 것이고, 그 기본 구현 메서드는 쓸모 없는 문자열 <strong>“[object Object]”</strong>를 반환할 것이다.<br>다음 메서드는 <code>valueOf()</code>이다. 이 메서드는 <strong>객체를 원시 값으로 변환</strong>한다. 예를 들면, valueOf() 메서드는 객체가 숫자 컨텍스트에서 산술 연산자(+ 제외)나 비교 연산자와 함께 사용될 때 자동으로 호출된다. 객체 대부분은 원시 값으로 변환할 필요가 없으므로, 이 메서드를 정의하지 않는다.<br>다음 메서드는 <code>toJson()</code>이고 JSON.stringify()에 의해 자동으로 호출된다. JSON 형식은 데이터 구조를 직렬화하는데 사용되고 자바스크립트 원시 값, 배열, 일반 객체를 처리할 수 있다. 직렬화 할 때 객체의 프로토타입과 생성자는 무시된다.</p>
<h4 id="964-비교-메서드"><a href="#9-6-4-비교-메서드" class="headerlink" title="9.6.4 비교 메서드"></a><span style="color:red">9.6.4 비교 메서드</span></h4><p>자바스크립트의 <strong>동치 연산자들은 객체를 비교할 때, 값이 아니라 참조를 사용한다.</strong> 즉, 주어진 두 참조가 같은 객체를 가리키고 있는지를 본다. 만약 어떤 클래스를 정의하고 이 클래스의 인스턴스를 비교하려면 비교하는 데 사용할 메서드를 정의해야 한다.<br>인스턴스를 동등 비교하려면, <code>equals()</code>라는 인스턴스 메서드를 정의해야 한다. equals() 메서드는 하나의 인자를 받고, 전달받은 인자와 equals 메서드를 가진 객체가 같다면 true를 반환한다. 클래스 컨텍스트상에서 ‘같다’라는 것이 어떤 의미인지는 구현에 달려있다.<br>객체를 어떤 순서에 따라 비교하는 것도 유용하다. 어떤 클래스의 한 인스턴스가 다른 인스턴스보다 ‘작다’ 또는 ‘크다’라고 말할 수 있게된다. 만약 &lt;와 &lt;=같은 관계 연산자에 객체를 사용하면 자바스크립트는 먼저 해당 객체의 <code>valueOf()</code> 메서드를 호출하고, 이 메서드가 원시 값을 반환하면 값을 비교한다. 그러나 대다수 클래스에는 valueOf() 메서드가 없다. 만약 valueOf() 메서드가 없는 객체들을 명시적으로 선택한 순서에 따라 비교하려면, <code>compareTo()</code> 메서드를 정의해야 한다.<br>compareTo() 메서드는 하나의 인자를 받고, 메서드 호출 대상 객체와 인자를 비교한다. 만약 this 객체가 인자 객체보다 작으면 compareTo()는 0보다 작은 값을 반환해야 하며, this 객체가 인자 객체보다 크면 0보다 큰 값을 반환해야 한다. 만약 두 객체가 같으면 을 반환해야 한다. 가장 좋은 방법은 equals() 메서드와 compareTo() 메서드를 일관성 있게 작성하는 것이다.<br>클래스에 compareTo() 메서드를 정의하는 한 가지 이유는 해당 클래스의 인스턴스들로 구성된 배열을 정렬하기 위함이다. <code>Array.sort()</code> 메서드는 추가 인자로 인스턴스를 비교하는 함수를 받는데, 이 비교 함수는 compareTo() 메서드와 <strong>똑같은 반환 값 규칙을 사용</strong>한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ranges.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a.compareTo(b); &#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="966-private-상태"><a href="#9-6-6-private-상태" class="headerlink" title="9.6.6 private 상태"></a><span style="color:red">9.6.6 private 상태</span></h4><p>인스턴스를 생성할 때, 생성자 호출의 클로저에 포착된 변수(혹은 인자)를 사용하면 private 인스턴스 필드를 흉내 낼 수 있다. 그러면 생성자 내부에서 함수들을 정의하고, 이 함수들을 새로 생성한 객체의 프로퍼티로 할당해야 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 예제) 시작점과 끝점에 대해 약한 캡슐화가 적용된 Range 클래스</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from , to</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 객체의 프로퍼티로 from, to를 저장하지 말 것.</span></span><br><span class="line">    <span class="comment">// 대신에 시작점과 끝점을 반환하는 접근자 함수를 정의한다.</span></span><br><span class="line">    <span class="comment">// 인자로 넘어온 from, to 값은 클로저에 저장된다.</span></span><br><span class="line">    <span class="keyword">this</span>.from = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">from</span>; &#125;</span><br><span class="line">    <span class="keyword">this</span>.to = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> to; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 프로토타입의 메서드들은 생성자에 인자로 전달된 from, to를 직접 볼 수 없다.</span></span><br><span class="line">    <span class="comment">// 프로토타입의 메서드들은 다른 모든 것과 마찬가지로 접근자 메서드를 호출해야 한다.</span></span><br><span class="line">    Range.prototype = &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: Range,</span><br><span class="line">        includes: function(x) &#123; <span class="keyword">return</span> <span class="keyword">this</span>.from() &lt;= x &amp;&amp; x &lt;= <span class="keyword">this</span>.to(); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>이러한 캡슐화 기법에는 <strong>오버헤드</strong>가 있다. 상태를 캡슐화하도록 클로저를 사용하는 클래스는 그렇지 않은 클래스보다 확실히 느리고 크다.</p>
<hr>
<h2 id="97-서브클래스"><a href="#9-7-서브클래스" class="headerlink" title="9.7 서브클래스"></a><span style="color:red">9.7 서브클래스</span></h2><p>객체 지향 프로그래밍에서 클래스 B는 다른 클래스 A를 <code>확장(extend)</code>하거나 클래스 A의 하위클래스가 될 수 있다. 이런 경우, 클래스 A를 <strong>슈퍼클래스</strong>라 하고 클래스 B를 <strong>서브클래스</strong>라고 한다. 클래스 B의 인스턴스는 클래스 A의 모든 인스턴스 메서드를 상속한다. 클래스 B의 메서드가 클래스 A의 메서드를 재정의했을 때, 클래스 B의 재정의된 메서드에서 클래스 A의 원래 메서드를 호출할 수가 있는데 이를 <code>메서드 체이닝</code>이라고 한다. 비슷하게 서브클래스의 생성자 B()가 슈퍼클래스의 생성자 A()를 호출할 필요가 있는데, 이는 <code>생성자 체이닝</code>이라고 한다.</p>
<blockquote>
<p>이하 내용은 추후에 업데이트 예정… 다른 부분보다 확실히 이해가 많이 필요한 부분이라 몇 번 더 읽어봐야 할 것 같다.</p>
</blockquote>
<p><br><br><strong>출처 : <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10338797" rel="external nofollow noopener noreferrer" target="_blank">“JavaScript: The Definitive Guide, by David Flanagan (O’Reilly). Copyright 2011 David Flanagan, 978-0-596-80552-4”</a></strong></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-29T17:10:32.000Z">2017-01-30</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    40분 읽기 (대략 5932 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/30/JavaScript/complete-guide-to-javascript-chapter-8/">자바스크립트 완벽가이드 8장 (함수)</a>
            
        </h1>
        <div class="content">
            <p><code>함수</code>는 한 번 정의하면 몇 번이든 실행할 수 있고 호출할 수 있는 자바스크립트 코드 블록이다. 함수 호출에는 전달인자 외에도 <code>호출 컨텍스트</code>가 포함되는데, <code>this</code> 키워드의 값이 바로 해당 컨텍스트다.<br>어떤 객체의 프로퍼티로 할당된 함수를 해당 객체의 <code>메서드</code>라 한다. 어떤 함수를 객체를 대상(on)으로, 또는 객체를 통해서(through) 호출하면, 이 객체는 해당 함수의 호출 컨텍스트, 즉 호출된 함수의 this 값이 된다. 새로 생성된 객체를 초기화하는 데 쓰이는 함수는 <code>생성자(constructor)</code>라고 한다.<br>자바스크립트 함수는 다른 함수 내에 중첩되어 정의될 수 있고, 중첩된 함수는 해당 함수가 정의된 유효범위 안의 어떤 변수에도 접근할 수 있다. 이는 자바스크립트 함수가 <code>클로저(closure)</code>이며, 클로저가 가능하게 하는 중요하고 강력한 프로그래밍 기법을 자바스크립트도 구사할 수 있음을 뜻한다.</p>
<h2 id="81-함수-정의하기"><a href="#8-1-함수-정의하기" class="headerlink" title="8.1 함수 정의하기"></a>8.1 함수 정의하기</h2><p>함수는 <code>function</code> 키워드에 의해 정의되며, function 키워드는 함수 정의 표현식 또는 함수 선언문에서 사용된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 정의된 함수를 변수에 할당할 수 있다.</span></span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="comment">// 함수 표현식은 이름을 포함할 수 있다. 이러한 이름은 재귀 호출에 유용하게 사용된다.</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">return</span> x*fact(x<span class="number">-1</span>); &#125;;</span><br><span class="line"><span class="comment">// 함수 표현식은 다른 함수의 전달인자로 사용 가능하다.</span></span><br><span class="line">data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a-b ; &#125;);</span><br><span class="line"><span class="comment">// 함수 표현식은 정의되는 즉시 호출 가능하다.</span></span><br><span class="line"><span class="keyword">var</span> tensquared = (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x*x;&#125;(<span class="number">10</span>));</span><br></pre></td></tr></table></figure></p>
<p>함수 정의 표현식에서 함수 이름은 옵션이다. 함수 선언문이 실제로 하는 일은, 어떤 변수를 정의하고 함수 객체를 그 변수에 할당하는 것이다.  함수 정의 표현식이 이름을 포함하면, 이 함수 몸체의 유효 범위에 해당 함수 객체에 연결된 이름이 포함된다. 사실상 그 함수 이름이 해당 함수의 지역 변수가 되는 것이다. 표현식 형태로 함수를 정의하는 것은 한 번만 사용되는 함수에 특히 적합하다.<br>함수 선언문은 그 함수를 둘러싼 스크립트나 함수의 맨 위로 <code>끌어올려(hoisted)</code>진다. 따라서 해당 함수는 이 함수가 정의된 위치보다 앞서 나오는 코드로부터 호출될 수 있다. 그러나 표현식으로 정의된 함수는 다르다. 함수를 호출하려면 먼저 호출할 함수를 참조할 수 있어야 하는데, 표현식으로 정의된 함수는 변수에 할당되기 전까지는 참조할 수 없다. <strong>변수 선언은 끌어올려지지만, 변수 할당은 그렇지 않다.</strong> 그래서 표현식으로 정의된 함수는 정의되는 지점 위에서는 호출할 수 없다.<br>함수 대부분은 return문을 포함하고 있다. return 다음에 오는 표현식의 값을 호출자에게 반환하는데 return 다음에 표현식이 없다면 undefined 값을 반환한다. 함수가 return 문을 포함하지 않는다면, 함수 몸체 내의 각 구문을 실행 후 다음 호출자에게 undefined 값이 반환된다.</p>
<hr>
<h2 id="82-함수-호출하기"><a href="#8-2-함수-호출하기" class="headerlink" title="8.2 함수 호출하기"></a>8.2 함수 호출하기</h2><p>자바스크립트 함수는 네 가지 방법으로 호출할 수 있다.</p>
<ol>
<li>일반적인 함수 형태</li>
<li>메서드 형태</li>
<li>생성자</li>
<li>call()과 apply() 메서드를 통한 간접 호출</li>
</ol>
<h4 id="821-함수-호출"><a href="#8-2-1-함수-호출" class="headerlink" title="8.2.1 함수 호출"></a>8.2.1 함수 호출</h4><p>함수가 호출될 때는 먼저, 각각의 전달인자 표현식(괄호 사이에 있는 것)이 평가되고, 평가 결과 값이 해당 함수의 전달인자가 된다. 이 전달인자 값들은 함수 정의에 등장하는 형식인자 각각에 대응된다.<br>일반적인 함수 형태로 호출하도록 작성된 함수는 보통 <code>this</code> 키워드를 사용하지 않는다.</p>
<h4 id="822-메서드-호출"><a href="#8-2-2-메서드-호출" class="headerlink" title="8.2.2 메서드 호출"></a><span style="color:red">8.2.2 메서드 호출</span></h4><p>메서드는 객체의 속성으로 저장된 자바스크립트 함수일 뿐이다. 그러나 <strong>메서드 호출</strong>은 <strong>함수 호출</strong>에 비해 한 가지 중요한 부분이 다른데, 바로 <code>호출 컨텍스트</code>다. 메서드 호출 표현식에서는 객체가 호출 컨텍스트가 되므로, 함수 몸체에서 <code>this</code> 키워드를 사용해서 객체를 참조할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculator = &#123;</span><br><span class="line">    operand1: <span class="number">1</span>,</span><br><span class="line">    operand2: <span class="number">1</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 이 객체를 참조하기 위해 this 키워드를 사용</span></span><br><span class="line">        <span class="keyword">this</span>.result = <span class="keyword">this</span>.operand1 + <span class="keyword">this</span>.operand2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculator.add();</span><br><span class="line">calculator.result        <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure></p>
<p><code>메서드</code>와 <code>this</code> 키워드는 자바스크립트 객체 지향 프로그래밍 패러다임의 중심이다. 메서드로 사용되는 함수는 메서드의 호출 대상 객체를 <code>암시적 인자</code>로 전달받는다.</p>
<blockquote>
<p><strong>메서드 체이닝</strong><br>메서드 체이닝은 객체 이름은 한 번만 사용하고 메서드는 여러 번 호출할 수 있는 방식이다. (메서드가 객체를 반환하면, 메서드의 반환 값을 후속 호출의 일부로 사용)</p>
</blockquote>
<p>변수와 달리, this 키워드에는 유효범위(scope)가 없고 중첩 함수는 호출자의 this 값을 상속하지 않는다. 만약 중첩 함수가 메서드 형태로 호출되면, 그 함수의 this 값은 그 함수의 호출 대상 객체다. <strong>가장 흔한 실수는, 함수 형태로 호출된 중첩 함수가 바깥쪽 함수의 호출 컨텍스트를 획득하기 위해 this 값을 사용할 수 있다고 가정하는 것이다. 만약 바깥쪽 함수의 this 값에 접근하고 싶다면, 안쪽 함수의 유효범위에 바깥쪽 함수의 this 값을 별도의 변수로 저장해야 한다. 이러한 용도로 보통 <code>self</code> 변수를 사용한다.</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;                 <span class="comment">// this 값을 변수에 저장</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);         <span class="comment">// true: this는 객체 o이다.</span></span><br><span class="line">        f();                             <span class="comment">// 헬퍼 함수 f() 호출</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;                   <span class="comment">// 중첩 함수 f()</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);     <span class="comment">// false: this는 global 객체 또는 undefined이다.</span></span><br><span class="line">            <span class="built_in">console</span>.log(self === o);     <span class="comment">// true: self는 바깥쪽 함수의 this 값이다.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">o.m();</span><br></pre></td></tr></table></figure></p>
<h4 id="823-생성자-호출"><a href="#8-2-3-생성자-호출" class="headerlink" title="8.2.3 생성자 호출"></a><span style="color:red">8.2.3 생성자 호출</span></h4><p>함수나 메서드 호출 앞에 <code>new</code> 키워드가 있다면 생성자 호출이다. 생성자 호출은 일반 함수와 메서드 호출에 비해 매개변수, 호출 컨텍스트와 반환 값을 다루는 방식이 다르다.<br><strong>생성자에 전달인자(매개변수) 목록이 없다면, 자바스크립트 생성자 호출 문법은 전달인자 목록과 괄호를 아예 생략하는 것을 허용한다.</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Obejct;</span><br><span class="line"><span class="comment">// 위 두개는 같은 코드이다.</span></span><br></pre></td></tr></table></figure></p>
<p>생성자를 호출하면 생성자의 prototype 프로퍼티를 상속받은 새로운 빈 객체가 생성된다. 생성자 함수는 객체를 초기화하고, <strong>새로 생성된 이 객체는 생성자 함수의 호출 컨텍스트로 사용된다.</strong> 따라서 생성자 함수는 새로 생성된 객체를 <code>this</code> 키워드로 참조할 수 있다. 주의할 것은 생성자 호출이 마치 메서드 호출처럼 보일지라도, 메서드가 속한 객체가 아닌 새로 생성된 객체가 호출 컨텍스트로 사용된다는 점이다. (즉, new o.m()과 같은 표현식에서 o가 호출 컨텍스트로 사용되지는 않는다는 뜻)<br>생성자 함수는 보통 return 키워드를 사용하지 않는다. 일반적으로 생성자 함수는 새 객체를 초기화하고, 생성자 함수 몸체의 끝에 이르면 암시적으로 그 객체를 반환한다. 새 객체가 생성자 호출 표현식의 값이다.</p>
<h4 id="824-간접-호출"><a href="#8-2-4-간접-호출" class="headerlink" title="8.2.4 간접 호출"></a>8.2.4 간접 호출</h4><p>자바스크립트 함수는 객체이고, 모든 자바스크립트 객체와 같이 함수에도 메서드가 있다. 이 메서드 중 <code>call()</code>과 <code>apply()</code>는 함수를 간접적으로 호출한다. 두 메서드 모두 호출 때 this 값을 명시적으로 지정할 수 있는데, 이는 어떤 함수든지 특정 객체의 메서드로 호출할 수 있다는 의미다. 심지어 함수가 실제로 그 객체에 속하지 않더라도 말이다.</p>
<hr>
<h2 id="83-함수-전달인자와-매개변수"><a href="#8-3-함수-전달인자와-매개변수" class="headerlink" title="8.3 함수 전달인자와 매개변수"></a>8.3 함수 전달인자와 매개변수</h2><h4 id="831-생략-가능한-매개변수"><a href="#8-3-1-생략-가능한-매개변수" class="headerlink" title="8.3.1 생략 가능한 매개변수"></a>8.3.1 생략 가능한 매개변수</h4><p>정의된 것보다 적은 수의 전달인자로 함수가 호출되면, 나머지 매개변수는 <code>undefined</code> 값으로 설정된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPropertyNames</span>(<span class="params">o, <span class="regexp">/* optional */</span> a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === <span class="literal">undefined</span>) a = [];    <span class="comment">// 만약 undefined이면 새 배열을 사용한다.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> property <span class="keyword">in</span> o) a.push(property);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getPropertyNames의 첫줄에는 if문 대신, 관용적으로 || 연산자를 사용하기도 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a || [];</span><br></pre></td></tr></table></figure></p>
<p><code>||</code> 연산자는 첫 번째 피 연산자가 true이거나  true로 변환될 수 있는 값이면 첫 번째 피 연산잘르 반환하고, 그렇지 않으면 두 번째 피 연산자를 반환한다. 따라서, 두 번째 인자가 생략된다면(또는 null이거나 false혹은 false로 변환될 수 있는 값이라면), 새로 생성된 빈 배열이 대신 사용될 것이다.</p>
<h4 id="832-가변길이-전달인자-목록-arguments-객체"><a href="#8-3-2-가변길이-전달인자-목록-Arguments-객체" class="headerlink" title="8.3.2 가변길이 전달인자 목록: Arguments 객체"></a>8.3.2 가변길이 전달인자 목록: Arguments 객체</h4><p>함수가 호출될 때 정의된 매개변수보다 더 많은 인자가 전달되면, 매개변수 이름이 붙지 않은 인자 값을 직접적으로 참조할 방법은 없다. <code>Arguments</code> 객체는 이러한 문제에 대한 해결책이다. 함수 몸체 내에서 arguments 식별자는 해당 호출에 대한 Arguments 객체를 참조한다. Arguments 객체는 <code>유사 배열 객체</code>이고, 이름이 아니라 인덱스 숫자를 통해 함수의 전달인자를 얻어올 수 있다. (내장 함수 Math.max()가 Arguments를 사용하여 동작한다.)<br>arguments는 실제로는 배열이 아니라 Arguments 객체이다. 각 Arguments 객체는 숫자 인덱스가 붙은 배열 원소와 length 프로퍼티를 갖고 있다. 그러나 배열은 아니다. 어쩌다가 숫자로 된 프로퍼티를 갖고 있는 객채이다.<br>Arguments 객체의 배열 원소와 매개변수의 이름은 동일한 값을 가리키는 다른 두 이름이다. (Arguments 객체가 평범한 배열이라면, arguments[0]과 x는 같은 값을 가질 수 있지만, 하나를 변경하는 작업이 다른 하나에 영향을 미치지는 않을 것이다.)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);             <span class="comment">// 전달인자의 초기 값 출력</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="literal">null</span>;        <span class="comment">// 배열 요소를 변경하면 x 또한 변경</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);             <span class="comment">// 이제 null을 출력</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="833-객체의-프로퍼티를-전달인자로-사용하기"><a href="#8-3-3-객체의-프로퍼티를-전달인자로-사용하기" class="headerlink" title="8.3.3 객체의 프로퍼티를 전달인자로 사용하기"></a>8.3.3 객체의 프로퍼티를 전달인자로 사용하기</h4><p>어떤 함수에 세 개 이상의 매개변수가 있다면, 이 함수를 호출할때 인자의 올바른 순서를 기억하기가 어렵다. 따라서 전달인자를 순서에 상관없이 <code>이름/값</code>의 쌍으로 함수에 전달하는 편이 효과적일 수 있다. 단일 객체를 전달인자로 받는 함수를 정의하고, 함수의 사용자에게 함수에서 요구하는 이름/값 쌍을 가진 객체를 함수의 인자로 넘기도록 하면 된다.</p>
<h4 id="834-전달인자-형식"><a href="#8-3-4-전달인자-형식" class="headerlink" title="8.3.4 전달인자 형식"></a>8.3.4 전달인자 형식</h4><p>자바스크립트 메서드의 매개변수에는 정의된 형식도 없고, 함수에 전달한 값에 대해서 자료형 검사도 하지 않는다. 한두 번만 사용하고 ‘버릴’함수가 아니라면, 인자 자료형을 검사하는 코드를 추가할 가치가 있다.<br>자바스크립트는 매우 유연하며 자료형을 느슨하게 처리하는 언어이기에, 때로는 인자 개수와 자료형에 유연한 함수를 작성하는 것이 바람직하다.</p>
<hr>
<h2 id="84-값으로서의-함수"><a href="#8-4-값으로서의-함수" class="headerlink" title="8.4 값으로서의 함수"></a>8.4 값으로서의 함수</h2><p><strong>자바스크립트에서 함수는 문법일 뿐만 아니라 값이기도 한데, 이는 함수가 변수에 할당될 수 있고 객체의 프로퍼티나 배열 원소로 저장될 수도 있으며, 다른 함수의 인자로 전달될 수도 있고, 기타 여러 방식으로 사용될 수 있음을 뜻한다.</strong></p>
<h4 id="841-자시만의-함수-프로퍼티-정의하기"><a href="#8-4-1-자시만의-함수-프로퍼티-정의하기" class="headerlink" title="8.4.1 자시만의 함수 프로퍼티 정의하기"></a>8.4.1 자시만의 함수 프로퍼티 정의하기</h4><p>자바스크립트에서 함수는 원시 값이 아니지만 <code>특별한 종류의 객체</code>이고 이는 함수가 <strong>프로퍼티</strong>를 가질 수 있음을 의미한다. 함수가 여러 번 호출되어도 그 값이 유지되어야 하는 ‘정적’ 변수가 필요할 때는, 전역 변수를 사용하는 것보다 함수의 프로퍼티를 사용하는 것이 편리한 경우가 많다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 팩토리얼을 계산하고 계산 결과를 함수 자신의 프로퍼티에 캐시한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isFinite</span>(n) &amp;&amp; n&gt;<span class="number">0</span> &amp;&amp; n==<span class="built_in">Math</span>.round(n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(n <span class="keyword">in</span> factorial))                       <span class="comment">// 만약 캐시 해둔 결과가 없다면</span></span><br><span class="line">            factorial[n] = n * factorial(n<span class="number">-1</span>);       <span class="comment">// 팩토리얼을 계싼하고, 계산 값 캐시</span></span><br><span class="line">        <span class="keyword">return</span> factorial[n];                         <span class="comment">// 캐시 결과를 반환</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">&#125;</span><br><span class="line">factorial[<span class="number">1</span>] = <span class="number">1</span>;                                    <span class="comment">// 캐시를 기본 경우(1)에 대한 값으로 초기화</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="85-네임스페이스로서의-함수"><a href="#8-5-네임스페이스로서의-함수" class="headerlink" title="8.5 네임스페이스로서의 함수"></a><span style="color:red">8.5 네임스페이스로서의 함수</span></h2><p>자바스크립트는 함수 단위의 유효범위를 갖는다. 함수 내부에 정의된 변수는 해당 함수 내부(중첩 함수를 포함한)에서는 접근 가능하지만, 그 함수 바깥에는 존재할 수 없다. 함수 밖에서 정의된 변수는 전역 변수이고 자바스크립트 프로그램 전체에서 접근할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;       <span class="comment">// 이름이 없는 표현식으로 함수 작성</span></span><br><span class="line">                     <span class="comment">// 모듈 코드 위치</span></span><br><span class="line">&#125;());                <span class="comment">// 함수 리터럴을 끝내고 바로 호출</span></span><br></pre></td></tr></table></figure></p>
<p>단일 표현식으로 함수를 정의하고 호출하는 방식은 관용적으로 자주 사요되는 기법이다. 함수 앞의 시작 괄호는 반드시 필요한데, 만약 시작괄호가 없다면 자바스크립트 인터프리터는 function 키워드를 함수 선언문으로 해석하기 때문이다. 괄호가 있으면 인터프리터는 이것을 표현식 형태의 함수 선언으로 올바르게 인식한다. 괄호가 꼭 필요하지 않은 상황에서도, 정의하자마자 호출할 함수를 괄호로 둘러싸는 건 관용적인 방식이다.</p>
<hr>
<h2 id="86-클로저"><a href="#8-6-클로저" class="headerlink" title="8.6 클로저"></a><span style="color:red">8.6 클로저</span></h2><p>자바스크립트는 다은 언어와 마찬가지로 <code>어휘적 유효범위</code>를 사용한다. 함수를 호출하는 시점에서의 변수 유효범위가 아니라, 함수가 정의된 시점의 변수 유효범위를 사용하여 함수가 실행된다는 뜻이다. 이러한 어휘적 유효범위를 구현하기 위해, 자바스크립트 함수 객체는 내부 상태에 함수 자체의 코드뿐만 아니라 현재 유효범위 체인에 대한 참조도 포함하고 있다. <strong>함수 객체와 함수의 변수가 해석되는 유효범위(변수 바인딩의 집합)를 아울러 컴퓨터 과학 문헌에서는 <code>클로저(closure)</code>라고 부른다.(내부함수는 외부함수의 지역변수에 접근 할 수 있는데 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근할 수 있다. 이러한 메커니즘이 클로저이다.)</strong><br>기술적으로 자바스크립트 함수는 클로저이다. 함수는 객체이고 함수 자신과 관련된 유효범위 체인을 갖고있기 때문이다. 함수 대부분은 함수가 정의되었을 때의 유효범위 체인을 사용하여 호출되고, 클로저가 개입되었는지의 여보는 중요하지 않다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;             <span class="comment">// 전역 변수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;          <span class="comment">// 지역 변수</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> scope; &#125;      <span class="comment">// 이 유효범위에 있는 값을 반환</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()()</span><br></pre></td></tr></table></figure></p>
<p>checkscope()는 중첩 함수를 객체 그 자체를 반환한다. 어휘적 유효범위의 기본적은 규칙을 기억해야한다. <strong>자바스크립트 함수는 함수가 정의되었을 때의 <code>유효범위 체인</code>을 사용하여 실행된다.</strong> 중첩 함수 f()가 정의된 유효범위 체인에서 변수 scope는 “local scope”로 바인드되어 있다. f가 어디서 호출되든 상관없이, f가 실행될 때 이 바인딩은 항상 유효하다. 따라서 코드의 제일 마지막 줄은 “global scope”가 아니라 “local scope”를 반환한다. 이것이 클로저의 놀랍고 강력한 특성이다. <strong><code>클로저</code>는 자신을 정의한 바깥쪽 함수에 바인딩된 지역 변수(그리고 전달인자)를 포착한다.</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniqueInteger = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;      <span class="comment">// 함수를 정의하고 바로 호출</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;                   <span class="comment">// 아래 함수의 내부 상태</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> counter++; &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p>중첩 함수는 유효범위에 있는 변수에 접근하고, 바깥쪽 함수에 정의된 counter 변수를 사용할 수 있다. 바깥쪽 함수의 실행이 끝나면, 어떤 코드도 counter 변수를 볼 수 없다. 오직 안쪽 함수만 단독으로 counter 변수에 접근할 수 있을 뿐이다. counter와 같은 내부 변수는 여러 클로저가 공유할 수 있다. 즉, <strong>같은 함수 안에 정의된 중첩 함수들은 같은 유효범위 체인을 공유한다.</strong><br><strong>클로저 기법과 getter/setter 프로퍼티들을 결합할 수 있다.</strong>  다음 예제는 내부 상태를 다루는 데 일반 객체 프로퍼티 대신 클로저를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">n</span>) </span>&#123;        <span class="comment">// 함수 전달인자 n은 내부 변수다.</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// getter 메서드 프로퍼티는 counter 변수를 반환하고 증가시킨다.</span></span><br><span class="line">        get count() &#123; <span class="keyword">return</span> n++; &#125;,</span><br><span class="line">        <span class="comment">// setter 메서드는 프로퍼티 n 값을 감소시키는 것을 허용하지 않는다.</span></span><br><span class="line">        set count(m) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( m &gt;= n) n = m</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"count는 오직 더 큰 값으로만 설정될 수 있습니다."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = conter(<span class="number">1000</span>);</span><br><span class="line">c.count             <span class="comment">// =&gt; 1000</span></span><br><span class="line">c.count             <span class="comment">// =&gt; 1001</span></span><br><span class="line">c.count = <span class="number">2000</span>      <span class="comment">// =&gt; 2000</span></span><br><span class="line">c.c ount            <span class="comment">// =&gt; 2000</span></span><br><span class="line">c.count = <span class="number">2000</span>      <span class="comment">// =&gt; 에러!</span></span><br></pre></td></tr></table></figure>
<p>counter() 함수는 지역 변수를 정의하지 않지만, 프로퍼티 접근 메서드들이 공유하는 내부 상태를 보관하기 위해 매개변수 n을 사용한다. 이로써 counter()를 호출하는 쪽에서 내부 변수의 초기 값을 지정할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0-9 값을 반환하는 함수들의 배열을 반환</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfuncs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> funcs = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        funcs[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> i; &#125;;</span><br><span class="line">    <span class="keyword">return</span> funcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcs = constfuncs();</span><br><span class="line">funcs[<span class="number">5</span>]()         <span class="comment">// 무엇이 반환될까?</span></span><br></pre></td></tr></table></figure>
<p>위의 코드는 열 개의 클로저를 생성하고, 생성한 클로저들을 배열에 저장한다. 모든 클로저는 같은 함수 내에서 정의되고, 따라서 클로저들은 변수 i에 대한 접근을 <strong>공유</strong>한다. constfuncs() 실해잉 끝나면, 변수 i의 값은 10이고, 열 개의 클로저 모두 이 값을 공유한다. 클로저와 연관된 유효범위 체인이 ‘살아 있다’는 사실을 기억해야 한다. <strong>중첩 함수는 유효범위에 대한 내부 사본이나 변수 바인딩의 스냅샷 따위는 만들지 않는다.</strong></p>
<p>더 자세한 내용은 다음을 참고<br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures" rel="external nofollow noopener noreferrer" target="_blank">클로저(MDN)</a><br><a href="http://meetup.toast.com/posts/86" rel="external nofollow noopener noreferrer" target="_blank">자바스크립트의 스코프와 클로저</a></p>
<hr>
<h2 id="87-함수-프로퍼티-메서드-생성자"><a href="#8-7-함수-프로퍼티-메서드-생성자" class="headerlink" title="8.7 함수 프로퍼티, 메서드, 생성자"></a>8.7 함수 프로퍼티, 메서드, 생성자</h2><p>자바스크립트에서 함수는 일종의 값이다. typeof 연산자를 사용하면 “function” 문자열을 얻을 수 있지만, 함수는 정말 독특한 <strong>자바스크립트 객체</strong>다. 함수는 객체이기 때문에 프로퍼티와 메서드를 가질 수 있으며 Function() 이라는 생성자도 갖고 있다.</p>
<h4 id="872-prototype-프로퍼티"><a href="#8-7-2-prototype-프로퍼티" class="headerlink" title="8.7.2 prototype 프로퍼티"></a>8.7.2 prototype 프로퍼티</h4><p>모든 함수에는 prototype 프로퍼티가 있는데, 이 프로퍼티는 프로토타입 객체를 참조한다. 모든 함수는 서로 다른 프로토타입 객체를 갖고 있고, 함수가 생성자로 사용될 때, 새로 생성된 객체는 함수의 프로토타입 객체로부터 프로퍼티들을 상속받는다.</p>
<h4 id="873-call과-apply-메서드"><a href="#8-7-3-call-과-apply-메서드" class="headerlink" title="8.7.3 call()과 apply() 메서드"></a><span style="color:red">8.7.3 call()과 apply() 메서드</span></h4><p><code>call()</code>과 <code>apply()</code>는 어떤 함수를 다른 객체의 메서드인 것처럼 간접적으로 호출할 수 있도록 한다. call()과 apply()의 첫 번째 인자는 호출되는 함수와 관련이 있는 개체다. 이 첫 번째 인자는 호출 컨텍스트고 함수 몸체에서 <code>this</code> 키워드의 값이 된다. 함수 f()를 객체 o의 메서드로 호출하려면 다음과 같이 사용한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.call(o);</span><br><span class="line">f.apply(o);</span><br></pre></td></tr></table></figure></p>
<p>call()의 첫 번째 호출 컨텍스트 다음에 있는 모든 인자는 호출되는 함수로 전달된다. apply() 메서드는 call() 메서드와 비슷하지만, 함수에 전달할 인자는 배열 형태여야 한다. apply()는 실제 배열과 마찬가지로 유사 배열 객체와도 잘 작동한다. 특히 arguments 배열을 직접 apply()에 넘김으로써, 다른 함수를 호출할 때 현재 함수에 전달된 인자와 같은 인자를 전달할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 o의 메서드 m을, 원본 메서드 호출 전후에 로그 메시지를 남긴다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>(<span class="params">o, m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> original o[m];          <span class="comment">// 원본 메서드를 클로저에 기억</span></span><br><span class="line">    o[m] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">"Entering:"</span>, m);</span><br><span class="line">        <span class="keyword">var</span> result = original.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);   <span class="comment">// 원본 메서드 호출</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">"Exiting:"</span>, m);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="874-bind-메서드"><a href="#8-7-4-bind-메서드" class="headerlink" title="8.7.4 bind() 메서드"></a><span style="color:red">8.7.4 bind() 메서드</span></h4><p>bind() 메서드는 ECMAScript 5에 추가되었다. <strong><code>bind()</code>의 주요 목적은 함수와 객체를 서로 묶는 것이다. 함수 f의 bind() 메서드를 호출하면서 객체 o를 전달하면, bind() 메서드는 새로운 함수를 반환한다. 반환된 새 함수를 호출하면, 원래 함수 f가 o의 메서드로 호출된다.</strong> 새로운 함수에 전달한 모든 인자는 원래 함수에도 전달된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.x + y; &#125;     <span class="comment">// 바인드되어야 하는 함수</span></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span> : <span class="number">1</span> &#125;;                       <span class="comment">// 바인드 될 객체</span></span><br><span class="line"><span class="keyword">var</span> g = f.bind(o);                       <span class="comment">// g(x)를 호출하면 o.f(x)가 호출된다.</span></span><br><span class="line">g(<span class="number">2</span>)                                     <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure></p>
<p>ECMAScript 5의 bind() 메서드는 함수를 객체에 바인딩하는 것보다 더 많은 일을 한다. bind()에 전달하는 인자 중 첫 번째 이후의 모든 인자는 this 값과 함께 해당 함수의 인자로 바인딩된다. 이를 <code>커링(currying)</code>이라 부르기도 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y &#125;;</span><br><span class="line"><span class="comment">// 첫 번째 인자는 1로 바인딩된다. 새로운 함수는 단지 하나의 인자만 요구한다.</span></span><br><span class="line"><span class="keyword">var</span> succ = sum.bind(<span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line">succ(<span class="number">2</span>)            <span class="comment">// =&gt; 3: x는 1에 바인딩되고 y 인자로 2를 넘긴다.</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>출처 : <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10338797" rel="external nofollow noopener noreferrer" target="_blank">“JavaScript: The Definitive Guide, by David Flanagan (O’Reilly). Copyright 2011 David Flanagan, 978-0-596-80552-4”</a></strong></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-29T17:10:32.000Z">2017-01-30</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    13분 읽기 (대략 2013 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/30/JavaScript/complete-guide-to-javascript-chapter-10/">자바스크립트 완벽가이드 10장 (정규 표현식을 사용한 패턴 매칭)</a>
            
        </h1>
        <div class="content">
            <p><strong><code>정규 표현식</code>(regular expression)은 문자의 패턴을 나타내는 객체다.</strong> 자바스크립트의 RegExp 클래스는 정규 표현식을 표현하고, String과 RegExp에는 정규표현식을 사용하여 강력한 패턴 매칭을 수행하는 메서드와 텍스트상에서 특정 텍스트를 찾아서 바꾸는 함수가 정의되어 있다.</p>
<h2 id="101-정규-표현식-정의"><a href="#10-1-정규-표현식-정의" class="headerlink" title="10.1 정규 표현식 정의"></a>10.1 정규 표현식 정의</h2><p>자바스크립트에서 정규 표현식은 <code>RegExp</code> 객체로 표현된다. RegExp 객체는 RegExp() 생성자를 사용하여 만들 수 있지만, RegExp() 생성자보다는 정규 표현식 리터럴 문법이 더 자주 사용된다. 정규 표현식 리터럴은 <strong>항 쌍의 슬래시(/)</strong> 문자 사이에 위치한 문자들이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/s$/</span>;</span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"s$"</span>);</span><br></pre></td></tr></table></figure></p>
<p>정규 표현식은 연속된 문자로 구성되어 있다. 영문자를 포함한 문자 대부분은 패턴에 적혀 있는 문자 그대로 매치된다. 몇몇 문자는 문자 그대로 매치되지 않으며, 특별한 의미를 지닌다. 정규 표현식 /s$/는 두 문자로 구성되었는데, 먼저 “s”는 문자 그대로 s와 매치되고, “$”는 특수 메타 문자로 문자열의 끝과 매치된다. 따라서 이 정규 표현식은 “s”로 끝나는 모든 문자열과 매치된다.</p>
<h4 id="1011-리터럴-문자"><a href="#10-1-1-리터럴-문자" class="headerlink" title="10.1.1 리터럴 문자"></a>10.1.1 리터럴 문자</h4><p>모든 영문자와 숫자는 그 문자 그대로 정규 표현식에서 매치된다 특정한 비-알파벳 문자들은 <strong>역슬래시</strong>로 시작하는 <code>이스케이프</code> 문자열을 통해 지원한다. (역슬래시 문자를 있는 그대로 넣으려면 역슬래시 자체를 이스케이프 해야한다. <strong>( /\\/ )</strong><br>몇가지 구두점 문자는 정규 표현식에서 특별한 의미를 지닌다. <strong>(^$.*+?=!:|\/()[]{})</strong></p>
<h4 id="1012-문자-클래스"><a href="#10-1-2-문자-클래스" class="headerlink" title="10.1.2 문자 클래스"></a>10.1.2 문자 클래스</h4><p>개별 리터럴 문자들은 그 문자들을 <code>대괄호</code>로 묶어서 문자 클래스로 다룰 수 있다. 문자 클래스는 해당 클래스 내의 모든 문자에 매치된다. <strong>/[abc]/</strong>는 a,b,c 중 아무 글자에나 매치된다. 부정 문자 클래스도 정의될 수 있는데 이는 대괄호 안에 있는 문자들을 제외한 모든 문자와 매치된다. <code>캐럿(^)</code>을 사용한다. 정규표현식 <strong>/[^abc]/</strong>는 a,b,c를 제외한 모든 문자와 매치된다. 문자 클래스 <code>하이픈(-)</code>을 사용하여 문자의 범위를 지정할 수도 있다. <strong>/[a-z]/</strong>는 라틴 알파벳 소문자와 매치되며, 모든 라틴 알파벳 글자나 숫자와 매치되게 하려면 <strong>/[a-zA-Z0-9]/</strong>를 사용한다.</p>
<h4 id="1013-반복"><a href="#10-1-3-반복" class="headerlink" title="10.1.3 반복"></a>10.1.3 반복</h4><p>복잡한 패턴을 작성할 때는 정규 표현식의 요소가 몇 번이나 반복되는지를 나타내는 문법을 사용해야 한다. 반복을 지정하는 문자는 언제나 반복을 지정할 패턴 뒤에 나온다.</p>
<ul>
<li>{n,m} : 앞의 항목이 적어도 n번이상, m번 이하로 나타난다.</li>
<li>{n,} : 앞의 항목이 n번 이상 나타난다.</li>
<li>{n} : 앞의 항목이 정확하게 n번 나타난다.</li>
<li>? : 앞의 항목이 0번 또는 한 번 나타난다. 앞의 항목이 나오지 않을 수도 있다. {0,1}과 동등</li>
<li>+ : 앞의 항목이 한 번 이상 나타난다. {1,}과 동등</li>
<li>* : 앞의 항목이 0번 또는 그 이상 나타난다. {0,}과 동등<br><em>와 ? 반복 문자를 사용할 때는 조심해야 한다. 예를 들면 정규 표현식 /a</em>/는 실제로 문자열 “bbbb”와 매치된다.</li>
</ul>
<h4 id="1014-대체-그룹화-참조"><a href="#10-1-4-대체-그룹화-참조" class="headerlink" title="10.1.4 대체, 그룹화, 참조"></a>10.1.4 대체, 그룹화, 참조</h4><p><strong>정규 표현식 문법은 대체 표현식, 부분 표현식 그룹화, 이전 부분 표현식을 참조 하는 특별한 문자를 포함하고 있다.</strong><br><code>파이프 문자(|)</code>는 대체 표현식을 구분한다. <strong>/ab|cd|ef/</strong>는 문자열 “ab” 또는 문자열 “cd” 또는 문자열 “ef”와 매치된다. 대체 표현식은 매치를 발견할 때까지 왼쪽에서 오른쪽으로 수행된다. 따라서 /a|ab/를 문자열 “ab”에 적용하면, 오직 첫 번째 글자 a만 매치된다.<br>정규 표현식에서 <code>괄호</code>는 여러 목적으로 사용된다. 하나는 여러 항목을 하나의 부분 표현식으로 묶고(그룹화(, 묶인 항목들을 |, *, +, ? 등이 하나의 단위로 취급할 수 있게 한다. <strong>/(ab|cd)+|ef/</strong>는 “ab” 또는 “cd”가 한 번 이상 반복되는 문자열 혹은 문자열 “ef”와 매치된다.<br>정규 표현식에서 괄호의 다른 목적은 전체 패턴 안에 부분 패턴을 정의하는 것이다. 정규 표현식이 대상 문자열에 성공적으로 매치되면, 괄호로 둘러싸인 특정 패턴과 매치되는 부분 문자열을 추출할 수 있다. 예를 들어 각 매치에 대해 끝에 있는 숫자에만 관심이 있다면, 패턴 일부를 <strong>/[a-z]+(\d+)/</strong>와 같이 괄호 안에 두고 찾아낸 매치 결과에서 숫자를 추출할 수 있다.</p>
<h4 id="1016-플래그flag"><a href="#10-1-6-플래그-flag" class="headerlink" title="10.1.6 플래그(flag)"></a>10.1.6 플래그(flag)</h4><p>정규 표현식 플래그는 고차원 패턴 매칭 규칙을 지정한다. 다른 정규 표현식 문법과는 달리 플래그는 / 문자 쌍 바깥에, 즉 두 번째 슬래시 다음에 등장한다. 자바스크립트는 세 가지 플래그를 지원한다. 플래그들은 조합하여 지정될 수 있다.</p>
<ul>
<li>i : 대소문자를 구별하지 않는 매칭을 수행한다.</li>
<li>g : 전역 매칭을 수행한다.. 즉, 처음 매치에서 끝내지 않고 모든 매치를 찾는다.</li>
<li>m : 여러 줄 모드</li>
</ul>
<hr>
<h2 id="102-패턴-매칭을-위한-문자열-메서드"><a href="#10-2-패턴-매칭을-위한-문자열-메서드" class="headerlink" title="10.2 패턴 매칭을 위한 문자열 메서드"></a>10.2 패턴 매칭을 위한 문자열 메서드</h2><p>문자열에는 정규 표현식을 사용하는 메서드가 <strong>네 개</strong> 있다. 가장 간단한 것은 <code>search()</code> 메서드다. 이 메서드는 정규 표현식을 인자로 받고, 가장 처음 매칭되는 부분 문자열의 위치를 반환한다. 만약 매칭되는 문자열이 없다면 -1을 반환한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"JavaScript"</span>.search(<span class="regexp">/script/i</span>);         <span class="comment">// 4를 반환한다.</span></span><br></pre></td></tr></table></figure></p>
<p>search()에 넘기는 인자가 정규 표현식이 아니라면, 이 인자는 먼저 RegExp 생성자로 넘겨지고 정규 표현식으로 변환된다. search()는 전역 검색을 지원하지 않기 때문에, 정규 표현식 인자의 g플래그는 무시된다.<br><code>replace()</code> 메서드는 <strong>‘검색 후 바꾸기’</strong>를 수행한다. 첫 번째 인자로는 정규 표현식을 받고, 두 번째 인자로는 교체할 문자열을 받는다. replace() 메서드는 g플래그 사용이 가능하다. replace()의 첫 번째 인자가 정규 표현식이 아니라 일반 문자열인 경우에는 RegExp() 생성자를 사용하여 정규 표현식으로 변환하지 않고 전달된 문자열을 문자열 그대로 찾는다.(search() 와는 반대)<br><code>match()</code> 메서드는 정규 표현식 하나만을 인자로 받고 매치 결과를 배열로 반환한다. g플래그가 설정되어 있으면, 문자열 내의 모든 매치 부분을 배열로 반환한다. g플래그가 설정되어 있지 않으면, match()는 전역 검색을 수행하지 않고 단순히 첫 번째 매칭만 찾는다. 그러나 결과는 항상 배열로 반환된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="regexp">/(\w+):\/\/([\w.]+)\/(\S*)/</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"Visit my blog at http://www.example.com/~david"</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.match(url);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fullurl = result[<span class="number">0</span>];        <span class="comment">// http:/www.example.com/~david</span></span><br><span class="line">    <span class="keyword">var</span> protocol = result[<span class="number">1</span>];       <span class="comment">// http</span></span><br><span class="line">    <span class="keyword">var</span> host = result[<span class="number">2</span>];           <span class="comment">// www.example.com</span></span><br><span class="line">    <span class="keyword">var</span> path = result[<span class="number">3</span>];           <span class="comment">// ~david</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>split()</code> 메서드는 주어진 인자를 구분자로 삼아, 메서드가 호출된 문자열을 부분 문자열로 쪼갠다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"123,456,789"</span>.split(<span class="string">","</span>)        <span class="comment">// ["123", "456", "789"]</span></span><br></pre></td></tr></table></figure></p>
<p><br><br><strong>출처 : <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10338797" rel="external nofollow noopener noreferrer" target="_blank">“JavaScript: The Definitive Guide, by David Flanagan (O’Reilly). Copyright 2011 David Flanagan, 978-0-596-80552-4”</a></strong></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-27T17:10:32.000Z">2017-01-28</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    42분 읽기 (대략 6318 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/28/JavaScript/complete-guide-to-javascript-chapter-6/">자바스크립트 완벽가이드 6장 (객체)</a>
            
        </h1>
        <div class="content">
            <p>자바스크립트의 기본 데이터 타입은 <strong>객체</strong>다. 객체는 일종의 복합체로, 여러 값(원시 타입, 다른 객체)들을 묶어 이름으로 저장하고, 값을 가져올 수 있다. 객체는 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합이다. 자바스크립트 객체는 객체가 가진 고유 프로퍼티를 유지하는 것 외에 <strong>‘프로토타입’</strong>이라고 하는 다른 객체의 프로퍼티를 상속 받는다. 객체의 메서드들은 일반적으로 상속받은 프로퍼티이고, 이를 <strong><code>&#39;프로토타입 상속&#39;</code></strong>이라고 한다. 프로토타입 상속은 자바스크립트의 핵심적 특징이다.<br><br><strong>자바스크립트 객체는 프로퍼티를 동적으로 추가하고 제거할 수 있기 때문에 동적이지만 자바스크립트의 객체는 정적 객체를 흉내 낼 수도 있고, 정적 타입 언어에서의 ‘구조체’처럼 사용할 수도 있다.</strong><br><br><strong>자바스크립트에서는 문자열(string)과 숫자(number), true/false와 null/undefined를 제외한 나머지는 객체다. 비록 문자열과 숫자, 불리언 값은 객체는 아니지만 변경 불가능한 객체(Wrapper 객체)처럼 동작한다.</strong><br><br>객체의 각 프로퍼티는 <strong>‘프로퍼티 속성’</strong>(쓰기, 열거, 설정) 이라고 하는 연관된 값을 갖는다.<br><br>프로퍼티뿐 아니라, 모든 개체는 세 가지의 속성을 갖는다.</p>
<ul>
<li><strong>prototype</strong>은 상속받은 프로퍼티들을 가진 객체를 참조한다.</li>
<li><strong>class</strong>는 객체의 자료형(타입)을 특정짓는 문자열이다.</li>
<li><strong>extensible 속성</strong>(ECMAScript 5)은 객체에 새 프로퍼티를 추가할 수 있는지를 결정한다.</li>
</ul>
<h4 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h4><ul>
<li><strong>세 부류의 자바스크립트 객체</strong><ul>
<li><strong>‘네이티브 객체’</strong>는 ECMAScript 명세에 정의된 객체 또는 그 객체의 클래스다. Array, Function, Date, 정규 표현식들은 전부 네이티브 객체다.</li>
<li><strong>‘호스트 객체’</strong>는 브라우저와 같이 자바스크립트 인터프리터가 내장된 호스트 환경에 정의된 객체다.</li>
<li><strong>‘사용자 정의 객체’</strong>는 자바스크립트 코드의 실행으로 생성된 객체다.</li>
</ul>
</li>
<li><strong>두 종류의 프로퍼티</strong><ul>
<li><strong>‘고유 프로퍼티’</strong>는 객체에 직접 정의된 프로퍼티다.</li>
<li><strong>‘상속받은 프로퍼티’</strong>는 객체의 프로토타입 객체가 정의한 프로퍼티를 말한다.</li>
</ul>
</li>
</ul>
<h2 id="61-객체-생성하기"><a href="#6-1-객체-생성하기" class="headerlink" title="6.1 객체 생성하기"></a>6.1 객체 생성하기</h2><p>객체 리터럴을 통해 만들 수도 있고, new 키워드를 사용해 만들 수도 있으며, ECMAScript 5의 Object.create() 함수를 통해서도 생성할 수도 있다.</p>
<h4 id="611-객체-리터럴"><a href="#6-1-1-객체-리터럴" class="headerlink" title="6.1.1 객체 리터럴"></a>6.1.1 객체 리터럴</h4><p><code>객체 리터럴</code>은 평가될 때마다 새로운 객체를 생성하고 초기화하는 표현식이다. 각 프로퍼티의 값 또한 리터럴이 평가될 때마다 새롭게 계산된다. 따라서 하나의 객체 리터럴은 수많은 객체를 만들 수 있다. 객체 리터럴이 반복적으로 호출되는 함수 내부의 루프 몸체에 있는 경우, 매 순간 생기는 객체의 프로퍼티 값들은 서로 다를 것이다.</p>
<h4 id="612-new를-사용해-객체-생성하기"><a href="#6-1-2-new를-사용해-객체-생성하기" class="headerlink" title="6.1.2 new를 사용해 객체 생성하기"></a>6.1.2 new를 사용해 객체 생성하기</h4><p><code>new 연산자</code>는 객체를 만들고, 초기화한다. new 키워드 다음에는 반드시 함수 호출문이 와야한다. 이때 호출되는 함수를 <strong>생성자(constructor)</strong>라고 한다. 새로 생성된 객체를 초기화하는 역할을 한다. 코어 자바스크립트는 기본 타입에 대한 생성자를 내장하고 있다.</p>
<h4 id="613-프로토타입"><a href="#6-1-3-프로토타입" class="headerlink" title="6.1.3 프로토타입"></a><span style="color:red">6.1.3 프로토타입</span></h4><p>자바스크립트의 모든 객체는 또 다른 자바스크립트 객체와 연관되어 있다. 이 두번째 객체는 <code>프로토타입(prototype)</code>으로 알려져있고, 이때 객체는 프로토타입으로부터 프로퍼티들을 상속받는다. 객체 리터럴로 생성된 모든 객체는 프로토타입 객체가 같으며, 자바스크립트 코드에서 이 <strong>프로토타입 객체는 Object.prototype으로 참조할 수 있다.</strong><br>new 키워드를 사용해 생성자를 호출하면, <strong>생성자 함수의 프로토타입이 생성된 객체의 프로토타입이된다.</strong> 따라서 new Object()로 생성된 객체는 {}로 생성된 객체와 마찬가지로 Object.prototype를 상속받는다. 마찬가지로, new Array()로 생성된 객체는 Array.prototype을 객체의 프로토타입으로 사용하고, new Date()로 생성된 객체는 Date.prototype을 객체의 프로토타입으로 사용한다.</p>
<p><strong>모든 내장 생성자는 (그리고 대부분의 사용자 정의 생성자는) Object.prototype을 상속하는 객체를 프로토타입으로 갖는다.</strong> 예를 들어, Date.prototype은 Object.prototype의 프로퍼티들을 상속받는다. 따라서 new Date()를 통해 생성한 Date 객체는 Date.prototype과 Object.prototype으로부터 프로퍼티를 상속받는다. 이처럼 프로토타입 객체들이 연결된 것을 <strong><code>&#39;프로토타입 체인&#39;</code></strong>이라고 한다.</p>
<h4 id="614-objectcreate"><a href="#6-1-4-Object-create" class="headerlink" title="6.1.4 Object.create()"></a>6.1.4 Object.create()</h4><p>ECMAScript 5는 객체를 생성하는 <code>Object.create()</code> 메서드를 지원한다. 이 메서드의 첫 번째 인자가 프로토타입 객체다. Object.create()는 새 객체의 프로퍼티 정보를 두 번째 인자로 받을 수 있는데, 이 인자는 생략할 수 있다.<br><br>Object.create()는 정적 함수로, 개별 객체를 통해 호출되는 메서드가 아니다. 함수를 사용하기 위해서는 단순히 프로토타입 객체를 넘기기만 하면 된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;);           <span class="comment">// o1은 x, y 프로퍼티를 상속받는다.</span></span><br></pre></td></tr></table></figure></p>
<p>프로토타입을 갖지 않는 새 객체를 만들기 위해서는 함수에 null을 전달하면 된다. 하지만 이 경우 새롭게 생성된 객체는 어떠한 객체도 상속받지 않기 때문에 toString() 메서드와 같은 기본적인 메서드조차 사용할 수 없다. 만약 {} 또는 new Object()가 만들어내는 것과 같은 일반적인 빈 객체를 만들고 싶다면, 함수에 Object.prototype을 전달한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);       <span class="comment">// o2은 &#123;&#125; 또는 new Object()와 같은 객체다.</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="62-프로퍼티-접근-및-설정"><a href="#6-2-프로퍼티-접근-및-설정" class="headerlink" title="6.2 프로퍼티 접근 및 설정"></a><span style="color:red">6.2 프로퍼티 접근 및 설정</span></h2><h4 id="621-연관-배열로서의-객체"><a href="#6-2-1-연관-배열로서의-객체" class="headerlink" title="6.2.1 연관 배열로서의 객체"></a><span style="color:red">6.2.1 연관 배열로서의 객체</span></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object[<span class="string">"property"</span>]</span><br></pre></td></tr></table></figure>
<p>위와 같은 형태는 마치 문자열을 인덱스로 갖는 배열에 접근하는 형태와 유사하다. 이러한 형태의 배열을 <strong><code>연관 배열</code></strong>이라고 하고, 해시나 맵, 사전이라고도 한다. <strong>모든 자바스크립트 객체는 연관 배열이다.</strong><br><br>자바스크립트는 C나 C++, 자바에 비해 타입의 제약이 느슨하다. 프로그램은 객체 안에 수많은 프로퍼티들을 만들 수 있다. 하지만 마침표(.) 연산자를 사용해 객체의 프로퍼티에 접근할 때는 프로퍼티의 이름을 반드시 식별자로 표현해야 한다. 식별자는 자바스크립트 프로그램에 직접 타이핑해 넣은 이름이며 자료형이 없으므로 프로그램이 실행되는 도중이 변경할 수 없다.<br><br><strong>반면에 [] 연산자를 사용해 객체의 프로퍼티에 접근할 때는 프로퍼티의 이름을 문자열로 표현한다.</strong> 문자열은 자바스크립트의 자료형이므로 프로그램 실행중에 생성하고 조작할 수 있다. 따라서 다음의 코드가 가능하다. 다음의 코드는 customer 객체의 address0, address1, address2, address3 프로퍼티 값을 읽고, 읽은 값을 addr 변수에 차례대로 이어 붙인다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addr = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  addr += customer[<span class="string">"address"</span> + i] + <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="622-상속"><a href="#6-2-2-상속" class="headerlink" title="6.2.2 상속"></a><span style="color:red">6.2.2 상속</span></h4><p>자바스크립트 객체는 고유 프로퍼티들을 갖고 있고, 동시에 해당 객체의 프로토타입 객체로부터 여러 프로퍼티들을 상속받는다.<br><br>객체 o에서 프로퍼티 x를 찾는다고 했을때, 객체 o가 프로토타입 객체에 고유 프로퍼티 x가 없다면, 해당 프로토타입 객체에서 x를 찾는다. 만약 프로토타입 객체에 고유 프로퍼티 x가 없다면, 해당 프로토타입 객체가 역시 또 다른 프로토타입을 가진 경우, 그 또 다른 프로토타입 객체에서 프로퍼티 x를 찾는다. 이 작업은 프로퍼티 x를 찾거나 prototype이 null인 객체가 발견될 때까지 계속된다. 이처럼 <strong>객체의 prototype 속성은 프로퍼티가 계승되는 체인 또는 연결리스트를 생성한다.</strong><br><br>다음은 객체 o의 프로퍼티 x에 값을 설정하는 경우이다. 객체 o가 상속받지 않은 고유 프로퍼티 x를 갖고 있는 경우에는 기존의 프로퍼티 값을 단순히 바꿀 수 있다. 프로퍼티 x를 갖고 있지않은 경우에는 객체 o에 프로퍼티 x를 만든 후 값을 설정한다. 따라서 만약 객체 o가 프로퍼티 x를 상속받은 상태였다면, 기존에 상속받은 프로퍼티의 x값은 새로 설정되는 값에 의해 가려지게 된다.<br><br>객체의 프로퍼티에 값을 설정할 때는 해당 프로퍼티에 값을 설정할 수 있는지 알아보기 위해 프로토타입 체인을 검사한다. 예를 들어, 객체 o가 상속한 프로퍼티 x가 읽기 전용이라면 해당 프로퍼티에는 값을 설정할 수 없다. 하지만 값 설정이 허용된다면 원래 객체에 새로운 프로퍼티가 만들어지거나 그 값이 설정되며, 프로토타입 체인은 결코 변경되지 않는다. 프로퍼티를 질의 할 때는 상속이 동작하지만 설정할 때는 그렇지 않다는 것은 자바스크립트의 중요한 특징 중 하나다. <strong>계승된 프로퍼티를 선택적으로 재정의 할 수 있기 때문이다.</strong></p>
<h4 id="623-프로퍼티-접근-에러"><a href="#6-2-3-프로퍼티-접근-에러" class="headerlink" title="6.2.3 프로퍼티 접근 에러"></a><span style="color:red">6.2.3 프로퍼티 접근 에러</span></h4><p>프로퍼티 접근 표현식을 사용해도 항상 값을 얻을 수 있거나 값을 설정할 수 있는 것은 아니다.<br><br>존재하지 않는 프로퍼티에는 접근해도 에러가 발생하지 않는다. 존재하지 않는 프로퍼티는 <strong>undefined</strong>로 평가된다. 하지만 <strong>존재하지 않는 객체의 프로퍼티에 접근하려고 하면 에러가 발생한다.</strong> null과 undefined 값은 어떠한 프로퍼티도 갖지 않기 때문에 이들 값에 프로퍼티로 접근을 시도하면 에러가 발생한다.</p>
<hr>
<h2 id="63-프로퍼티-삭제하기"><a href="#6-3-프로퍼티-삭제하기" class="headerlink" title="6.3 프로퍼티 삭제하기"></a>6.3 프로퍼티 삭제하기</h2><p><code>delete</code> 연산자는 객체의 프로퍼티를 삭제한다. 이 연산자는 프로퍼티의 값을 지우는 것이 아니라 프로퍼티를 지운다. delete 연산자는 상속받은 프로퍼티가 아닌 <strong>고유 프로퍼티만</strong> 지울 수 있다. (상속받은 프로퍼티를 지우기 위해서는 해당 프로퍼티가 정의된 프로토타입 객체에서 지워야 하고, 삭제에 성공하면 프로토타입 객체를 상속한 모든 객체가 영향을 받는다.) <br></p>
<hr>
<h2 id="64-프로퍼티-검사하기"><a href="#6-4-프로퍼티-검사하기" class="headerlink" title="6.4 프로퍼티 검사하기"></a>6.4 프로퍼티 검사하기</h2><p><code>in</code> 연산자 왼쪽에는 프로퍼티 이름이 문자열로 와야하고 오른쪽에는 개체가 와야한다. 객체에 해당 프로퍼티가 존재하면 true가 반환된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;           <span class="comment">// 객체 o에 고유 프로퍼티 x가 존재하므로 true를 반환한다.</span></span><br><span class="line"><span class="string">"toString"</span> <span class="keyword">in</span> o;    <span class="comment">// 객체 o에 상속받은 프로퍼티 toString가 있기 때문에 true를 반환한다.</span></span><br></pre></td></tr></table></figure></p>
<p>객체의 <code>hasOwnProperty()</code> 메서드는 주어진 이름의 프로퍼티가 객체에 존재하는지 검사한다. 상속받은 프로퍼티의 경우는 false를 반환한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">o.hasOwnProperty(<span class="string">"x"</span>);           <span class="comment">// 객체 o에 고유 프로퍼티 x가 존재하므로 true를 반환한다.</span></span><br><span class="line">o.hasOwnProperty(<span class="string">"toString"</span>);    <span class="comment">// toString은 상속받은 프로퍼티이기 때문에 false를 반환한다.</span></span><br></pre></td></tr></table></figure></p>
<p><code>propertyIsEnumerable()</code> 메서드는 hasOwnProperty()보다 상세한 검사를 한다.<br><br>undefined가 아니지만 확인할 때는 in 연산자 대신 논리 연산자 !==를 사용하는 편이 훨씬 효과적이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">o.x !== <span class="literal">undefined</span>;          <span class="comment">// true: 객체 o에 프로퍼티 x가 존재한다.</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>;          <span class="comment">// false: 객체 o에 프로퍼티 y가 존재하지 않는다.</span></span><br></pre></td></tr></table></figure></p>
<p>in 연산까지 사용하면 객체에 프로퍼티가 존재하지 않는 경우와 객체에 프로퍼티가 존재하지만 값이 undefined인 경우를 구별할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="literal">undefined</span> &#125;    <span class="comment">// 프로퍼티가 분명히 존재하지만 값이 undefined다.</span></span><br><span class="line">o.x !== <span class="literal">undefined</span>           <span class="comment">// false: 프로퍼티가 존재하지만 값이 undefined다.</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>           <span class="comment">// false: 프로퍼티가 존재하지 않는다.하지만 값이 undefined다.</span></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o                    <span class="comment">// true: 프로퍼티가 존재한다.</span></span><br><span class="line"><span class="string">"y"</span> <span class="keyword">in</span> o                    <span class="comment">// false: 프로퍼티가 존재하지 않는다.</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="65-프로퍼티-열거하기"><a href="#6-5-프로퍼티-열거하기" class="headerlink" title="6.5 프로퍼티 열거하기"></a>6.5 프로퍼티 열거하기</h2><p>객체가 가진 모든 프로퍼티들을 순회하고 싶을 때는 보통 <code>for/in</code> 루프토 해결한다.<br>지정한 객체가 가진 고유 프로퍼티 또는 상속된 프로퍼티들 중 열거 가능한 프로퍼티들마다 for/in 루프의 몸체가 실행된다. 상속받은 내장 메서드는 열거할 수 없지만, 사용자가 임의로 추가한 프로퍼티들은 열거할 수 있다.(임의로 열거할 수 없도록 설정하는 함수를 사용할 수도 있다.)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">z</span>:<span class="number">3</span> &#125;               <span class="comment">// 열거할 수 있는 3개의 고유 프로퍼티</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">"toString"</span>);     <span class="comment">// =&gt; false: toString은 열거할 수 없는 프로퍼티</span></span><br><span class="line"><span class="keyword">for</span>(p <span class="keyword">in</span> o)                             <span class="comment">//  객체 o의 모든 프로퍼티에 대해</span></span><br><span class="line">  <span class="built_in">console</span>.log(p);                       <span class="comment">// 프로퍼티 이름을 출력. 결과는 x, y, z가 출력</span></span><br><span class="line">                                        <span class="comment">//  toString은 출력되지 않는다.</span></span><br></pre></td></tr></table></figure></p>
<p>for/in 루프 말고도 ECMAScript 5에는 프로퍼티 이름을 열거하는 두가지 함수가 더 있다.</p>
<ol>
<li><code>Object.keys()</code> : 객체가 가진 <strong>고유 프로퍼티</strong> 중에 열거할 수 있는 프로퍼티 이름을 배열에 담아 반환한다.</li>
<li><code>Object.getOwnPropertyNames()</code> : 프로퍼티를 열거하는 함수다. Object.keys()는 객체가 가진 ‘열거할 수 있는’ 고유 프로퍼티들을 배열에 담아 반환하지만, Object.getOwnPropertyNames()는 해당 객체가 가진 <strong>모든 고유 프로퍼티</strong>의 이름을 배열로 반환한다.</li>
</ol>
<hr>
<h2 id="66-프로퍼티-getter와-setter"><a href="#6-6-프로퍼티-Getter와-Setter" class="headerlink" title="6.6 프로퍼티 Getter와 Setter"></a>6.6 프로퍼티 Getter와 Setter</h2><p>ECMAScript 5에서 프로퍼티의 값은 <code>getter/setter</code> 메서드로 대채할 수 있다. getter/setter 메서드로 정의된 프로퍼티는 단순히 값을 갖는 ‘데이터 프로퍼티’와는 다른 <strong><code>&#39;접근자 프로퍼티&#39;</code></strong>라고 한다.<br><br>프로그램이 객체의 접근자 프로퍼티의 값에 접근하면, 자바스크립트 엔진은 <strong>getter</strong> 메서드를 아무런 인자없이 호출하고 이때 반환 값이 프로퍼티 접근 표현식의 값이 된다. 프로그램이 프로퍼티의 값을 변경하려고 하면, 자바스크립트 엔진은 <strong>setter</strong> 메서드를 호출한다. 이때 할당자(=)의 오른쪽에 있는 값을 setter 메서드의 인자로 전달한다. setter 메서드는 프로퍼티의 값을 ‘설정’하는 것을 담당하고, 그 반환값은 무시된다.<br><br>데이터 프로퍼티가 writable(쓰기) 속성을 갖는 반면, 접근자 프로퍼티는 쓰기 속성이 없다. 만약 프로퍼티가 getter/setter 메서드를 모두 갖고 있으면, 읽기/쓰기 모두 가능한 프로퍼티인 것이고, 프로퍼티가 getter 메서드만 갖고 있다면, 읽기 전용 프로퍼티인 것이다. 프로퍼티가 setter 메서드만 갖고 있으면 쓰기 전용 프로퍼티고, 이때 읽기를 시도하면 항상 undefined가 반환된다.<br>접근자 프로퍼티는 다음과 같이 확장된 객체 리터럴 문법을 사용하여 쉽게 정의할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="comment">// 데이터 프로퍼티</span></span><br><span class="line">  data_prop: value,</span><br><span class="line">  <span class="comment">// 한 쌍의 함수로 정의된 접근자 프로퍼티</span></span><br><span class="line">  get accessor_prop() &#123; <span class="comment">/* 함수 몸체 */</span> &#125;,</span><br><span class="line">  set accessor_prop(value) &#123; <span class="comment">/* 함수 몸체 */</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>접근자 프로퍼티는 그 이름이 프로퍼티 이름과 같은 하나 또는 두 개의 함수이며, 함수 정의에 사용되는 function 키워드 대신 get/set을 사용한다.</strong><br>자바스크립트는 getter/setter 함수를 객체의 메서드로서 호출한다. 이는 함수의 몸체 안에 사용된 this 키워드가 객체 자신을 가리킨다는 뜻이다. 접근자 프로퍼티는 데이터 프로퍼티와 마찬가지로 상속할 수 있다.</p>
<hr>
<h2 id="67-프로퍼티-속성"><a href="#6-7-프로퍼티-속성" class="headerlink" title="6.7 프로퍼티 속성"></a>6.7 프로퍼티 속성</h2><p>프로퍼티에는 프로퍼티로 할 수 있는 작업을 결정하는 세 가지 속성이 있다.</p>
<ul>
<li><strong>writable</strong> : 프로퍼티 값의 변경 가능 여부를 결정</li>
<li><strong>enumerable</strong> : 프로퍼티가 열거될 수 있는지 여부를 결정</li>
<li><strong>configurable</strong> : configurable 속성뿐 아니라 writable 속성과 enumerable 속성 값의 변경 가능 여부를 결정</li>
</ul>
<p>접근자 프로퍼티의 getter/setter 메서드를 프로퍼티가 가진 속성으로 다룬다면 접근자 프로퍼티의 네 가지 속성은 <strong>get, set, enumerable, configurable</strong>이다.<br>ECMAScript 5에서는 프로퍼티의 속성 값을 질의하고, 값을 설정할 수 있는 <code>프로퍼티 디스크립터</code>라는 객체를 제공한다. 이 객체의 프로퍼티 이름은 표현 대상 속성의 이름과 같다.</p>
<ul>
<li>데이터 프로퍼티의 프로퍼티 디스크립터 객체의 프로퍼티 : value, writable, enumerable, configurable</li>
<li>접근자 프로퍼티의 프로퍼티 디스크립터 객체의 프로퍼티 : get, set, enumerable, configurable<br>객체가 가진 특정 프로퍼티에 대한 프로퍼티 디스크립터 객체는 <code>Object.getOwnPropertyDescriptor()</code>를 통해 얻을 수 있다. (Object.getOwnPropertyDescriptor()는 객체의 고유 프로퍼티에서만 동작한다.)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; value: 1, writable: true, enumerable:true, configurable:true &#125;를 반환한다.</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125; <span class="string">"x"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>프로퍼티의 속성을 설정하거나 임의의 속성으로 새 프로퍼티를 만들기 위해서는 <code>Object.defineProperty()</code>를 호출한다. 함수의 인자로, 수정할 객체와 추가하거나 변경할 프로퍼티 이름, 프로퍼티의 디스크립터 객체를 넘긴다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, &#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">configurable</span>:<span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>6.1 절에 있었던 ECMAScript 5 메서드인 Object.create() 메서드의 첫 번째 인자로는 새로 생성할 객체의 프로토타입 객체이며, 두 번째 선택 인자는 Object.defineProperty() 의 두 번째 인자와 같다. 이 두 번째 인자는, 생성된 객체에 프로퍼티로 추가된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.getOwnPropertyDescriptor()와 Object.defineProperty() 메서드를 사용하여 프로퍼티가 가진 속성까지 복사하는 extend() 함수</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Object.prototype에 열거되지 않는 메서드 extend()를 추가한다.</span></span><br><span class="line"><span class="comment">// 이 메서드는 호출 시에 인자로 전달된 객체에서 프로퍼티들을 복사하여 객체를 확장한다.</span></span><br><span class="line"><span class="comment">// 단순 프로퍼티의 값뿐 아니라 모든 프로퍼티 속성을 복사한다.</span></span><br><span class="line"><span class="comment">// 인자로 넘긴 객체가 소유한 모든 고유 프로퍼티는 대상 객체에 같은 이름의</span></span><br><span class="line"><span class="comment">// 프로퍼티가 존재하지 않는 한 대상 객체에 복사된다.</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype,</span><br><span class="line">  <span class="string">"extend"</span>,       <span class="comment">// Object.prototype.extend를 정의한다.</span></span><br><span class="line">  &#123;</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,      <span class="comment">// 열거 불가능</span></span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Object.prototype.extend 메서드의 값은 함수다.</span></span><br><span class="line">      <span class="comment">// 열거되지 않는 프로퍼티들을 포함한 고유 프로퍼티에 대해</span></span><br><span class="line">      <span class="keyword">var</span> names = <span class="built_in">Object</span>.getOwnPropertyNames(o);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.length; i ++) &#123;</span><br><span class="line">        <span class="comment">// this 객체에 이미 같은 이름의 프로퍼티가 존재하면 건너뛴다.</span></span><br><span class="line">        <span class="keyword">if</span> (names[i] <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 객체 o의 프로퍼티 디스크립터를 가져온다.</span></span><br><span class="line">        <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, names[i]);</span><br><span class="line">        <span class="comment">// this 객체에 프로퍼티를 생성할 때 앞에서 가져온 디스크립터 객체를 사용한다.</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, name[i], desc);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="68-객체-속성"><a href="#6-8-객체-속성" class="headerlink" title="6.8 객체 속성"></a>6.8 객체 속성</h2><p>모든 객체는 <strong>prototype, class, extensible 속성</strong>을 갖고 있다.</p>
<h4 id="681-prototype-속성"><a href="#6-8-1-prototype-속성" class="headerlink" title="6.8.1 prototype 속성"></a>6.8.1 prototype 속성</h4><p>prototype 속성은 객체가 만들어지는 시점에 설정된다. <code>객체 리터럴</code>을 통해 만든 객체는 Object.prototype을 객체의 프로토타입으로 설정하고, <code>new</code>를 사용해 만든 객체는 생성자 함수의 prototype 프로퍼티값이 prototype이 된다. <code>Object.create()</code> 메서드로 만든 객체는 메서드의 첫 번째 인자가 프로토타입 속성의 값이 된다.<br>객체 A가 객체 B의 프로토타입(또는 프로토타입 체인의 일부)인지 알아보기 위해서는 <code>isPrototypeOf()</code> 메서드를 사용한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(p);</span><br><span class="line">p.isPrototypeOf(o)                    <span class="comment">// =&gt; true: 객체 o는 객체 p를 상속받는다.</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(p)     <span class="comment">// =&gt; true: 객체 p는 Object.prototype을 상속받는다.</span></span><br></pre></td></tr></table></figure></p>
<h4 id="682-class-속성"><a href="#6-8-2-class-속성" class="headerlink" title="6.8.2 class 속성"></a>6.8.2 class 속성</h4><p><strong>객체의 class 속성은 객체의 타입에 대한 정보를 담고 있는 문자열이다.</strong><br>Object.prototype으로부터 상속되는 기본(default) <code>toString()</code> 메서드는 객체의 타입을 아래 형태의 문자열로 반환한다.<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[object class]</span><br></pre></td></tr></table></figure></p>
<p>따라서 객체의 클래스 정보를 알아보기 위해서는 객체의 toString() 메서드를 호출하면 된다.</p>
<h4 id="683-extensible-속성"><a href="#6-8-3-extensible-속성" class="headerlink" title="6.8.3 extensible 속성"></a>6.8.3 extensible 속성</h4><p><strong>객체의 extensible 속성은 객체에 새 프로퍼티를 추가할 수 있는지 여부를 결정한다.</strong> extensible 속성의 목적은 ‘잠겨있는’ 객체의 상태를 고정하고, 외부에서 변경하는 것을 막는 것이다. ECMAScript 5에서는 모든 내장 객체와 사용자 정의 객체는 확장할 수 없게 바뀌지 않는한 확장 가능하고, 호스트 객체의 확장성은 구현체에 따라 다르다.<br>확장할 수 있는 객체인지 알아보려면 <code>object.isExtensible()</code> 함수에 해당 객체를 인자로 넘긴다. 객체를 확장할 수 없도록 하려면, <code>Object.preventExtensions()</code>에 해당 객체를 인자로 넘긴다. 해당함수를 사용하면 전 상태로 돌아갈 수 없다. 또한 extensible 속성 값이 false인 객체라도, 프로토타입에 새 프로퍼티를 추가하면, 추가된 프로퍼티는 해당 객체에 상속된다.</p>
<hr>
<h2 id="69-객체-직렬화하기"><a href="#6-9-객체-직렬화하기" class="headerlink" title="6.9 객체 직렬화하기"></a><span style="color:red">6.9 객체 직렬화하기</span></h2><p><strong>객체 직렬화는 객체의 상태를 문자열로 변환하는 과정을 말한다.</strong> ECMAScript 5는 자바스크립트 객체를 직렬화하는 <code>JSON.stringify()</code> 메서드와 직렬화한 문자열을 객체로 복원하는 <code>JSON.parse()</code> 메서드를 지원한다. 이 두 함수는 JSON 데이터 교환 형식을 사용한다. <strong>JSON</strong>은 ‘JavaScript Object Notation’의 줄임 표현이다.<br>JSON 문법은 자바스크립트 문법의 부분 집합이기 때문에, 자바스크립트의 모든 값을 표현할 수는 없다. Function, RegExp, Error 객체와 undefined 값은 직렬화하거나 복원할 수 없다. <strong>JSON.stringify() 메서드는 객체가 가진 열거 가능한 고유 프로퍼티만 직렬화한다.</strong></p>
<hr>
<h2 id="610-객체-메서드"><a href="#6-10-객체-메서드" class="headerlink" title="6.10 객체 메서드"></a><span style="color:red">6.10 객체 메서드</span></h2><p>모든 자바스크립트 객체는 <strong>Object.prototype</strong>의 프로퍼티를 상속받는다. 상속된 프로퍼티들은 대부분 메서드이고, 어느 객체에서도 사용할 수 있기 때문에 주요 메서드라고 할 수 있다.</p>
<h4 id="6101-tostring-메서드"><a href="#6-10-1-toString-메서드" class="headerlink" title="6.10.1 toString() 메서드"></a><span style="color:red">6.10.1 toString() 메서드<span></span></span></h4><p><code>toString()</code> 메서드는 어떠한 인자도 받지 않고, <strong>호출 대상 객체의 값을 어떠한 방식으로든 문자열로 만들어서 반환한다.</strong> 자바스크립트는 객체를 문자열로 변환해야 할 때 항상 toString() 메서드를 사용한다.</p>
<h4 id="6103-tojson-메서드"><a href="#6-10-3-toJSON-메서드" class="headerlink" title="6.10.3 toJSON() 메서드"></a><span style="color:red">6.10.3 toJSON() 메서드<span></span></span></h4><p>Object.prototype에는 toJSON() 메서드가 정의되어 있지 않다. 하지만 JSON.stringify() 메서드는, 직렬화할 객체에 toJSON() 메서드가 있는지 찾고, 만약 있다면, toJSON() 메서드가 호출되고 그 결과 값이 원래 객체 대신 직렬화된다.</p>
<h4 id="6104-vluaeof-메서드"><a href="#6-10-4-vluaeOf-메서드" class="headerlink" title="6.10.4 vluaeOf() 메서드"></a><span style="color:red">6.10.4 vluaeOf() 메서드<span></span></span></h4><p>valueOf() 메서드는 toString() 메서드와 매우 비슷하다. 이 메서드는 <strong>객체가 원시 타입 값을 필요로 하는 문맥 안에서 사용될 때</strong>, 자바스크립트는 valueOf() 메서드를 자동으로 호출한다.</p>
<p><br><br><strong>출처 : <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10338797" rel="external nofollow noopener noreferrer" target="_blank">“JavaScript: The Definitive Guide, by David Flanagan (O’Reilly). Copyright 2011 David Flanagan, 978-0-596-80552-4”</a></strong></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2017-01-27T17:10:32.000Z">2017-01-28</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    38분 읽기 (대략 5708 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2017/01/28/JavaScript/complete-guide-to-javascript-chapter-7/">자바스크립트 완벽가이드 7장 (배열)</a>
            
        </h1>
        <div class="content">
            <p>자바스크립트의 배열은 타입이 고정되어 있지 않다. 같은 배열에 있는 원소 값의 타입은 서로 다를 수 있다. 배열의 원소는 객체가 될 수도 있고, 또 다른 배열이 될 수도 있다. 자바스크립트 배열은 <strong>동적</strong>이다. 배열의 크기가 필요에 따라 커지거나 작아질 수 있다. 배열을 생성하거나, 크기가 변경되어 다시 할당을 할 때도 배열 크기를 선언할 필요가 없다. 자바스크립트 배열은 밀집도가 높지 않고, 각 원소의 인덱스가 연속적이지 않아도 되고, 원소들 사이에 빈자리가 있어도 된다. 자바스크립트 배열에는 length 프로퍼티가 존재한다.<br><strong>자바스크립트 배열은 자바스크립트 객체의 특별한 형태이고, 배열의 인덱스는 프로퍼티 이름인데 정수인 것이다.</strong> 일반적으로 배열은 객체 프로퍼티를 통해 원소에 접근하는 것보다 <strong>정수 첨자</strong>를 통해 원소에 접근하는 것이 훨씬 빠르도록 최적화 되어 있다.<br>배열은 <code>Array.prototype</code>의 프로퍼티들을 상속받는다.</p>
<h2 id="71-배열-만들기"><a href="#7-1-배열-만들기" class="headerlink" title="7.1 배열 만들기"></a>7.1 배열 만들기</h2><p>배열을 만드는 가장 쉬운 방법은 <code>배열 리터럴</code>을 사용하는 것이다. 배열 리터럴은 대괄호([,])안에 배열의 원소를 쉼표(,)로 구분해 나열한 것이다.<br>만약 배열 리터럴은 객체 리터럴 또는 다른 배열 리터럴을 포함할 수 있다.  만약 배열 리터럴에서 빠진 부분이 있다면 해당 부분의 원소 값은 <strong>undefined</strong>가 된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> undefs = [,,];    <span class="comment">// 두 원소 모두 값은 undefined (배열 리터럴의 문법은 마지막 원소 다음에 쉼표 추가 가능)</span></span><br></pre></td></tr></table></figure></p>
<p>배열을 만드는 또 다른 방법은 <code>Array() 생성자</code>를 이용하는 것이다. 생성자는 3가지 방법으로 호출 가능하다.<br>– <strong>인자 없이 호출</strong><br>빈 배열을 생성하고 생성된 배열은 배열 리터럴 []과 동일하다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure></p>
<p>– <strong>배열의 길이를 의미하는 숫자를 인자로 주어 호출</strong><br>배열에 저장될 원소의 크기를 알고, 미리 공간을 할당할 때 사용한다. 배열에는 어떠한 값도 저장되지 않고, 배열의 인덱스 프로퍼티 값(“0”, “1” …)도 존재하지 않는다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>– <strong>두 개 이상의 원소, 또는 숫자가 아닌 원소 값 하나를 명시적으로 지정</strong><br>생성자의 인자 값들이 배열의 원소가 된다. 리터럴을 사용하는편이 훨씬 더 간단하다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">"test"</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="72-배열의-원소-읽고-쓰기"><a href="#7-2-배열의-원소-읽고-쓰기" class="headerlink" title="7.2 배열의 원소 읽고 쓰기"></a>7.2 배열의 원소 읽고 쓰기</h2><p>배열의 각 원소에 접근할 때에는 <code>[] 연산자</code>를 사용한다. <strong>배열은 객체의 특별한 종류이다.</strong> 배열의 [] 구문은 객체 프로퍼티 접근 때 쓰는 []와 똑같이 동작한다. 자바스크립트는 사용자가 명시한 숫자 배열 인덱스를 문자열 형태로 바꿔서 프로퍼티 이름으로 사용한다.<br><strong>배열의 인덱스와 객체 프로퍼티 이름을 올바르게 구별할 줄 알면 좋다.</strong> 모든 인덱스 값은 프로퍼티 이름이지만, 프로퍼티 이름은 0과 2의32승-1 사이의 정수여야만 인덱스가 될 수 있다. 모든 배열은 객체이므로, 어떤 이름의 프로퍼티라도 자유롭게 만들 수 있다. 하지만 배열에는, 프로퍼티 가운데 인덱스인 것들을 사용하면 <code>length</code> 프로퍼티의 값이 자동으로 갱신되는 특별한 기능도 갖추어져 있다.(배열이 일반 객체와 다른 점은 속성 이름으로 2의32승보다 작은 양수를 사용할 때, 자동으로 length 프로퍼티의 값을 바꾼다는 것이다.) 배열 첨자로 양의 정수가 담긴 문자열을 사용하면, 일반적으로 프로퍼티가 아닌 배열 인덱스로 쓰인다. (소수점 아래가 없는 부동 소수점 값도 마찬가지) 반면에 음수나, 정수 아닌 수들을 사용하면 숫자는 문자열로 변환되고, 변환된 문자열은 배열 객체의 프로퍼티 이름으로 사용된다.<br>객체에 존재하지 않는 프로퍼티 이름을 질의하면, 에러가 발생하지 않고 단순히 <strong>undefined</strong>값이 반환된다. 이러한 성질은 배열에도 적용된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="literal">true</span>, <span class="literal">false</span>];    <span class="comment">// 두 개의 원소를 가진 배열을 생성한다.</span></span><br><span class="line">a[<span class="number">2</span>]                  <span class="comment">// =&gt; undefined. 해당 인덱스에 원소가 없어서.</span></span><br><span class="line">a[<span class="number">-1</span>]                 <span class="comment">// =&gt; undefined. '-1'이라는 속성 이름에 해당하는 값이 없어서.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>모든 배열은 객체다.</strong> 따라서 배열은 객체의 프로토타입으로부터 원소들을 상속 받을 수 있다.</p>
<hr>
<h2 id="73-희소배열"><a href="#7-3-희소배열" class="headerlink" title="7.3 희소배열"></a>7.3 희소배열</h2><p><code>희소배열</code>은 배열에 속한 원소의 위치가 연속적이지 않은 배열을 말한다. 보통, 배열의 length 프로퍼티는 배열에 속한 원소의 개수를 의미한다. 그러나 희소배열의 경우, length 프로퍼티의 값은 원소의 개수보다 항상 크다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);      <span class="comment">// 원소가 없는 배열이지만 a.length의 값은 5다.</span></span><br><span class="line">a = [?];               <span class="comment">// length 값이 0인 빈 배열을 생성한다.</span></span><br><span class="line">a[<span class="number">1000</span>] = <span class="number">0</span>;           <span class="comment">// 하나의 원소를 할당했지만, length 값은 1001이 된다.</span></span><br></pre></td></tr></table></figure></p>
<p>희소배열은 보통배열보다 일반적으로 느리고, 메모리를 많이 사용할 뿐 아니라, 원소를 찾는데 걸리는 시간이 일반 객체의 속성 값을 찾는 시간만큼 오래 걸린다.<br>배열 리터럴 사용 시 값을 명시하지 않는 방법으로는 희소배열을 만들 수 없다. 해당 원소의 값이 <strong>undefined</strong>가 되기 때문이다. 이는 배열에 원소가 아예 존재하지 않는 것과는 다르다. in 연산자를 사용하면 두 경우의 차이점을 알 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = [,,,];          <span class="comment">// 세 개의 원소가 undefined인 배열</span></span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);   <span class="comment">// 원소가 존재하지 않는 배열</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a1                  <span class="comment">// =&gt; true: a1에는 0번 인덱스 위치에 원소가 존재한다.</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a2                  <span class="comment">// =&gt; false: a2에는 0번 인덱스 위치에 원소가 존재하지 않는다.</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="74-배열의-길이"><a href="#7-4-배열의-길이" class="headerlink" title="7.4 배열의 길이"></a>7.4 배열의 길이</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];    <span class="comment">// 다섯 개의 원소를 가진 배열</span></span><br><span class="line">a.length = <span class="number">3</span>;       <span class="comment">// length를 3으로 바꿨기 때문에 결과는 [1,2,3]</span></span><br><span class="line">a.length = <span class="number">0</span>;       <span class="comment">// length 값이 0이기 때문에 모든 element를 삭제, 결과는 []</span></span><br><span class="line">a.length = <span class="number">5</span>;       <span class="comment">// length 값은 5이지만, 원소가 없다. new Array(5)와 같은 결과</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="75-배열에-원소를-추가하거나-삭제하기"><a href="#7-5-배열에-원소를-추가하거나-삭제하기" class="headerlink" title="7.5 배열에 원소를 추가하거나 삭제하기"></a>7.5 배열에 원소를 추가하거나 삭제하기</h2><p>배열에 원소를 <strong>추가</strong>하는 방법</p>
<ul>
<li>배열의 새 인덱스에 값을 할당한다.</li>
<li>push() 메서드를 사용해 배열의 끝에 원소를 추가한다. (a[a.length]에 값을 할당하는것과 같다.)</li>
<li>unshift() 메서드를 사용하면 배열의 앞쪽에 원소를 추가할 수 있다.</li>
</ul>
<p>배열에 원소를 <strong>삭제</strong>하는 방법</p>
<ul>
<li>delete 연산자로 배열의 원소를 삭제할 수 있다. (배열의 length는 줄어들지 않는다.)</li>
<li>pop() 메서드를 사용해 배열의 앞에서 원소를 삭제한다.</li>
</ul>
<p>배열의 특정 원소를 지우는 것은, 해당 원소에 <strong>undefined</strong> 값을 할당하는 것과 의미가 비슷하다. 원소가 지워지더라도 생기는 공백을 다른 원소가 대신하지 않으며, 해당 배열은 희소배열이 된다.</p>
<hr>
<h2 id="76-배열-순회하기"><a href="#7-6-배열-순회하기" class="headerlink" title="7.6 배열 순회하기"></a>7.6 배열 순회하기</h2><p>ECMAScript 5에는 배열을 순회하는 다양한 메서드가 추가되었다. 사용자가 정의한 함수에 배열의 원소가 <strong>인덱스 순서</strong>대로 하나씩 넘어오도록 하여 배열을 순회하는 형태다. <code>forEach()</code> 메서드가 대표적이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sumOfSquares = <span class="number">0</span>;</span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)) </span>&#123;</span><br><span class="line">    sumOfSquares += x*x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>배열을 다룰 때 forEach() 같은 순회 메서드는 간단하고 강력한 함수형 프로그래밍 스타일을 사용할 수 있게 한다.</p>
<hr>
<h2 id="77-다차원-배열"><a href="#7-7-다차원-배열" class="headerlink" title="7.7 다차원 배열"></a>7.7 다차원 배열</h2><p>자바스크립트는 진정한 의미에서의 다차원 배열을 지원하지는 않는다. 그러나 배열의 배열을 사용해 다차원 배열을 흉내 낼 수 있다. 배열 내의 배열에 있는 원소에 접근하기 위해서는 단순히 [] 연산자를 두 번 사용하면 된다.</p>
<hr>
<h2 id="78-배열-메서드"><a href="#7-8-배열-메서드" class="headerlink" title="7.8 배열 메서드"></a><span style="color:red">7.8 배열 메서드</span></h2><h4 id="781-join"><a href="#7-8-1-join" class="headerlink" title="7.8.1 join()"></a><span style="color:red">7.8.1 join()</span></h4><p><code>Array.join()</code> 메서드는 배열의 모든 원소를 문자열로 변환하고, 변환한 문자들을 이어 붙인 결과를 반환한다. 결과로 반환되는 문자열에서 배열의 원소들을 구별하기 위해 <strong>구분자 문자열</strong>을 사용한다. 별도로 구분자 문자열을 지정하지 않으면 쉼표(,)가 기본 값으로 사용된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.join();                   <span class="comment">// =&gt; '1,2,3'</span></span><br><span class="line">a.join(<span class="string">" "</span>);                <span class="comment">// =&gt; '1 2 3'</span></span><br><span class="line">a.join(<span class="string">""</span>);                 <span class="comment">// =&gt; '123'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);     <span class="comment">// 길이가 10인 빈 배열</span></span><br><span class="line">b.join(<span class="string">'-'</span>)                <span class="comment">// =&gt; '---------': 아홉 개의 하이픈 문자열</span></span><br></pre></td></tr></table></figure></p>
<p>Array.join() 메서드는 String.split() 메서드와는 반대로 작동한다. <code>String.split()</code> 메서드는 문자열을 조각들로 분리하고, 이 조각들을 원소로 하는 배열을 생성한다.</p>
<h4 id="782-reverse"><a href="#7-8-2-reverse" class="headerlink" title="7.8.2 reverse()"></a><span style="color:red">7.8.2 reverse()</span></h4><p><code>Array.reverse()</code> 메서드는 배열의 원소 순서를 반대로 뒤집어 반환한다. 순서가 뒤바뀐 새로운 배열을 생성하는 것이 아니라, <strong>이미 존재하는</strong> 배열 안에서 원소들의 순서를 뒤바꾼다.</p>
<h4 id="783-sort"><a href="#7-8-3-sort" class="headerlink" title="7.8.3 sort()"></a><span style="color:red">7.8.3 sort()</span></h4><p><code>Array.sort()</code> 메서드는 배열 안의 원소들을 정렬하여 반환한다. sort() 메서드는 별도의 인자전달 없이 호출하면, 배열 안의 원소들을 알파벳순으로 정렬한다. 배열에 undefined 원소들이 존재하면, 이 원소들은 배열의 끝부분으로 정렬된다.<br>알파벳순이 아니라 다른 순서로 배열을 정려하려면, sort() 메서드의 전달 인자를 통해 비교 함수를 직접 명시해주어야 한다. 비교 함수는 전달인자를 두 개 받아서, 정렬된 배열에서 어떤 것이 먼저 나타나야 하는지 판단한다. <strong>만약 첫 번 째 인자가 두 번째보다 먼저 나타나야 한다면, 비교 함수는 0보다 작은 숫자를 반환해야 한다.</strong> 만약 두 값이 동등하다면 0을 반환해야 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">33</span>, <span class="number">4</span>, <span class="number">1111</span>, <span class="number">222</span>];</span><br><span class="line">a.sort();                     <span class="comment">// 알파벳순: 1111, 222, 33, 4</span></span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;       <span class="comment">// 번호순: 4, 33, 222, 1111</span></span><br><span class="line">    <span class="keyword">return</span> a-b;               <span class="comment">// 0보다 작은 값, 0, 또는 0보다 큰 값을 반환한다.</span></span><br><span class="line">&#125;);</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;<span class="keyword">return</span> b-a&#125;); <span class="comment">// 내림차순 정렬</span></span><br></pre></td></tr></table></figure></p>
<h4 id="784-concat"><a href="#7-8-4-concat" class="headerlink" title="7.8.4 concat()"></a><span style="color:red">7.8.4 concat()</span></h4><p><code>Array.concat()</code> 메서드는 기존 배열의 모든 원소에 concat() 메서드의 전달인자들을 추가한 <strong>새로운 배열을 반환</strong>한다. 전달인자로 배열을 전달하면, 이 배열안의 원소들을 꺼내어 반환하는 배열에 추가한다. 하지만 중첩 배열일 경우에는 중첩된 배열의 원소까지는 꺼내지 않는다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.concat(<span class="number">4</span>, <span class="number">5</span>);                   <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>, <span class="number">5</span>]);                 <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>]);         <span class="comment">// [1,2,3,4,5,6,7]</span></span><br><span class="line">a.concat(<span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]]);         <span class="comment">// [1,2,3,4,5, [6,7]]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="785-slice"><a href="#7-8-5-slice" class="headerlink" title="7.8.5 slice()"></a><span style="color:red">7.8.5 slice()</span></h4><p><code>Array.slice()</code> 메서드는 <strong>부분 배열을 반환</strong>한다. 부분 배열은 배열에서 잘라낸 원소들을 담은 <strong>새 배열</strong>이다. slice() 메서드는 전달인자를 두 개 받는데, 각 인자는 <strong>반환될 부분의 처음</strong>과 <strong>끝</strong>을 명시한다. 반환되는 배열은 첫 번째 전달인자가 지정하는 위치부터 두 번째 전달인자가 지정하는 위치 이전까지의 모든 원소를 포함한다. 만약 전달인자가 하나라면 그 위치에서 배열 끝까지의 모든 원소를 포함하는 부분 배열을 반환한다. 만약 전달인자가 음수라면, 배열의 마지막 원소에서부터의 상대적인 위치를 가리키는 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.slice(<span class="number">0</span>, <span class="number">3</span>);         <span class="comment">// [1,2,3]</span></span><br><span class="line">a.slice(<span class="number">3</span>);            <span class="comment">// [4,5]</span></span><br><span class="line">a.slice(<span class="number">1</span>, <span class="number">-1</span>);        <span class="comment">// [2,3,4]</span></span><br><span class="line">a.slice(<span class="number">-3</span>, <span class="number">-2</span>);       <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="786-splice"><a href="#7-8-6-splice" class="headerlink" title="7.8.6 splice()"></a><span style="color:red">7.8.6 splice()</span></h4><p><code>Array.splice()</code> 메서드는 배열의 원소를 삽입하거나 원소를 제거하려 할 때 범용적으로 사용하는 메서드다. splice() 메서드는 slice()나 concat() 메서드와는 달리 <strong>호출 대상 배열을 바로 수정</strong>한다.<br>splice()의 첫 번째 전달인자는 배열상에서 삽입 혹은 삭제 작업을 시작할 위치를 지정하고, 두 번째 전달인자는 배열에서 삭제할 원소의 개수를 지정한다. 두 번째 전달인자를 지정하지 않으면 첫 번째 전달인자로 지정한 배열의 시작 위치에서 마지막 원소까지 전부 삭제한다. splice()는 삭제한 배열을 반환하며, 만약 삭제된 원소가 하나도 없다면 빈 배열을 반환한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">a.splice(<span class="number">4</span>);       <span class="comment">// [5,6,7,8]을 반환, a는 이제 [1,2,3,4]</span></span><br><span class="line">a.splice(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">// [2, 3]을 반환, a는 이제 [1,4]</span></span><br><span class="line">a.splice(<span class="number">1</span>, <span class="number">1</span>);    <span class="comment">// [4]를 반환, a는 이제 [1]</span></span><br></pre></td></tr></table></figure></p>
<p>세 번째 전달인자부터는 배열에 새롭게 삽입할 원소들을 지정하는데 사용한다. 삽입 작업은 첫 번째 전달인자로 지정된 시작 위치부터 수행한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.splice(<span class="number">2</span>,<span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'b'</span>);    <span class="comment">// []를 반환, a는 이제 [1,2,'a','b',3,4,5]</span></span><br><span class="line">apsplice(<span class="number">2</span>,<span class="number">2</span>, [<span class="number">1</span>,<span class="number">2</span>], <span class="number">3</span>);    <span class="comment">// ['a', 'b']를 반환, a는 이제 [1,2,[1,2],3,3,4,5]</span></span><br></pre></td></tr></table></figure></p>
<p><strong>concat() 메서드와 달리 splice() 메서드는 전달인자로 배열이 전달되면, 그 배열의 원소들을 꺼내어 삽입하지 않고 배열 그 자체를 삽입한다.</strong></p>
<h4 id="787-push와-pop"><a href="#7-8-7-push-와-pop" class="headerlink" title="7.8.7 push()와 pop()"></a><span style="color:red">7.8.7 push()와 pop()</span></h4><p>push()와 pop() 메서드를 사용하면 배열을 마치 스택처럼 조작할 수 있다. (FILO (선입후출) 스택 구현 가능)<br>push() 메서드는 하나 이상의 원소들을 배열의 끝 부분에 이어 붙이고, <strong>배열의 새로운 length 값을 반환</strong>한다<br>pop() 메서드는 배열의 마지막 원소를 제거하고 배열의 length 값을 감소시킨 후, <strong>배열에서 제거한 원소를 반환</strong>한다.</p>
<h4 id="788-unshift와-shift"><a href="#7-8-8-unshift-와-shift" class="headerlink" title="7.8.8 unshift()와 shift()"></a><span style="color:red">7.8.8 unshift()와 shift()</span></h4><p>push(), pop()과 매우 유사하게 동작하는데, 배열의 끝이 아니라 배열의 맨 앞에서 원소를 추가하고 제거한다.<br>unshift() 메서드는 하나 혹은 그 이상의 원소들을 배열의 맨 앞에 추가하고, 추가된 원소만큼 공간을 만들기 위해 기존 배열 원소들을 인덱스가 높은 방향으로 옮긴 후, 배열의 새로운 length 값을 반환한다.<br>shift() 메서드는 배열의 첫 번째 원소를 제거한 후, 배열에서 제거한 원소를 반환한다.</p>
<h4 id="789-tostring"><a href="#7-8-9-toString" class="headerlink" title="7.8.9 toString()"></a><span style="color:red">7.8.9 toString()</span></h4><p>배열의 toString() 메서드는 배열의 모든 원소를 문자열로 변환하고 이 문자열들을 쉼표(,)로 분리한 목록을 반환한다. 별도의 전달인자를 지정하지 않고 join() 메서드를 호출하면 toString()과 동일한 결과를 얻을 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString()             <span class="comment">// '1,2,3'</span></span><br><span class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>].toString()     <span class="comment">// 'a,b,c'</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, <span class="string">'c'</span>]].toString()       <span class="comment">// '1,2,c'</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="79-ecmascript-5-배열-메서드"><a href="#7-9-ECMAScript-5-배열-메서드" class="headerlink" title="7.9 ECMAScript 5 배열 메서드"></a><span style="color:red">7.9 ECMAScript 5 배열 메서드</span></h2><p>ECMAScript 5는 배열을 <strong>순회, 매핑, 필터링, 테스팅, 감소, 검색하기</strong>위한 아홉 가지 새로운 메서드를 정의한다.<br>대부분의 메서드들은 첫 번째 전달인자로 함수를 받는다. 이 함수는 배열의 각 원소마다 한 번씩 실행하거나 일부 원소들에 한해 실행된다. 만약 배열이 희소배열이라면, 빈 원소의 경우 함수를 호출하지 않는다. 대부분, 첫 번째 전달인자로 지정한 함수는 세 개의 전달인자를 갖고 호출되는데, 배열 원소의 값과 인덱스, 마지막으로 배열 그 자체다. 첫 인자로 함수를 받는 대부분의 ECMAScript 5의 배열 메서드들은 생략 가능한 두 번째 인자를 받는다. 두 번째 전달인자를 지정하면, 첫 번째 전달인자인 함수는 마치 두 번째 인자의 메서드인 것처럼 호출된다. 두 번째 인자는 첫 번째 전달인자인 함수 안에서 <strong>this 키워드의 값으로 사용</strong>된다. ECMAScript 5 배열 메서드는 호출 대상 배열을 수정하지 않는다. 메서드의 전달인자로 쓰인 함수 안에서는 배열을 수정할 수 있다.</p>
<h4 id="791-foreach"><a href="#7-9-1-forEach" class="headerlink" title="7.9.1 forEach()"></a><span style="color:red">7.9.1 forEach()</span></h4><p><code>forEach()</code> 메서드는 배열을 순회하는 메서드이다. 첫 번째 인자로 넘긴 함수를 각각의 원소를 대사응로 호출한다. forEach()는 첫 인자로 전달된 함수를 호출할 때 세가지 인자를 넘긴다. <strong>각 인자는 배열의 원소 값과, 원소의 인덱스 값, 그리고 배열 그 자체다.</strong><br>forEach() 메서드는 <strong>배열의 모든 원소가 순회되기 전에는 종료도지 않는다.</strong> 루프에서 사용하는  break문은 사용할 수 없다. 루프를 중간에 종료시키려면, 예외를 발생시켜야 하고, forEach()는 try 블록 안에서 호출되어야 한다.</p>
<h4 id="792-map"><a href="#7-9-2-map" class="headerlink" title="7.9.2 map()"></a><span style="color:red">7.9.2 map()</span></h4><p><code>map()</code> 메서드는 배열의 각 원소를 메서드의 첫 번째 전달인자로 지정한 함수에 전달하고, 해당 함수의 반환 값을 배열에 담아 반환한다.<br>map() 메서드에 전달한 함수는 forEach()에 전달한 함수와 동일한 형태로 호출되지만 map() 메서드에 인자로 전달된 함수는 반드시 값을 반환해야 한다. <strong>map() 메서드는 기존의 배열을 수정하지 않고, 새배열을 반환한다.</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">b = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x*x; &#125;); <span class="comment">// b는 [1, 4, 9]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="793-filter"><a href="#7-9-3-filter" class="headerlink" title="7.9.3 filter()"></a><span style="color:red">7.9.3 filter()</span></h4><p><code>filter()</code> 메서드는 배열의 일부분을 반환한다. 이 메서드에 전달하는 함수는 <strong>조건자 함수</strong>(항상 true 또는 false 값을 반환하는 함수)여야 한다. filter()의 조건 함수는 forEach()와 map() 메서드와 동일한 형태로 호출된다. 반환값이 true이거나 true로 변환되는 값이면 조건자 함수에 전달된 값은 filter가 반환할 배열에 추가된다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">smallvalues = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x &gt; <span class="number">3</span> &#125;);        <span class="comment">// [2, 1]</span></span><br><span class="line">everyother = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x, i</span>) </span>&#123; <span class="keyword">return</span> i%<span class="number">2</span>==<span class="number">0</span> &#125;);     <span class="comment">// [5, 3, 1]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="794-every와-some"><a href="#7-9-4-every-와-some" class="headerlink" title="7.9.4 every()와 some()"></a><span style="color:red">7.9.4 every()와 some()</span></h4><p><code>every()</code>와 <code>some()</code> 메서드는 배열 조건자 함수다. 두 메서드는 인자로 주어진 조건자 함수를 배열에 적용하여, 결과로 true나 false를 반환한다.<br>every() 메서드는 전달인자로 넘긴 함수가 배열의 모든 원소에 대하여 true를 반환하는 경우, every() 메서드는 true를 반환한다.<br>some() 메서드는 전달인자로 넘긴 함수가 배열의 일부 원소에 대해 true를 반환하는 경우, some() 메서드는 true를 반환한다.<br>every()와 some() 메서드는 반환 값이 결정되면 배열의 원소 순회를 중단한다.</p>
<h4 id="795-reduce와-reduceright"><a href="#7-9-5-reduce-와-reduceRight" class="headerlink" title="7.9.5 reduce()와 reduceRight()"></a><span style="color:red">7.9.5 reduce()와 reduceRight()</span></h4><p><code>reduce()</code>와 <code>reduceRight()</code> 메서드는 인자로 주어진 함수를 사용하여 배열의 원소들을 하나의 값으로 결합한다.<br>reduce() 메서드는 두 개의 인자를 갖는다. 첫 번째 인자는 배열 원소의 감소 작업을 하는 함수다. 이 감소 함수는 배열 원소 중 두 값을 하나로 결합하면서 크기를 줄이고, 마지막 남은 값을 반환한다. 두 번째 인자는 감소 함수에 전달할 시작 값이다.<br>reduce()에 사용되는 함수는 forEach()와 map()과는 조금 다르다. reduce()에서 사용하는 함수의 첫 번째 인자는 함수를 사용해 계산된 값의 누적된 결과다. 그 초기 값은 reduce()의 두 번째 인자로 전달한 값이다. 이후의 호출에서는 전 단계 함수 호출에서 반환된 값을 함수의 첫 번째 인자로 사용한다.<br>reduceRight() 메서드는 reduce()와 동작은 같지만, 배열의 끝부터 시작해 반대 방향으로 처리한다. 감소 함수의 피연사자들 중 오른쪽 피연산자의 우선순위가 높다면, reduceRight()를 사용해야 한다. reduce()와 reduceRight() 메서드는 감소 함수 호출 시 사용할 this 값을 선택인자로 지정할 수 없다. 선택 초기 값 인자만 지정할 수 있다. 만약 감소 함수를 특정 object의 메서드로 호출하고 싶다면, Function.bind() 메서드를 사용해야 한다.</p>
<h4 id="796-indexof와-lastindexof"><a href="#7-9-6-indexOf-와-lastIndexOf" class="headerlink" title="7.9.6 indexOf()와 lastIndexOf()"></a><span style="color:red">7.9.6 indexOf()와 lastIndexOf()</span></h4><p><code>indexOf()</code>와 <code>lastIndexOf()</code> 메서드는 배열의 원소 중에서 특정한 값을 찾는다. 값이 존재하면 해당 값의 인덱스를 반환하고, 존재하지 않을 경우에는 -1을 반환한다. indexOf()는 배열의 처음부터 검색하고, lastIndexOf()는 배열의 끝에서부터 검색한다. indexOf()와 lastIndexOf()는 함수를 인자로 받지 않고, 첫 번째 인자에서 배열에서 찾고자 하는 값, 두 번째 인자에서 검색을 시작할 배열 인덱스를 지정할 수 있다.(생략가능)</p>
<hr>
<h2 id="710-배열-타입"><a href="#7-10-배열-타입" class="headerlink" title="7.10 배열 타입"></a>7.10 배열 타입</h2><p>ECMAScript 5에서는 <code>Array.isArray()</code>라는 함수를 통해 특정 객체가 배열인지 판단할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([?])      <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;?&#125;)      <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="711-유사-배열-객체"><a href="#7-11-유사-배열-객체" class="headerlink" title="7.11 유사 배열 객체"></a>7.11 유사 배열 객체</h2><p>length 프로퍼티와 양의 정수 이름의 프로퍼티가 있는 객체는 일종의 배열로 취급할 수 있다. 이를 <code>유사 배열 객체</code>라고 한다.<br>자바스크립트 배열 메서드는 배열뿐 아니라 유사 배열 객체에도 적용이 가능 하도록 범용 메서드로 구현되었다. 유사 배열은 Array.prototype을 상속받지 않기 때문에, 배열 메서드를 해당 객체의 메서드로 호출할 수는 없지만 <code>Function.call</code> 메서드를 통해서 간접적으로 호출할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="string">"0"</span>:<span class="string">"a"</span>, <span class="string">"1"</span>:<span class="string">"b"</span>, <span class="string">"2"</span>:<span class="string">"c"</span>, <span class="attr">length</span>:<span class="number">3</span>&#125;;     <span class="comment">// 유사 배열 객체</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.join(a, <span class="string">"+"</span>)                       <span class="comment">// =&gt; 'a+b+c'</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="712-문자열을-배열처럼-사용하기"><a href="#7-12-문자열을-배열처럼-사용하기" class="headerlink" title="7.12 문자열을 배열처럼 사용하기"></a><span style="color:red">7.12 문자열을 배열처럼 사용하기</span></h2><p>문자열은 읽기 전용 배열처럼 동작한다. 문자열의 각 문자는 chatAt() 메서드로 접근할 수도 있지만 대괄호 []를 사용해 접근할 수도 있다. 문자열을 인덱스로 접근함으로써 얻을 수 있는 가장 큰 장점은 charAt() 메서드 호출을 단순하게 []로 대체 함으로써 코드가 전보다 간결해지고, 가독성이 높아지는 것이다.<br><strong>문자열은 변하지 않는 값이라서, 읽기 전용 배열</strong>로만 다룰 수 있다. push(), sort(), reverse(), splice()와 같은 배열 메서드는 배열을 직접 수정하므로 문자열에서는 작동하지 않는다.</p>
<p><br><br><strong>출처 : <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10338797" rel="external nofollow noopener noreferrer" target="_blank">“JavaScript: The Definitive Guide, by David Flanagan (O’Reilly). Copyright 2011 David Flanagan, 978-0-596-80552-4”</a></strong></p>

        </div>
        
        
        
    </div>
</div>









<!-- For Google Adsense -->
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-3921438651818825" data-ad-slot="3015269677"></ins>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({});
</script>



    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous is-invisible is-hidden-mobile">
            <a class="is-flex-grow has-text-black-ter" href="/categories/Programming/JavaScript/archives/0/">이전</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/categories/Programming/JavaScript/archives/2/">다음</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link is-current" href="/categories/Programming/JavaScript/">1</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/categories/Programming/JavaScript/archives/2/">2</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="is-rounded" src="/images/avatar.jpeg" alt="JongMin">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        JongMin
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        생각을 기록하자
                    </p>
                    
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        포스트
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            125
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        카테고리
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            23
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        태그
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            205
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/jongmin92" target="_blank" rel="external nofollow noopener noreferrer">
                팔로우</a>
        </div>
        
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/jongmin92">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Facebook" href="https://www.facebook.com/jongmin.kim.7796420">
                
                <i class="fab fa-facebook"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            최근 글
        </h3>
        
        <article class="media">
            
            <a href="/2021/03/21/Kotlin/coroutines/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="코루틴 이해하기">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2021-03-20T15:17:42.000Z">2021-03-21</time></div>
                    <a href="/2021/03/21/Kotlin/coroutines/" class="title has-link-black-ter is-size-6 has-text-weight-normal">코루틴 이해하기</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Kotlin/">Kotlin</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/03/31/Java/use-assertthat/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="Unit Test에서 AssertThat을 사용하자">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-30T15:44:27.000Z">2020-03-31</time></div>
                    <a href="/2020/03/31/Java/use-assertthat/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Unit Test에서 AssertThat을 사용하자</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Java/">Java</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/01/02/Java/rsa/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="Encryption - RSA">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-01-02T13:29:00.000Z">2020-01-02</time></div>
                    <a href="/2020/01/02/Java/rsa/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Encryption - RSA</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Programming/">Programming</a> / <a class="has-link-grey -link" href="/categories/Programming/Java/">Java</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/12/26/Programming/2019-retrospect/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="2년차 LINE 서버 개발자의 2019년 회고">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-12-26T13:23:00.000Z">2019-12-26</time></div>
                    <a href="/2019/12/26/Programming/2019-retrospect/" class="title has-link-black-ter is-size-6 has-text-weight-normal">2년차 LINE 서버 개발자의 2019년 회고</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/12/23/Programming/hmac/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="HMAC을 이용한 무결성 보장">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-12-23T14:37:00.000Z">2019-12-23</time></div>
                    <a href="/2019/12/23/Programming/hmac/" class="title has-link-black-ter is-size-6 has-text-weight-normal">HMAC을 이용한 무결성 보장</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                카테고리
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/Algorithm/">
            <span class="level-start">
                <span class="level-item">Algorithm</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">14</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/Algorithm/BOJ/">
            <span class="level-start">
                <span class="level-item">BOJ</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">6</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Algorithm/Concept/">
            <span class="level-start">
                <span class="level-item">Concept</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">8</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/Book/">
            <span class="level-start">
                <span class="level-item">Book</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Database/">
            <span class="level-start">
                <span class="level-item">Database</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Java/">
            <span class="level-start">
                <span class="level-item">Java</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Kotlin/">
            <span class="level-start">
                <span class="level-item">Kotlin</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/">
            <span class="level-start">
                <span class="level-item">Programming</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">95</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/Programming/AWS/">
            <span class="level-start">
                <span class="level-item">AWS</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Git/">
            <span class="level-start">
                <span class="level-item">Git</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Gradle/">
            <span class="level-start">
                <span class="level-item">Gradle</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/HTML/">
            <span class="level-start">
                <span class="level-item">HTML</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Java/">
            <span class="level-start">
                <span class="level-item">Java</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">21</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/JavaScript/">
            <span class="level-start">
                <span class="level-item">JavaScript</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">15</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Linux-Ubuntu/">
            <span class="level-start">
                <span class="level-item">Linux & Ubuntu</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">5</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Node/">
            <span class="level-start">
                <span class="level-item">Node</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">5</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/RaspberryPi/">
            <span class="level-start">
                <span class="level-item">RaspberryPi</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">8</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/React-Native/">
            <span class="level-start">
                <span class="level-item">React Native</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Spring/">
            <span class="level-start">
                <span class="level-item">Spring</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">19</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Tool/">
            <span class="level-start">
                <span class="level-item">Tool</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/Project/">
            <span class="level-start">
                <span class="level-item">Project</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">6</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/Project/Emily/">
            <span class="level-start">
                <span class="level-item">Emily</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">6</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/Tip/">
            <span class="level-start">
                <span class="level-item">Tip</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.png" alt="92Hz" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2021 KimJongMin&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("ko");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'https://jongmin92.github.io',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/" rel="external nofollow noopener noreferrer" target="_blank">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="Zurück nach oben" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="입력 하세요...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '포스트',
                PAGES: '페이지',
                CATEGORIES: '카테고리',
                TAGS: '태그',
                UNTITLED: '(제목없음)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>