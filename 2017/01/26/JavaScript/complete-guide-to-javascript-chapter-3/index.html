<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>자바스크립트 완벽가이드 3장 (타입, 값, 변수) - 92Hz</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="92Hz"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="92Hz"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="자바스크립트의 타입은 크게 원시 타입(promitive type)과 객체 타입(object type)으로 나뉜다. 원시타입에는 숫자, 텍스트의 나열, 불리언 진리 값이 있다.자바스크립트에서 null과 undefined는 원시값이긴 하지만, 숫자도 아니고, 문자열이나 불리언도 아니다. null과 undefined는 자기 자신만을 값으로 갖는 독립적인 타입이다"><meta property="og:type" content="article"><meta property="og:title" content="자바스크립트 완벽가이드 3장 (타입, 값, 변수)"><meta property="og:url" content="https://jongmin92.github.io/2017/01/26/JavaScript/complete-guide-to-javascript-chapter-3/"><meta property="og:site_name" content="92Hz"><meta property="og:description" content="자바스크립트의 타입은 크게 원시 타입(promitive type)과 객체 타입(object type)으로 나뉜다. 원시타입에는 숫자, 텍스트의 나열, 불리언 진리 값이 있다.자바스크립트에서 null과 undefined는 원시값이긴 하지만, 숫자도 아니고, 문자열이나 불리언도 아니다. null과 undefined는 자기 자신만을 값으로 갖는 독립적인 타입이다"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jongmin92.github.io/img/og_image.png"><meta property="article:published_time" content="2017-01-25T17:10:32.000Z"><meta property="article:modified_time" content="2021-03-21T11:05:17.829Z"><meta property="article:author" content="KimJongMin"><meta property="article:tag" content="TIL"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="JavaScript 완벽가이드"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jongmin92.github.io/2017/01/26/JavaScript/complete-guide-to-javascript-chapter-3/"},"headline":"자바스크립트 완벽가이드 3장 (타입, 값, 변수)","image":["https://jongmin92.github.io/img/og_image.png"],"datePublished":"2017-01-25T17:10:32.000Z","dateModified":"2021-03-21T11:05:17.829Z","author":{"@type":"Person","name":"KimJongMin"},"description":"자바스크립트의 타입은 크게 원시 타입(promitive type)과 객체 타입(object type)으로 나뉜다. 원시타입에는 숫자, 텍스트의 나열, 불리언 진리 값이 있다.자바스크립트에서 null과 undefined는 원시값이긴 하지만, 숫자도 아니고, 문자열이나 불리언도 아니다. null과 undefined는 자기 자신만을 값으로 갖는 독립적인 타입이다"}</script><link rel="canonical" href="https://jongmin92.github.io/2017/01/26/JavaScript/complete-guide-to-javascript-chapter-3/"><link rel="alternate" href="/rss2.xml" title="92Hz" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-90389042-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-90389042-1');</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="92Hz" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="카탈로그" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-01-25T17:10:32.000Z" title="1/26/2017, 2:10:32 AM">2017-01-26</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-21T11:05:17.829Z" title="3/21/2021, 8:05:17 PM">2021-03-21</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/JavaScript/">JavaScript</a></span><span class="level-item">37분안에 읽기 (약 5549 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile">자바스크립트 완벽가이드 3장 (타입, 값, 변수)</h1><div class="content"><p>자바스크립트의 타입은 크게 <code>원시 타입(promitive type)</code>과 <code>객체 타입(object type)</code>으로 나뉜다. 원시타입에는 숫자, 텍스트의 나열, 불리언 진리 값이 있다.<br>자바스크립트에서 null과 undefined는 원시값이긴 하지만, 숫자도 아니고, 문자열이나 불리언도 아니다. null과 undefined는 자기 자신만을 값으로 갖는 독립적인 타입이다. <strong>숫자와 문자열, 불리언, null, undefined 외의 값은 객체다. 객체는 이름과 값을 갖는 프로퍼티의 집합이다.</strong><br><br><strong>자바스크립트에서는 함수도 특별한 객체</strong>이다. 함수는 값이고, 자바스크립트 프로그램은 함수를 보통 객체처럼 다룰 수 있다.<br><br><strong>클래스는 객체 타입의 하위 타입으로 생각할 수 있다.</strong> 코어 자바스크립트에서는 Array와 Function 클래스 뿐만 아니라 세 개의 다른 유용한 클래스들을 정의하고 있다.</p>
<ul>
<li>Date : 날짜를 표현하는 객체를 정의</li>
<li>RegExp : 정규 표현식을 표현하는 객체를 정의</li>
<li>Error : 자바스크립트 프로그램에서 발생할 수 있는 문법과 런타임 에러를 표현하는 객체를 정의</li>
</ul>
<p>자바스크립트 인터프리터는 <strong>메모리 관리를 위해 자동</strong>으로 **<code>가비지 컬렉션</code>**을 수행한다. 프로그램이 필요할 때 객체를 생성할 수 있고, 프로그래머는 이 객체를 어떻게 해제할지 걱정할 필요가 없다. 객체에 더 이상 접근할 수 없을 때(프로그램이 더 이상 객체를 참조하지 않을 때) 인터프리터는 그 객체를 자동으로 메모리에서 해제한다.<br><br>자바스크립트는 <strong>객체 지향 언어</strong>다. 다양한 타입의 값을 다루는 전역 함수를 정의해두기보다, 어떠한 값과 작동하는 메서드를 그 값의 타입에 정의해둔다는 말이다. 예를 들면, 배열의 원소들을 정렬할 때는 배열 a를 sort() 함수에 인자로 전달하는 것이 아니라 a의 sort() 메서드를 호출하여 정렬하는 것이다. null과 undefined를 제외하고는 모두 메서드를 가질 수 있다.</p>
<h2 id="3-1-숫자"><a href="#3-1-숫자" class="headerlink" title="3.1 숫자"></a>3.1 숫자</h2><p>다른 프로그래밍 언어들과는 다르게 자바스크립트는 정수 값과 실수 값을 구분하지 않는다. 자바스크립트에서는 <strong>모든 숫자를 실수로 표현</strong>한다.</p>
<h4 id="3-1-3-산술-연산"><a href="#3-1-3-산술-연산" class="headerlink" title="3.1.3 산술 연산"></a>3.1.3 산술 연산</h4><p>자바스크립트의 산술 연산은 오버플로와 언더플로, 0으로 나누는 에러를 발생시키지 않는다. 산술 연산의 결과가 표현할 수 있는 가장 큰 수보다 더 크다면(오버플로) <code>Infinity</code>라고 표현하는 무한대의 값을 출력한다. 음의 무한대가 되면 이 값을 <code>-Infinity</code>로 출력한다. 언더플로는 산술 연산의 결과가 표현할 수 있는 가장 작은 값보다 더 0에 가까울 때 발생한다. 이런 경우 자바스크립트는 0을 돌려준다.<br><br><strong>자바스크립트에서 0으로 나누는 연산은 에러가 아니다.</strong> 이런 경우 무한대 또는 음의 무한대가 반환된다. 그러나 0을 0으로 나누는 것은 정의되지 않은 값을 갖고, 그 결과로 숫자가 아닌 특수한 값을 가진다. 자바스크립트에서는 이러한 값을 <strong>NaN</strong>으로 출력한다. (ECMAScript 5에서는 Infinity와 NaN을 읽기 전용 값으로 정의한다.) <code>Number</code>객체에는 Inifiny와 NaN이 따로 상수로 정의되어 있다.</p>
<p>자바스크립트에서 NaN은 그 자신뿐만 아니라 다른 값과 같은지 비교 할 수 없다. 변수 x가 NaN인지 판단하기 위해 <code>x === NaN</code> 문을 작성할 수 없고, 대신 <code>x != x</code> 라고 작성해야 한다. isNaN() 함수가 이러한 경우에 유용하게 사용할 수 있다. 이 함수는 인자가 NaN이거나, 문자열이나 객체처럼 숫자가 아니라면 참을 반환한다.</p>
<h4 id="3-1-4-이진-부동소수점과-반올림-오류"><a href="#3-1-4-이진-부동소수점과-반올림-오류" class="headerlink" title="3.1.4 이진 부동소수점과 반올림 오류"></a>3.1.4 이진 부동소수점과 반올림 오류</h4><p>무한히 많은 실수가 있지만 자바스크립트에서는 한정된 숫자만 부동소수점 형태로 표현할 수 있다. 자바스크립트에서 사용하는 IEEE-754 부동소수점 표현 방식은 1/2, 1/8, 1/1024 같은 분수를 정확하게 표현 할 수 있는 이진 표현법이다. 하지만 가장 많이 사용하는 분수는 10진수 분수인데, 이진 표현법으로는 0.1과 같은 간단한 값도 정확하게 표현 할 수 없다.<br>따라서 다음과 같은 상황이 발생한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">.3</span> - <span class="number">.2</span>;        <span class="comment">// 0.3 - 0.2</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">.2</span> - <span class="number">.1</span>;        <span class="comment">// 0.2 - 0.1</span></span><br><span class="line">x == y                  <span class="comment">// =&gt; false: 두 값은 같지 않다.</span></span><br><span class="line">x == <span class="number">.1</span>                 <span class="comment">// =&gt; false: 0.3 - 0.2는 0.1이 아니다.</span></span><br><span class="line">y == <span class="number">.1</span>                 <span class="comment">// =&gt; true: 0.2 - 0.1은 0.1과 같다.</span></span><br></pre></td></tr></table></figure>
<p>이진 부동소수점 숫자를 사용하기 때문에 발생하는 현상이다. 계산된 값은 대부분 적절하지만, 값들을 동등 비교할 경우에 문제가 발생한다.</p>
<h4 id="3-1-5-날짜와-시간"><a href="#3-1-5-날짜와-시간" class="headerlink" title="3.1.5 날짜와 시간"></a>3.1.5 날짜와 시간</h4><p>날짜와 시간을 표현하는 Date 객체를 사용한다. Date 객체는 숫자 같은 <strong>원시 타입이 아니다.</strong></p>
<hr>
<h2 id="3-2-텍스트"><a href="#3-2-텍스트" class="headerlink" title="3.2 텍스트"></a>3.2 텍스트</h2><p>문자열(string)은 16비트 값들이 연속적으로 나열된 변경이 불가능한 값으로, 각 문자는 유니코드 문자로 표현된다. 문자열의 길이 값은 문자열에 들어 있는 16비트 값의 개수다.</p>
<p>자바스크립트는 유니코드 문자열 집합으로 UTF-16을 사용한다. 유니코드 문자는 16비트에 적합한 코드 포인트를 갖고 있고, 문자열의 한 문자로 표현할 수 있다. 16비트로 표현할 수 없는 유니코드는 UTF-16 규칙에 따라 두 개의 16비트 값으로 인코딩한다. 따라서, 자바스크립트에서는 길이가 2인 문자열이 하나의 유니코드 문자를 표현하는 경우도 있다.<br><strong>문자열을 다루는 다양한 메서드는 문자를 다루는게 아니라 문자의 16비트 값을 다룬다.</strong></p>
<h4 id="3-2-3-문자열-다루기"><a href="#3-2-3-문자열-다루기" class="headerlink" title="3.2.3 문자열 다루기"></a>3.2.3 문자열 다루기</h4><p><strong>자바스크립트에서 문자열은 변경되지 않는다.</strong> replace()와 toUpperCase() 같은 메서드는 기존 문자열을 변경하지 않고 새문자열을 반환한다. 즉, 문자열 관련 메서드는 호출 시에 기존 문자열을 수정하지 않는다. ECMAScript5에서 문자열은 읽기 전용 배열처럼 취급될 수 있고, 대괄호 대신 <strong>charAt()</strong> 메서드를 사용해도 문자열의 개별 문자(16비트 값)에 접근할 수 있다.</p>
<h4 id="3-2-4-패턴-매칭"><a href="#3-2-4-패턴-매칭" class="headerlink" title="3.2.4 패턴 매칭"></a>3.2.4 패턴 매칭</h4><p>자바스크립트는 문자 패턴을 나타내는 객체를 생성하기 위해 RegExp() 생성자를 정의한다. 이 패턴은 <strong>정규 표현식</strong>이라 부르며, 자바스크립트는 정규 표현식을 위해 펄(Perl)의 구문을 따른다. 문자열과 RegExp 객체는 모두 패턴 매칭과 ‘검색 후 바꾸기’기능을 수행하는 메서드를 갖고 있다. RegExp는 자바스크립트의 원시 타입이 아니다. Date 객체처럼 RegExp는 유용한 API를 갖고 있는 <strong>특별한 종류의 객체</strong>다.<br>한 쌍의 슬래시 사이에 있는 문자열은 정규 표현식 리터럴을 구성하고, 한 쌍의 슬래시 중 두 번째 슬래시 뒤에는 하나 혹은 그 이상의 문자가 뒤따라 올 수 있는데, 이것은 패턴의 의미를 수정할 수 있다.<br><br>RegExp 객체에는 유용한 메서드들이 정의되어 있다. 또한 <strong>문자열은 RegExp 객체를 인자로 갖는 메서드들을 갖고 있다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">&quot;testing: 1, 2, 3&quot;</span>;      <span class="comment">// 간단한 문자열</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\b+/g</span>                <span class="comment">// 하나 이상의 모든 숫자와 일치</span></span><br><span class="line">pattern.test(text);                 <span class="comment">// =&gt; true: 일치하는 문자열이 존재</span></span><br><span class="line">text.search(pattern);               <span class="comment">// =&gt; 9: 첫 번째로 매치하는 문자열의 위치</span></span><br><span class="line">text.match(pattern);                <span class="comment">// =&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]: 일치된 항목의 배열</span></span><br><span class="line">text.replace(pattern, <span class="string">&quot;#&quot;</span>);         <span class="comment">// =&gt; &quot;testing: #, #, #&quot;</span></span><br><span class="line">text.split(<span class="regexp">/\D+/</span>);                  <span class="comment">// =&gt; [&quot;&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]: 숫자가 아닌 문자(열)를 기준으로 분할</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-3-불리언-값"><a href="#3-3-불리언-값" class="headerlink" title="3.3 불리언 값"></a><span style="color:red">3.3 불리언 값</span></h2><p><strong>자바스크립트의 어떤 값이든 불리언 값으로 변환될 수 있다.</strong> 다음은 모두 불리언 false 값으로 변한다.</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>0</li>
<li>-0</li>
<li>NAN</li>
<li>“” // 빈 문자열</li>
</ul>
<p>불리언 값은 문자열 “true” 혹은 “false”로 변환할 수 있는 <code>toString()</code> 메서드를 갖고 있지만 그 밖의 메서드는 갖고있지 않다.</p>
<h2 id="3-4-null과-undefined"><a href="#3-4-null과-undefined" class="headerlink" title="3.4 null과 undefined"></a><span style="color:red">3.4 null과 undefined</span></h2><p><code>null</code>은 보통 아무 값도 갖지 않음을 가리킬 때 사용한다. typeof 연산자를 null에 사용하면 문자열 “object”를 반환한다. 그 결과로 볼 때, <strong>null은 ‘객체가 없음’을 뜻하는 특수한 객체 값으로 생각할 수 있다.</strong> 하지만 실무에서 null은 값이 null 하나뿐인 어떤 고유한 자료형에 속한 것으로 간주하여, 객체뿐 아니라 수나 문자열 “값이 없음”을 나타내는 데도 쓰인다.<br><br>자바스크립트에는 값이 없음을 나타내는 또 다른 값, <code>undefined</code>가 있다. <strong>undefined는 null보다 심한 부재 상태</strong>를 나타낸다. undefined는 초기화되어 있지 않는 변수나, 존재하지 않는 객체 프로퍼티나 배열의 원소 값에 접근하려고 할 때 얻는 값이다. 또한 undefined는 반환값이 없는 함수의 반환값이고, 실 인자가 전달되지 않은 형식인자의 값이다. ECMAScript 5에서 undefined는 읽기 전용이며, typeof 연산자의 결과로 “undefined”가 반환된다. 이는 undefined가 <strong>특별한 고유의 값</strong>임을 말한다.<br><br>이러한 차이에도 불구하고 <strong>null</strong>과 <strong>undefined</strong>는 둘다 값이 없음을 가리키고, 사용할 때 서로 바꿔 사용할 수도 있다. 동치 연산자 ==를 null과 undefined에 사용하면 두 값이 같다고 간주하며 엄격한 동치 연산자 ===는 다르다고 판단한다.<br><br>시스템 수준에서 예기치 않은 상황에 발생한, 오류성 값 부재를 표현할 때는 주로 undefined를 사용하고, 일반적인 프로그램 수준에서 일반적으로, 또는 예상 가능한 값 부재 상황을 표현하고 싶을 때는 null을 사용한다. <strong>만약 이들 값 중 하나를 변수나 프로퍼티에 할당할 필요가 있거나 함수에 인자로 전달할 필요가 있다면, undefined보다는 null을 사용하는게 적절하다.</strong></p>
<h2 id="3-6-래퍼-wrapper-객체"><a href="#3-6-래퍼-wrapper-객체" class="headerlink" title="3.6 래퍼(wrapper) 객체"></a><span style="color:red">3.6 래퍼(wrapper) 객체</span></h2><p>자바스크립트 객체는 복합적인 값이다. 객체는 프로퍼티 또는 이름 있는 값들의 집합이다. 프로퍼티의 값이 함수일 때, 그 함수를 <strong>메서드</strong>라 부른다.<br><br>문자열의 프로퍼티를 참조하려 할 때, 자바스크립트는 new String()를 호출한 것처럼 <strong>문자열 값을 객체로 변환한다.</strong> 이 객체는 문자열 메서드를 상속하며, 프로퍼티 참조를 살펴보는 데 사용한다. 일단 프로퍼티 참조가 해제되면 새로 생성된 임시 객체는 메모리에서 회수된다.<br><br>숫자와 불리언은 문자열과 같은 이유로 메서드를 갖고 있다. 임시 객체는 <code>Number()</code> 혹은 <code>Boolean()</code> 생성자를 통해 만들어지고, 메서드는 임시 객체를 통해 호출된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">s.len = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> t = s.len;</span><br></pre></td></tr></table></figure>
<p>위의 코드를 실행시 t의 값은 undefined이다. 2행은 생성된 임시 String 객체의 len 프로퍼티에 4를 할당한다. 그리고 임시 객체는 바로 삭제된다. 3행은 기존 문자열 값과 같은 값을 가진 새로운 String 객체를 생성하고 len 프로퍼티를 읽으려고 하지만 존재하지 않아 undefined를 출력한다. <strong>값을 할당하는 것은 임시 객체에서 수행되며, 지속되지 않는다.</strong><br><br>문자열, 숫자, 불리언의 프로퍼티에 접근하려고 할 때 생성되는 <strong>임시 객체</strong>는 <code>래퍼(wrapper) 객체</code>로 알려져 있다. 문자열과 숫자, 불리언 값의 프로퍼티는 읽기 전용이고, 이 값들에 새로운 프로퍼티를 정의할 수 없다는 점에서 이 값들이 객체와 다르다는 사실을 알아야 한다.<br><br>String()과 Number(), Boolean() 생성자를 사용해 명시적으로 래퍼 객체를 생성할 수도 있다. 자바스크립트는 래퍼 객체를 필요에 따라 기본 타입으로 변환한다. == 동치 연산자는 값과 그 값의 래퍼 객체를 동등하게 다루지만 === 엄격한 동치 연산자로 이를 구별할 수 있다. (typeof 연산자는 기본 타입과 래퍼 객체의 차이점을 보여줄 수 있다.)</p>
<h2 id="3-7-변경-불가능한-원시-타입-값과-변경-가능-객체-참조"><a href="#3-7-변경-불가능한-원시-타입-값과-변경-가능-객체-참조" class="headerlink" title="3.7 변경 불가능한 원시 타입 값과 변경 가능 객체 참조"></a><span style="color:red">3.7 변경 불가능한 원시 타입 값과 변경 가능 객체 참조</span></h2><p>자바스크립트에서 <strong>원시 타입(undefined, null, 불리언, 숫자, 문자열) 값</strong>과 <strong>객체(배열과 함수를 포함한)</strong> 사이에는 근본적인 차이점이 있다. 원시 타입의 값은 수정할 수 없다는것이다. 문자열 같은 경우 문자열을 수정하는 모든 문자열 메서드는 새로운 문자열을 반환한다. 원시 타입은 값으로 비교된다. 두 값은 같은 값이어야만 같다. 문자열 같은 경우 서로 다른 문자열 값을 비교할 때, 자바스크립트는 두 문자열의 길이가 같고 각 인덱스에 있는 문자들이 같다면 두 문자열을 같다고 판단한다.<br><br>객체는 원시 타입과는 다르다. 객체는 자신의 값을 변경할 수 있다. <strong>객체는 값으로 비교되지 않는다. 두 객체가 같은 프로퍼티와 값을 가지고 있어도 두 객체는 같지 않다.</strong> 그리고 두 배열은 같은 순서로 같은 원소를 갖고 있어도 같지 않다.<br><br>객체는 <code>참조 타입(reference type)</code>으로 불리는데, 이는 자바스크립트의 원시 타입과 구별하기 위해서다. <strong>객체의 값은 참조다.</strong> 객체는 참조로 비교될 수 있다. 두 객체 값은 그들이 같은 객체를 참조하면 같다. 객체는 새로운 복사본을 생성하지 않기 때문에 객체 혹은 배열의 새로운 복사본을 만들고 싶다면 <strong>명시적으로 객체의 프로퍼티 또는 배열의 원소를 복사</strong>해야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];                  <span class="comment">// 복사하고자 하는 배열</span></span><br><span class="line"><span class="keyword">var</span> b = [];                               <span class="comment">// 복사하고자 하는 배열</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;       <span class="comment">// 배열 a의 각 인덱스</span></span><br><span class="line">    b[i] = a[i];                          <span class="comment">// a의 원소를 b로 복사한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>두 다른 객체 또는 배열을 서로 비교하고 싶다면 그들의 프로퍼티 또는 원소를 비교해야 한다.</p>
<hr>
<h2 id="3-8-타입-변환"><a href="#3-8-타입-변환" class="headerlink" title="3.8 타입 변환"></a>3.8 타입 변환</h2><p>자바스크립트는 타입에 매우 유연하다. 자바스크립트가 문자열을 원한다면, 문자열이 올 자리에 어떤 값을 전달하더라도 문자열로 변환될 것이고, 숫자를 원한다면 숫자가 올 자리에 다른 어떤 값이 오더라도 숫자로 변환될 것이다.(또는 의미 있는 변환을 할 수 없다면 NaN으로 변환된다.)</p>
<h4 id="3-8-1-변환과-동치"><a href="#3-8-1-변환과-동치" class="headerlink" title="3.8.1 변환과 동치"></a>3.8.1 변환과 동치</h4><p>자바스크립트는 <strong>값의 타입을 유연하게 변환</strong>시킬 수 있다. 따라서, 동치 연산자 ==도 유연하게 동작한다. 다음은 모두 true를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>     <span class="comment">// 이 두 값은 같다고 판단된다.</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="number">0</span>              <span class="comment">// 비교하기 전에 숫자로 변환된다.</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>            <span class="comment">// 불리언은 비교하기 전에 숫자로 변환한다.</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">false</span>          <span class="comment">// 두 피연선자는 비교하기 전에 숫자로 변환된다.</span></span><br></pre></td></tr></table></figure>
<p><strong>서로 변환 가능한 값이라고 해서 동치는 아니다.</strong> undefined가 불리언 값이 올 자리에 사용되면 false로 변환된다. 하지만 이것이 undefined == false 임을 의미하지는 않는다. if문은 undefined를 false로 변환하지만, == 연산자는 undefined를 불리언으로 변환하지 않는다.</p>
<h4 id="3-8-2-명시적-변환"><a href="#3-8-2-명시적-변환" class="headerlink" title="3.8.2 명시적 변환"></a>3.8.2 명시적 변환</h4><p>자바스크립트는 많은 형 변환을 자동으로 수행하지만, 명시적 변환이 필요할 때가 있다. 명시적으로 타입변환을 수행하는 가장 간단한 방법은 Boolean(), Number(), String(), Object() 함수를 사용하는 것이다. new 연산자 없이 호출되면, 이 함수들은 <strong>변환 함수</strong>로 작동한다.</p>
<h4 id="3-8-3-객체에서-원시-타입으로-변환"><a href="#3-8-3-객체에서-원시-타입으로-변환" class="headerlink" title="3.8.3 객체에서 원시 타입으로 변환"></a>3.8.3 객체에서 원시 타입으로 변환</h4><p>모든 객체는 두 개의 타입 변환 메서드를 상속한다.</p>
<ul>
<li>toString() : 객체를 <strong>문자열</strong>로 표현하여 반환한다.</li>
<li>valueOf() : 기본적으로 원시 타입을 반환하지 않고 단순히 <strong>객체</strong> 그 자신을 반환한다.</li>
</ul>
<p>자바스크립트는 toString(), valueOf() 순으로 메서드를 호출하여 문자열로 변환하여 반환한다. 만약 toString() 또는 valueOf() 로부터 원시타입 값을 얻을 수 없다면 <code>TypeError</code>를 발생시킨다. 객체를 숫자로 전환할 때는 문자열과 같은 방식으로 전환하지만, valueOf() 메서드를 먼저 호출한다.</p>
<hr>
<h2 id="3-9-변수-선언"><a href="#3-9-변수-선언" class="headerlink" title="3.9 변수 선언"></a>3.9 변수 선언</h2><p>자바스크립트에서는 변수를 사용하기 전에 변수 선언을 해야 한다. var 문을 통해서 변수를 선언하는데, var 문에서 변수에 초기 값을 지정하지 않는다면, 변수는 값이 설정될 때까지 <strong>undefined</strong> 값을 갖게 된다. 자바스크립트 변수 선언에는 타입을 명시하지 않는다.</p>
<h2 id="3-10-변수의-유효범위"><a href="#3-10-변수의-유효범위" class="headerlink" title="3.10 변수의 유효범위"></a><span style="color:red">3.10 변수의 유효범위</span></h2><p>변수의 유효범위란 프로그램에서 어떤 변수가 정의되어 있는 영역을 말한다.</p>
<h4 id="3-10-1-함수-유효범위와-끌어올림-hoisting"><a href="#3-10-1-함수-유효범위와-끌어올림-hoisting" class="headerlink" title="3.10.1 함수 유효범위와 끌어올림(hoisting)"></a><span style="color:red">3.10.1 함수 유효범위와 끌어올림(hoisting)</span></h4><p>C 같은 프로그래밍 언어에서 블록 안에 있는 코드는 자신만의 유효범위를 가지며, 변수는 해당 변수가 선언되지 않은 블록 밖에서는 보이지 않는다. 이를 <strong>블록 유효범위</strong>라고 부른다. 자바스크립트에서는 블록 유효범위의 개념이 없고 <strong>함수 유효범위</strong>를 사용한다. 변수는 해당 변수가 정의된 함수 안에서 보일 뿐 아니라, 그 함수 안에 중첩된 함수 안에서도 보인다. 이런 자바스크립트의 특징을 비공식적으로 **끌어올림(hoisting)**이라고 한다. 자바스크립트의 코드는 함수 안에 있는 모든 변수를 함수 맨 위로 ‘끌어올린’ 것처럼 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(scope);       <span class="comment">// &quot;global&quot;이 아니라 &quot;undefined&quot;를 출력한다.</span></span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">&quot;local&quot;</span>;      <span class="comment">// 여기서 초기호하지만, 정의는 다른 곳에서 이루어진다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(scope);       <span class="comment">// &quot;local&quot;을 출력한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 함수는 실제로 다음 코드와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope;                <span class="comment">// 지역 변수는 함수 맨 꼭대기에서 선언한다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(scope);       <span class="comment">// scope 변수는 존재하지만 아직 &quot;undefined&quot; 값이다.</span></span><br><span class="line">  scope = <span class="string">&quot;local&quot;</span>;          <span class="comment">// 이제 scope 변수가 초기화되고 제대로 된 값이 있다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(scope);       <span class="comment">// 여기서는 기대한 값이 들어있다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>함수의 유효범위 규칙 때문에 지역 변수는 함수 전체에 걸쳐 정의된다. 지역 변수가 함수 전체에 걸쳐 정의되었더라도 var 문이 실행되고 나서야 실제로 초기화 된다. 따라서 변수 선언은 함수 맨 위로 **’끌어올려(hoisting)’**지고 초기화는 나중에 이루어지게 된다.<br><br>블록 유효범위를 가진 프로그래밍 언어에서 일반적으로 변수를 선언하는 좋은 프로그래밍 방법은, <strong>가능한 한 그 변수가 사용되는 가장 가까운 곳에서 선언하는 것이다. 하지만 자바스크립트는 블록 유효범위를 가지고 있지 않기 때문에 함수의 맨 위에 선언해야할지도 모른다.</strong></p>
<h4 id="3-10-3-유효범위-체인"><a href="#3-10-3-유효범위-체인" class="headerlink" title="3.10.3 유효범위 체인"></a><span style="color:red">3.10.3 유효범위 체인</span></h4><p><strong>자바스크립트는 언어적으로 유효범위를 갖고 있는 언어다.</strong> 변수의 유효범위란 정의된 변수를 사용 가능한 소스코드의 집합으로 생각할 수 있다.<br><br>지역 변수를 객체의 프로퍼티로 생각한다면, 변수 유효범위를 다른 관점으로 볼 수도 있다. 자바스크립트의 모든 코드 무더기는 그것과 연관된 유효범위 체인을 갖고 있다. 이 유효범위 체인은 해당 코드 무더기의 ‘범위 안’에 있는 변수를 정의하는 <strong>객체의 체인, 리스트</strong>다.<br><br>최상위 자바스크립트 코드의 경우, 유효범위 체인은 단 하나의 ‘전역 객체’만으로 이루어진다. 중첩되지 않은 함수의 유효 범위 체인은 두 개의 객체로 이루어진다. 하나는 함수 매개변수와 지역 변수를 정의하는 객체고, 다른 하나는 전역 객체다. 중첩된 함수에서 유효범위 체인은 세 개 이상의 객체를 갖는다. 함수가 호출될 때, 해당 함수의 지역변수를 저장하기 위해서 새로운 객체를 하나 생성하고, 해당 객체를 기존에 저장된 유효범위 체인에 추가한다. 중첩 함수의 경우에는 외부에서 함수를 호출할 때마다 중첩된 함수가 매번 선언된다.</p>
<br>
**출처 : ["JavaScript: The Definitive Guide, by David Flanagan (O'Reilly). Copyright 2011 David Flanagan, 978-0-596-80552-4"](http://book.naver.com/bookdb/book_detail.nhn?bid=10338797)**
</div><div class="article-licensing box"><div class="licensing-title"><p>자바스크립트 완벽가이드 3장 (타입, 값, 변수)</p><p><a href="https://jongmin92.github.io/2017/01/26/JavaScript/complete-guide-to-javascript-chapter-3/">https://jongmin92.github.io/2017/01/26/JavaScript/complete-guide-to-javascript-chapter-3/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>KimJongMin</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2017-01-26</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-03-21</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="external nofollow noopener noreferrer" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="external nofollow noopener noreferrer" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="external nofollow noopener noreferrer" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/TIL/">TIL</a><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript/">JavaScript</a><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript-%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C/">JavaScript 완벽가이드</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2017/01/27/JavaScript/complete-guide-to-javascript-chapter-4/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">자바스크립트 완벽가이드 4장 (표현식과 연산자)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2017/01/26/JavaScript/complete-guide-to-javascript-chapter-2/"><span class="level-item">자바스크립트 완벽가이드 2장 (어휘 구조)</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">댓글</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://jongmin92.github.io/2017/01/26/JavaScript/complete-guide-to-javascript-chapter-3/';
            this.page.identifier = '2017/01/26/JavaScript/complete-guide-to-javascript-chapter-3/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'https-jongmin92-github-io' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">카탈로그</h3><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-숫자"><span class="level-left"><span class="level-item">1</span><span class="level-item">3.1 숫자</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-5-날짜와-시간"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">3.1.5 날짜와 시간</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-2-텍스트"><span class="level-left"><span class="level-item">2</span><span class="level-item">3.2 텍스트</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-2-4-패턴-매칭"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">3.2.4 패턴 매칭</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-3-불리언-값"><span class="level-left"><span class="level-item">3</span><span class="level-item">3.3 불리언 값</span></span></a></li><li><a class="level is-mobile" href="#3-4-null과-undefined"><span class="level-left"><span class="level-item">4</span><span class="level-item">3.4 null과 undefined</span></span></a></li><li><a class="level is-mobile" href="#3-6-래퍼-wrapper-객체"><span class="level-left"><span class="level-item">5</span><span class="level-item">3.6 래퍼(wrapper) 객체</span></span></a></li><li><a class="level is-mobile" href="#3-7-변경-불가능한-원시-타입-값과-변경-가능-객체-참조"><span class="level-left"><span class="level-item">6</span><span class="level-item">3.7 변경 불가능한 원시 타입 값과 변경 가능 객체 참조</span></span></a></li><li><a class="level is-mobile" href="#3-8-타입-변환"><span class="level-left"><span class="level-item">7</span><span class="level-item">3.8 타입 변환</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-8-3-객체에서-원시-타입으로-변환"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">3.8.3 객체에서 원시 타입으로 변환</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-9-변수-선언"><span class="level-left"><span class="level-item">8</span><span class="level-item">3.9 변수 선언</span></span></a></li><li><a class="level is-mobile" href="#3-10-변수의-유효범위"><span class="level-left"><span class="level-item">9</span><span class="level-item">3.10 변수의 유효범위</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-10-3-유효범위-체인"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">3.10.3 유효범위 체인</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="92Hz" height="28"></a><p class="is-size-7"><span>&copy; 2021 KimJongMin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>