<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>태그: Sort - 92Hz</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="92Hz"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="92Hz"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="website"><meta property="og:title" content="92Hz"><meta property="og:url" content="https://jongmin92.github.io/"><meta property="og:site_name" content="92Hz"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://jongmin92.github.io/img/og_image.png"><meta property="article:author" content="KimJongMin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jongmin92.github.io"},"headline":"92Hz","image":["https://jongmin92.github.io/img/og_image.png"],"author":{"@type":"Person","name":"KimJongMin"},"description":""}</script><link rel="alternate" href="/rss2.xml" title="92Hz" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-90389042-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-90389042-1');</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="ca-pub-3921438651818825" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="92Hz" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">태그</a></li><li class="is-active"><a href="#" aria-current="page">Sort</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-11-20T09:00:00.000Z" title="11/20/2017, 6:00:00 PM">2017-11-20</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-21T11:03:02.988Z" title="3/21/2021, 8:03:02 PM">2021-03-21</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Concept/">Concept</a></span><span class="level-item">6분안에 읽기 (약 860 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/11/20/Algorithm/Concept/priority-queue/">힙 응용 - 우선순위 큐 (Priority queue)</a></h1><div class="content"><h3 id="우선순위-큐-Priority-queue-란"><a href="#우선순위-큐-Priority-queue-란" class="headerlink" title="우선순위 큐 (Priority queue) 란?"></a>우선순위 큐 (Priority queue) 란?</h3><p>큐는 여러개의 데이터를 넣을 수 있는 자료구조 입니다. 데이터가 넣고 뺄때는 <strong>First In First Out(FIFO) 구조</strong>를 가집니다.</p>
<p><strong><code>우선순위 큐</code>는 이러한 큐의 한종류로써 <code>최대 우선순위 큐</code>와 <code>최소 우선순위 큐</code>로 나뉩니다.</strong></p>
<h3 id="최대-우선순위-큐"><a href="#최대-우선순위-큐" class="headerlink" title="최대 우선순위 큐"></a>최대 우선순위 큐</h3><p>최대 우선순위 큐는 다음의 두가지 연산을 지원하는 자료구조 입니다. (최소 우선순위 큐는 EXTRACT-MAX 대신 EXTRACT-MIN을 지원하는 자료구조입니다.)</p>
<ol>
<li><strong>INSERT(x)</strong> : 새로운 원소 x를 삽입</li>
<li><strong>EXTRACT_MAX()</strong> : 최대값을 삭제하고 반환</li>
</ol>
<p>MAX HEAP을 이용해서 최대 우선순위 큐를 구현할 수 있습니다.</p>
<h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1flon6ap26oj31780syn7m.jpg" alt="INSERT 과정"></p>
<p>위의 그림은 MAX HEAP의 형태로 저장되어 있는 우선순위 큐 입니다. 현재 heap은</p>
<ol>
<li>complete binary tree</li>
<li>max heap property<br>조건을 만족하기 때문에 이를 유지하면서 INSERT 연산을 하기 위해서는 고려할 사항들이 있습니다.</li>
</ol>
<p>INSERT는 새로운 노드를 추가해야하는데 <strong>complete binary tree</strong> 를 만족하기 위해서는 가장 마지막 레벨의 leaf에 추가 될 수 밖에 없습니다. 그리고 새로운 노드가 추가된 후 <strong>max heap property</strong>를 만족하기 위해서는 max-heapify 연산이 필요합니다.<br>INSERT의 의사 코드는 다음과 같습니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAX-HEAP-<span class="built_in">INSERT</span>(A, key)&#123;</span><br><span class="line">    heap_size = heap_size + <span class="number">1</span>;</span><br><span class="line">    A[heap_size] = key;</span><br><span class="line">    i = heap_size;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">1</span> <span class="keyword">and</span> A[<span class="built_in">PARENT</span>(i)] &lt; A[i])&#123;</span><br><span class="line">        exchange A[i] <span class="keyword">and</span> A[<span class="built_in">PARENT</span>(i)];</span><br><span class="line">        i = <span class="built_in">PARENT</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위의 코드에서 A는 heap의 사이즈를 1증가 시키고, 그 자리에 새로운 key값을 넣습니다. i는 새로 추가된 노드의 인덱스입니다.<br>그 후 while 문에서 i &gt; 1 (root 노드가 아니라는 의미) 이며, A[PARENT(i)] &lt; A[i] (부모 노드에 저장된 값보다 크다는 의미) 라면 부모 노드와 값을 교환합니다.</p>
<p>즉, 루트 노드가 될 때까지 혹은 자신의 부모 노드보다 작을 때 까지 계속해서 교환연산을 진행합니다. 따라서 시간 복잡도는 트리의 높이에 비례하게 되고, heap은 complete binary tree이므로 <code>O(nlogn)</code>입니다.</p>
<h3 id="EXTRACT-MAX"><a href="#EXTRACT-MAX" class="headerlink" title="EXTRACT_MAX"></a>EXTRACT_MAX</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1flonkg61l9j314a0ro7cl.jpg" alt="EXTRACT_MAX 과정"></p>
<p>위의 그림은 EXTRACT_MAX 과정을 나타내고 있습니다. heap은 complete binary tree 성질을 유지하기 위해서 아무 노드나 삭제하는 것이 아니라 마지막 노드를 삭제하게 됩니다. 이때 루트 노드와 마지막 노드의 자리를 변경해 마지막 노드를 삭제 후 max-heapify를 통해 다시 max heap property를 만족하도록 만들 수 있습니다.<br>HEAP-EXTRACT-MAX의 의사 코드는 다음과 같습니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HEAP-EXTRACT-<span class="built_in">MAX</span>(A)&#123;</span><br><span class="line">    <span class="keyword">if</span> heap-size[A] &lt; <span class="number">1</span></span><br><span class="line">        then error <span class="string">&quot;heap underflow&quot;</span></span><br><span class="line">    max &lt;- A[<span class="number">1</span>]</span><br><span class="line">    A[<span class="number">1</span>] &lt;- A[heap-size[A]]</span><br><span class="line">    heap-size[A] &lt;- heap-size[A] - <span class="number">1</span></span><br><span class="line">    MAX-<span class="built_in">HEAPIFY</span>(A, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-로-구현하기"><a href="#C-로-구현하기" class="headerlink" title="C++로 구현하기"></a>C++로 구현하기</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heap_insert</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, tmp;</span><br><span class="line"></span><br><span class="line">    size = size + <span class="number">1</span>;</span><br><span class="line">    a[size] = key;</span><br><span class="line"></span><br><span class="line">    i = size;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span> &amp;&amp; a[i / <span class="number">2</span>] &lt; a[i]) &#123;</span><br><span class="line">        tmp = a[i / <span class="number">2</span>];</span><br><span class="line">        a[i / <span class="number">2</span>] = a[i];</span><br><span class="line">        a[i] = tmp;</span><br><span class="line">        i = i / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heap_extract_max</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;heap underflow\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = a[<span class="number">1</span>];</span><br><span class="line">    a[<span class="number">1</span>] = a[size];</span><br><span class="line">    <span class="built_in">max_heapify</span>(a, size<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>출처 : 2015 봄학기 알고리즘 - 부경대 권오흠 교수님</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-11-19T07:35:00.000Z" title="11/19/2017, 4:35:00 PM">2017-11-19</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-21T11:02:53.832Z" title="3/21/2021, 8:02:53 PM">2021-03-21</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Concept/">Concept</a></span><span class="level-item">6분안에 읽기 (약 833 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/11/19/Algorithm/Concept/heap-sort-2/">힙 정렬 (Heap sort) - 2</a></h1><div class="content"><p>저번 포스팅에서는 힙(Heap)과 max-heapify에 대해 알아보았습니다. 이번 포스팅에서는 직접 1차원 배열을 heap 구조로 변경한 후 힙 정렬을 해보겠습니다.</p>
<h3 id="1차원-배열을-힙-Heap-으로-만들기"><a href="#1차원-배열을-힙-Heap-으로-만들기" class="headerlink" title="1차원 배열을 힙(Heap) 으로 만들기"></a>1차원 배열을 힙(Heap) 으로 만들기</h3><p>먼저 의사 코드는 다음과 같습니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BUILD-MAX-HEAP</span><br><span class="line">    heap-size[A]&lt;-length[A]</span><br><span class="line">    <span class="keyword">for</span> i &lt;- |length[A]/<span class="number">2</span>| downto <span class="number">1</span></span><br><span class="line">        <span class="keyword">do</span> MAX-<span class="built_in">HEAPIFY</span>(A,i)</span><br></pre></td></tr></table></figure>
<p>i가 A 배열의 길이 / 2 부터 시작하는 이유는 리프 노드에서는 max-heapify 과정이 필요 없기 때문입니다.</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1flnftndkvwj31260yodqt.jpg" alt="BUILD-MAX-HEAP 과정"></p>
<p>힙을 만드는데의 시간 복잡도는 다음과 같습니다.<br>MAX-HEAPIFY 연산의 시간 복잡도는 log(n) 입니다. 그런데 for 문이 n/2 돌기 때문에 n/2*log(n)이며 빅 오로 표기하면 O(n*log(n))이 됩니다.<br>이는 루트 노드만 고려하여 상당히 러프하게 계산한 것이기 때문에, 정확하게 계산한다면 시간 복잡도는 **<code>O(n)</code>**이 됩니다.</p>
<h3 id="힙-정렬-Heap-sort-하기"><a href="#힙-정렬-Heap-sort-하기" class="headerlink" title="힙 정렬(Heap sort) 하기"></a>힙 정렬(Heap sort) 하기</h3><p>힙 정렬은 다음과 같은 순서로 실행됩니다.</p>
<ol>
<li>주어진 데이터를 힙으로 만든다</li>
<li>힙에서 최대값(루트 노드)을 가장 마지막 값과 바꾼다.</li>
<li>힙의 크기가 1 줄어든 것으로 간주한다. 즉, 마지막 값은 힙의 일부가 아닌것으로 간주한다.</li>
<li>루트 노드에 대해서 HEAPIFY(1)한다.</li>
<li>2~4번을 반복한다.</li>
</ol>
<p>데이터를 힙으로 만들면 인덱스 1의 값이 가장 최대값 이므로 마지막 값과 바꿉니다.<br>그리고 마지막값은 정렬된 값으로 간주하고 더 이상 신경쓰지 않아도 됩니다.<br>그렇게 줄여나간다면 결국 정렬된 상태의 배열이 완성됩니다.</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1flnhnyssc1j31bi10sqec.jpg" alt="힙 정렬 과정"></p>
<p>힙 정렬의 의사 코드는 다음과 같습니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HEAPSORT</span>(A)</span><br><span class="line">    BUILD-MAX-<span class="built_in">HEAP</span>(A)             <span class="comment">// O(n)</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;-heap-size downto <span class="number">2</span> <span class="keyword">do</span> <span class="comment">// n-1 times</span></span><br><span class="line">        exchange A[<span class="number">1</span>] &lt;-&gt; A[i]    <span class="comment">// O(1)</span></span><br><span class="line">        heap_size &lt;- heap_size <span class="number">-1</span> <span class="comment">// O(1)</span></span><br><span class="line">        MAX-<span class="built_in">HEAPIFY</span>(A,<span class="number">1</span>)          <span class="comment">// O(log(n))</span></span><br></pre></td></tr></table></figure>
<p>총 시간 복잡도는 **<code>nlogn</code>**이 됩니다.</p>
<h3 id="C-로-힙-정렬-구현하기"><a href="#C-로-힙-정렬-구현하기" class="headerlink" title="C++로 힙 정렬 구현하기"></a>C++로 힙 정렬 구현하기</h3><p>다음과 같이 C++로 힙 정렬을 구현할 수 있습니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITEM_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = idx * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> right = (idx * <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> largest = idx;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 왼쪽 자식 노드와 비교</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; size &amp;&amp; a[left] &gt; a[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 오른쪽 자식 노드와 비교</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; size &amp;&amp; a[right] &gt; a[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 부모 노드보다 자식 노드가 큰 경우 교환</span></span><br><span class="line">    <span class="keyword">if</span> (largest != idx) &#123;</span><br><span class="line">        tmp = a[largest];</span><br><span class="line">        a[largest] = a[idx];</span><br><span class="line">        a[idx] = tmp;</span><br><span class="line">        <span class="comment">// 재귀 호출</span></span><br><span class="line">        <span class="built_in">max_heapify</span>(a, size, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">max_heapify</span>(a, size, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build_max_heap</span>(a, size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = size - <span class="number">1</span>; count &gt; <span class="number">0</span>; count--) &#123;</span><br><span class="line">        <span class="comment">// 루트 노드를 가장 마지막 노드와 교환</span></span><br><span class="line">        tmp = a[count];</span><br><span class="line">        a[count] = a[<span class="number">1</span>];</span><br><span class="line">        a[<span class="number">1</span>] = tmp;</span><br><span class="line">        <span class="comment">// 힙 구조 유지</span></span><br><span class="line">        <span class="built_in">max_heapify</span>(a, count, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[ITEM_SIZE] = &#123; <span class="number">0</span>, &#125;; <span class="comment">// 루트 노드는 1번 인덱스 부터 시작</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ITEM_SIZE; i++) &#123;</span><br><span class="line">        a[i] = (<span class="built_in">rand</span>() % (ITEM_SIZE * <span class="number">10</span>)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_arr</span>(a, ITEM_SIZE);</span><br><span class="line">    <span class="built_in">heap_sort</span>(a, ITEM_SIZE);</span><br><span class="line">    <span class="built_in">print_arr</span>(a, ITEM_SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>출처 : 2015 봄학기 알고리즘 - 부경대 권오흠 교수님</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-11-19T05:00:00.000Z" title="11/19/2017, 2:00:00 PM">2017-11-19</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-21T11:02:51.564Z" title="3/21/2021, 8:02:51 PM">2021-03-21</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Concept/">Concept</a></span><span class="level-item">12분안에 읽기 (약 1741 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/11/19/Algorithm/Concept/heap-sort-1/">힙 정렬 (Heap sort) - 1</a></h1><div class="content"><p>힙 정렬은 <code>힙, 바이너리 힙, 이진 힙</code>이라고 부르는 자료구조를 이용하는 정렬 알고리즘입니다.</p>
<p><strong>힙 정렬의 특징</strong>은 다음과 같습니다.<br>1.최악의 경우에도 시간 복잡도가 nlogn이 되는 빠른 정렬이다.<br>2.힙 정렬은 알고리즘을 구현하는데 추가적인 배열이 필요하지 않다.<br>3.이진 힙(바이너리 힙) 자료구조를 사용한다.</p>
<p>먼저 힙 정렬을 구현하기 전에, <code>힙</code> 이라는 자료구조에 대해 알아보겠습니다.</p>
<h3 id="힙-Heap-이란"><a href="#힙-Heap-이란" class="headerlink" title="힙(Heap) 이란?"></a>힙(Heap) 이란?</h3><p>힙(Heap)은</p>
<ol>
<li>complete binary tree(완전 이진 트리) 이면서</li>
<li>heap property를 만족해야 합니다.</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1flnbnxri5vj31cy0nu48n.jpg" alt="포화 이진 트리, 완전 이진 트리"></p>
<p>위의 그림에서는 **full binary tree(포화 이진 트리)**와 **complete binary tree(완전 이진 트리)**에 대해 설명하고 있습니다.</p>
<p><code>binary tree(이진 트리)</code>란 한 노드가 최대 2개의 자식 노드를 가지는 트리 입니다. 따라서, 위의 2개 트리는 모두 이진 트리입니다. 이진 트리는 이진 탐색 트리(BST)와 이진 힙(Binary Heap)의 구현에 흔히 사용됩니다.</p>
<p><code>full binary tree(포화 이진 트리)</code>란 이진 트리중에 모든 레벨의 노드 들이 꽉 차있는 형태를 말합니다.</p>
<p><code>complete binary tee(완전 이진 트리)</code>는 마지막 레벨을 제외하면 완전히 꽉 차있고, 마지막 레벨에는 가장 오른쪽 부터 연속된 몇개의 노드가 비어있을 수 있는 트리를 말합니다. 따라서 포화 이진 트리는 완전 이진 트리이기도 합니다.</p>
<p>위의 2번째 조건에서 <strong>heap property</strong>를 만족해야 한다고 했습니다. 이 heap property는 2개의 조건으로 나누어집니다.</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1flnccxerlwj31b60g0dla.jpg"></p>
<ol>
<li><strong>max heap property</strong> - 부모 노드는 자식 노드보다 데이터가 크거나 같다.</li>
<li><strong>min heap property</strong> - 부모 노드는 자식 노드보다 데이터가 크거나 작다.</li>
</ol>
<p>max와 min 모두 대칭적 관계이므로 모든 알고리즘에 적용되나 상황에 따라서 간단하게 사용할 수 있는 것을 씁니다. 여기서는 max-heap property를 다루겠습니다.</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1flnc51lx8aj31da0qqk02.jpg" alt="(a) heaps, (b,c) nonheaps"></p>
<p>(a)의 3개 트리는 모두 heap 입니다. (완전 이진 트리이면서 heap property를 만족합니다.)<br>(b)의 3개 트리는 heap이 아닙니다. (완전 이진 트리이지만, (max)heap property를 만족하지 않습니다.)<br>(c)의 2개 트리도 heap이 아닙니다. (완전 이진 트리를 만족하지 않습니다.)</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1flncuv31voj318u0da79j.jpg"></p>
<p>위의 (a), (b), (c)는 모두 다 heap입니다.<br>(a), (b), (c)는 동일한 데이터를 갖고 있는 서로 다른 heap입니다. 즉, <strong>여러가지 모양의 heap이 존재할 수 있는 것입니다.</strong></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1flncxi146tj31820h0n30.jpg"></p>
<p>Heap은 <strong>1차원 배열을 사용해 표현할 수 있습니다.</strong> 같은 레벨에서 왼쪽부터 배열로 저장하면 1차원 배열이 됩니다. 일반적인 트리에서는 부모 자식간의 관계를 식을 통해 표현할 수 없지만 Heap은 complete binary tree이므로 배열의 인덱스만으로 부모와 자식의 관계를 표현할 수 있습니다. 루트 노드가 배열의 1번 인덱스부터 시작한다면 다음과 같은 표현식을 사용할 수 있습니다.</p>
<ul>
<li>루트 노드 : A[1]</li>
<li>A[i]의 부모 노드 : A[i/2]</li>
<li>A[i]의 왼쪽 자식 노드 : A[2i]</li>
<li>A[i]의 오른쪽 자식 노드 : A[2i+1]</li>
</ul>
<p>따라서 <strong>Heap은 1차원 배열을 통해 표현이 가능하기 때문에 불필요하게 트리 자료구조를 따로 만들어 사용해 구현할 필요가 없습니다.</strong></p>
<h3 id="Max-heapify-란"><a href="#Max-heapify-란" class="headerlink" title="Max-heapify 란?"></a>Max-heapify 란?</h3><p>지금부터는 어떤 1차원 배열의 데이터가 있을 때 이 1차원 배열을 Heap으로 변환하는 과정에 대해 알아보겠습니다. (이번 포스팅에서는 max heap만을 다루기로 했으므로 max heap을 만드는 방법에 대해 알아보겠습니다.)<br>일반 1차원 배열은 <strong>max-heapify</strong>라는 연산 과정을 통해 max heap으로 만들수 있습니다.</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1flnd6rf5iij31eq0s6jzw.jpg"></p>
<p>max-heapify 연산을 하기 위한 전제조건을 위의 그림에서 보여주고 있습니다.</p>
<ol>
<li>트리의 전체 모양은 complete binary tree이다.</li>
<li>왼쪽 서브 트리(subtree)는 그 자체로 heap이다.</li>
<li>오른쪽 서브 트리(subtree)는 그 자체로 heap이다.</li>
</ol>
<p>여기서 유일하게 루트 노드만이 heap property를 만족하지 않을때, max-heapify 연산을 통해 heap property를 만족하게 만들 수 있습니다.</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1flndt24q4ij31fo0xck3z.jpg" alt="max-heapify 연산 과정"></p>
<p>위의 그림에서 루트 노드는 자신의 자식 노드중에 더 큰값과 자리를 교체 합니다. 그 후 교체된 노드에서 다시 max-heapify 연산을 통해 max-heap property를 만족할 때까지 반복합니다.</p>
<p>결국 max-heapify는 동일한 과정을 반복하고 있기 때문에 **recursion(재귀)**로 구현이 가능합니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAX-<span class="built_in">HEAPIFY</span>(A, i)&#123;</span><br><span class="line">    <span class="keyword">if</span> there is no child of A[i]</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    k &lt;- index of the biggest child of i;</span><br><span class="line">    <span class="keyword">if</span> A[i]&gt;=A[k]</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    exchange A[i] <span class="keyword">and</span> A[k];</span><br><span class="line">    MAX-<span class="built_in">HEAPIFY</span>(A, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>첫번째 조건은 base case로서, 자식 노드가 없다면 가장 아래의 레벨에 위치한 리프노드이기 때문에 종료합니다. 만약 자식 노드가 있다면 큰 자식 노드의 인덱스를 k로 지정합니다. 그 후  부모 노드와 값을 비교해 부모 노드가 크다면 max-heapify 과정을 종료하고, 자식 노드의 값이 크다면 부모 노드와 값을 교환한 후 다시 max-heapify를 재귀 호출 합니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAX-<span class="built_in">HEAPIFY</span>(A, i)&#123;</span><br><span class="line">    <span class="keyword">while</span> A[i] has a child <span class="keyword">do</span></span><br><span class="line">        k&lt;- index of the biggest child of i;</span><br><span class="line">        <span class="keyword">if</span> A[i]&gt;= A[k];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        exchange A[i] <span class="keyword">and</span> A[k];</span><br><span class="line">        i=k;</span><br><span class="line">    end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>같은 함수를 iterate하게 구현한 코드입니다. 주요 함수의 동작 원리는 같습니다.</p>
<p>max-heapify의 시간 복잡도는 루트 노드로부터 마지막 레벨까지 비교, 교환 연산을 하므로 트리의 높이보다 많은 시간이 필요하지 않습니다. 따라서 <strong>시간 복잡도는 높이에 의해서 결정되며, <code>O(h)</code>입니다.</strong><br>일반적인 이진트리가 아닌 complete binary tree이므로 노드의 개수를 n이라 하면, **시간 복잡도는 <code>O(logn)</code>**이 됩니다.</p>
<p>출처 : 2015 봄학기 알고리즘 - 부경대 권오흠 교수님</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-11-06T15:30:00.000Z" title="11/7/2017, 12:30:00 AM">2017-11-07</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-21T11:03:05.367Z" title="3/21/2021, 8:03:05 PM">2021-03-21</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Concept/">Concept</a></span><span class="level-item">7분안에 읽기 (약 1071 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/11/07/Algorithm/Concept/quick-sort/">퀵 정렬 (Quick sort)</a></h1><div class="content"><h3 id="분할정복법과-퀵-정렬-Quick-sort"><a href="#분할정복법과-퀵-정렬-Quick-sort" class="headerlink" title="분할정복법과 퀵 정렬 (Quick sort)"></a>분할정복법과 퀵 정렬 (Quick sort)</h3><p>퀵 정렬은 합병 정렬과 마찬가지로 분할정복법을 사용하지만 그 방법에 있어서 차이가 있습니다.<br><strong>퀵 정렬에서는 정렬할 데이터가 주어지면 하나의 값을 <code>기준값(pivot)</code>으로 사용하여 정렬을 합니다.</strong> 어떤 값을 기준값으로 설정하는지가 퀵정렬의 성능을 좌우합니다.</p>
<p>분할정복법 3단계를 바탕으로 퀵정렬의 과정을 알아보겠습니다.</p>
<ol>
<li>분할 : 하나의 값을 기준값(pivot)으로 설정 한 후 데이터들을 기준값보다 큰 값과 작은값으로 분류한다.</li>
<li>정복 : 분할한 양쪽을 각각 재귀로 퀵 정렬한다.</li>
<li>합병 : 이미 분할 과정에서 정렬이 완료되었기 때문에 따로 과정이 없다.</li>
</ol>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fl8t9gfhijj30u00h6q5c.jpg" alt="퀵 정렬에서의 분할정복법 과정"></p>
<h3 id="퀵-정렬-의사-코드"><a href="#퀵-정렬-의사-코드" class="headerlink" title="퀵 정렬 의사 코드"></a>퀵 정렬 의사 코드</h3><p>의사 코드는 다음과 같습니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">quickSort</span>(A[], p, r) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;r) then&#123;</span><br><span class="line">        q = <span class="built_in">partition</span>(A, p, r);    <span class="comment">// 분할</span></span><br><span class="line">        <span class="built_in">quickSort</span>(A, p, q<span class="number">-1</span>);    <span class="comment">// 왼쪽 부분배열 정렬</span></span><br><span class="line">        <span class="built_in">quickSort</span>(A, q+<span class="number">1</span>, r);    <span class="comment">// 오른쪽 부분배열 정렬</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">partition</span>(A[], p, r) &#123;</span><br><span class="line">    배열 A[p...r]의 원소들을 A[r]을 기준으로 양쪽으로 재배치하고</span><br><span class="line">    A[r]이 자리한 위치를 <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>배열 A의 인덱스 p에서 r사이에 있는 데이터를 정렬합니다. 조건문으로 p가 r보다 작은 경우에만 알고리즘이 실행되도록 합니다. 다음으로 partion 함수는 기준값(pivot)을 기준으로 전체 데이터를 나눠주고 피봇 인덱스를 반환하는 역할을 합니다. 따라서, q는 피봇이 됩니다.</p>
<p>[p, q-1] 은 배열의 왼쪽 부분, 작은 값이고<br>[q+1, r] 까지는 배열의 오른쪽 부분, 큰 값입니다.<br>재귀적으로 quickSort 함수를 호출해 정렬합니다.</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fl8trgffz7j30nh0ii0ty.jpg"></p>
<p>위의 그림에서 기준값(pivot)으로 인덱스의 마지막 값을 사용하고 있습니다. 위의 그림 기준에서 현재 인덱스 j의 값이 기준값보다 크다면 j를 증가시켜 다음값으로 넘어갑니다.<br>그러나 인덱스 j의 값이 기준값보다 작다면 앞쪽으로 보내야하는데, 이때 i값을 1 증가 시킨 후 그 값과 교환합니다.</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fl8twh3l33j30q00l43zz.jpg"><br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fl8u0xwg18j30q10hwta0.jpg"></p>
<p>위의 과정은 기준값을 마지막 인덱스의 값인 15로 설정하고 i와 j를 증가시키면서 정렬하는 과정을 보여줍니다. 모든 정렬이 완료되면 인덱스 i+1의 값과 기준값의 위치를 변경합니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Partition</span>(A, p, r)&#123;</span><br><span class="line">    x&lt;-A[r];</span><br><span class="line">    i&lt;-p<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> j&lt;-p to r<span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> A[j] &lt;= x then</span><br><span class="line">        i&lt;-i+<span class="number">1</span>;</span><br><span class="line">        exchange A[i] <span class="keyword">and</span> A[j];</span><br><span class="line">    exchange A[i+<span class="number">1</span>] <span class="keyword">and</span> A[r];</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Partition 함수를 더 자세한 의사 코드로 나타냈습니다. 앞서 설명한 위치 변환과 인덱스 증가로 정렬을 완료하고 마지막으로 기준값(pivot)의 인덱스를 리턴합니다.</strong></p>
<h3 id="퀵-정렬-c-코드"><a href="#퀵-정렬-c-코드" class="headerlink" title="퀵 정렬 c++ 코드"></a>퀵 정렬 c++ 코드</h3><p>이제 의사 코드를 바탕으로 c++ 코드를 작성하면 다음과 갖습니다. (의사 코드와는 완전히 일치하지는 않습니다.)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITEM_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = right;</span><br><span class="line">    <span class="keyword">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = left;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[pivot]) &#123;</span><br><span class="line">                tmp = a[j];</span><br><span class="line">                a[j] = a[i + <span class="number">1</span>];</span><br><span class="line">                a[i + <span class="number">1</span>] = tmp;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = a[pivot];</span><br><span class="line">        a[pivot] = a[i + <span class="number">1</span>];</span><br><span class="line">        a[i + <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    pivot = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = <span class="built_in">partition</span>(a, left, right);</span><br><span class="line">        <span class="built_in">quick_sort</span>(a, left, pivot - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quick_sort</span>(a, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[ITEM_SIZE] = &#123; <span class="number">15</span>, <span class="number">2</span>, <span class="number">24</span>, <span class="number">18</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">21</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="built_in">print_arr</span>(a, ITEM_SIZE);</span><br><span class="line">    <span class="built_in">quick_sort</span>(a, <span class="number">0</span>, ITEM_SIZE - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print_arr</span>(a, ITEM_SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="퀵-정렬-시간-복잡도"><a href="#퀵-정렬-시간-복잡도" class="headerlink" title="퀵 정렬 시간 복잡도"></a>퀵 정렬 시간 복잡도</h3><p>퀵 정렬에서의 시간 복잡도는 파티션(분할) 하는데 모든 데이터를 한번씩 비교하면 되므로 n이 됩니다. 정확하게 말하자면 데이터의 개수가 n개일때, n-1 번의 비교가 이루어집니다.</p>
<p>합병 정렬보다는 시간 복잡도를 구하는게 조금 더 복잡한데, 합병 정렬은 항상 2개로 나뉘는것과 달리 퀵 정렬은 항상 양쪽이 고르게 나누어지지 않기 때문입니다.</p>
<p>먼저 최악의 경우부터 생각해보면 모든 배열이 정렬되어있을 때, 기준값이 최대/최소 값일 때, 최악의 시간 복잡도가 발생합니다. 분할은 0개와 나머지 전체로 나누어지므로 결국 데이터는 아무변화가 없고 똑같은 루틴이 반복되기 때문에 시간 복잡도는 **<code>O(n^2)</code>**가 됩니다.</p>
<p>반대로 최선의 경우는 항상 절반으로 분할되는 경우로, 이 때는 합병 정렬과 동일한 시간인 **<code>O(nlogn)</code>**의 시간을 같습니다.</p>
<p>퀵 정렬은 다른 정렬 알고리즘보다 대체로 빠르기 때문에 퀵 정렬 이라는 이름이 붙었습니다. 그렇지만 최악의 경우에는 O(n^2)의 느린 속도를 보여줬는데 왜 퀵 정렬이 다른 알고리즘 보다 빠른 걸가요?</p>
<p>최선의 경우와 최악의 경우는 극단적인 케이스라서 실제적으로 일어나기 어려운 상황입니다.</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fl8ud3s48pj30sj0ih0wb.jpg" alt="항상 한쪽이 적어도 1/9 이상이 되도록 분할된다면?"></p>
<p>현식적으로 가정했을 때, n개의 데이터가 항상 9:1로 분할 된다고 하면 한 단계 당 분할되는 시간을 구하면 항상 n이므로 전체 비교 연산은 트리의 깊이 * n 입니다.<br>트리는 대칭적이지 않으므로 가장 깊은 오른쪽 경로(최악의 경우)를 예로 들면 (9/10)^k * n = 1이 됩니다.<br>따라서 시간 복잡도 k = log9/10(n)이 됩니다.</p>
<p>이 예가 의미하는 것은 <strong>퀵 정렬의 성능은 파티션이 얼마나 밸런스있게 나뉘냐에 결정된다는 것입니다.</strong> 극단적인 경우만 아니라면 퀵 정렬의 시간 복잡도는 nlogn 이 되므로 실제로 상당히 빠른 정렬 방법이 됩니다.</p>
<p>출처 : 2015 봄학기 알고리즘 - 부경대 권오흠 교수님</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-11-06T08:50:00.000Z" title="11/6/2017, 5:50:00 PM">2017-11-06</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-21T11:02:56.003Z" title="3/21/2021, 8:02:56 PM">2021-03-21</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Concept/">Concept</a></span><span class="level-item">11분안에 읽기 (약 1691 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/11/06/Algorithm/Concept/merge-sort/">합병 정렬 (Merge sort)</a></h1><div class="content"><h3 id="분할정복법과-합병-정렬-Merge-sort"><a href="#분할정복법과-합병-정렬-Merge-sort" class="headerlink" title="분할정복법과 합병 정렬 (Merge sort)"></a>분할정복법과 합병 정렬 (Merge sort)</h3><p><strong><code>합병 정렬</code>은 앞서 알아본 선택, 삽입, 버블 정렬과는 다르게 <code>분할정복법</code>이라는 개념을 사용합니다.</strong></p>
<p>**분할정복법(Divide-And-Conquer)**이라는 것은 주어진 문제를 다음과 같은 3단계의 절차를 통해 해결하는 방법입니다.</p>
<ol>
<li>분할 : 해결하고자 하는 문제를 작은 크기의 동일한 문제들로 분할한다.</li>
<li>정복 : 각각의 작은 문제를 순환적으로 해결한다.</li>
<li>합병 : 작은 문제의 해를 합하여(merge) 원래 문제에 대한 해를 구한다.</li>
</ol>
<p>그럼 이를 토대로 합병 정렬의 과정을 살펴보겠습니다.</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl8jl4h25hj30qd0gzzpr.jpg"></p>
<p>합병 정렬은 여러 개의 데이터를 한 번에 정렬하는 것이 아닌 이를 계속해서 반으로 나눈 후 다시 합병하는 과정에서 정렬이 이루어집니다.</p>
<p>분할을 반복하다보면 마지막은 길이가 1인 구간으로 나뉘어집니다. 더이상 분할이 불가능할때 다시 합병하면서 정렬을 하는것입니다. 그렇기 때문에 합병 정렬에서 가장 중요한 부분은 실제 정렬을 수행하는 **합병(merge)**하는 과정입니다.</p>
<p>그럼 합병과정에서 정렬은 어떻게 이루어질까요? 다음 그림을 통해서 실제 정렬이 이루어지는 합병 과정을 좀 더 자세히 알아보겠습니다.</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fl8knuvjxgj30vd0e7gm6.jpg"></p>
<p>먼저 위 그림은 합병이 이루어 지기 위한 이미 정렬된 2개의 블록이 존재하는 모습입니다. 현재 두개의 블록은 이미 길이가 1인 구간으로 나눠진 배열부터 시작해 각각 합병 과정을 거쳐 정렬된 상태로 만들어진 배열입니다.<br><strong>이 두개의 블록을 정렬된 상태를 유지하며 합치기 위해서는 i 인덱스에 있는 값과, j 인덱스에 있는 값을 하나씩 비교한 후 <code>추가배열</code>에 저장하면 됩니다.</strong></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fl8lrnjgylj30ux0dxt9d.jpg"></p>
<p>위 그림처럼 하나의 블록이 모두 합쳐 졌을 경우 나머지 블록은 순서대로 배열에 저장하면 됩니다.</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl8ko6pwa2j30v20e1q3m.jpg"></p>
<p>모든 합병을 마친 후 이 추가배열의 값으로 기존 배열의 해당 구간에 복사하면 됩니다.</p>
<h3 id="합병-정렬-의사-코드"><a href="#합병-정렬-의사-코드" class="headerlink" title="합병 정렬 의사 코드"></a>합병 정렬 의사 코드</h3><p>의사 코드는 다음과 같습니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mergeSort</span>(A[],p,r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;r) then&#123;</span><br><span class="line">        q &lt;- (p+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(A,p,q);</span><br><span class="line">        <span class="built_in">mergeSort</span>(A,q+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">merge</span>(A, p, q, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">merge</span>(A[], p, q, r)&#123;</span><br><span class="line">    정렬되어 있는 ㅜ 배열 A[p..q]와 A[q+<span class="number">1.</span>..r]을 합하여</span><br><span class="line">    정렬된 하나의 배열 A[p...r]을 만든다.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="합병-정렬-c-코드"><a href="#합병-정렬-c-코드" class="headerlink" title="합병 정렬 c++ 코드"></a>합병 정렬 c++ 코드</h3><p>이제 의사 코드를 바탕으로 c++ 코드를 작성하면 다음과 같습니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITEM_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    i = left;</span><br><span class="line">    j = mid + <span class="number">1</span>;</span><br><span class="line">    k = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp_arr[ITEM_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left 부터 mid 까지의 블록과 mid + 1 부터 right 까지의 블록을 서로 비교</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">            tmp_arr[k] = a[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp_arr[k] = a[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left 블록의 값이 다 처리되었지만, right 블록의 index가 남아 있는 경우</span></span><br><span class="line">    <span class="comment">// right 블록의 남은 부분을 순차적으로 tmp_arr에 복사</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = j; m &lt;= right; m++) &#123;</span><br><span class="line">            tmp_arr[k] = a[m];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// left 블록의 남은 부분을 순차적으로 tmp_arr에 복사</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = i; m &lt;= mid; m++) &#123;</span><br><span class="line">            tmp_arr[k] = a[m];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 임시 배열인 tmp_arr의 값을 원본 배열에 복사한다.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = left; m &lt;= right; m++) &#123;</span><br><span class="line">        a[m] = tmp_arr[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 절반으로 나누기 위해 중간 위치 찾기</span></span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 분할</span></span><br><span class="line">        <span class="built_in">merge_sort</span>(a, left, mid);</span><br><span class="line">        <span class="built_in">merge_sort</span>(a, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 합병</span></span><br><span class="line">        <span class="built_in">merge</span>(a, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[ITEM_SIZE] = &#123; <span class="number">15</span>, <span class="number">2</span>, <span class="number">24</span>, <span class="number">18</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">21</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="built_in">print_arr</span>(a, ITEM_SIZE);</span><br><span class="line">    <span class="built_in">merge_sort</span>(a, <span class="number">0</span>, ITEM_SIZE - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print_arr</span>(a, ITEM_SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="합병-정렬-시간-복잡도"><a href="#합병-정렬-시간-복잡도" class="headerlink" title="합병 정렬 시간 복잡도"></a>합병 정렬 시간 복잡도</h3><p>이제 마지막으로 합병 정렬의 시간 복잡도를 알아보겠습니다. 데이터가 n개 일때 합병 정렬로 계산하는 시간을 T(n)이라고 하겠습니다.<br>정렬을 위해서 반으로 분할한 후 n/2개의 블럭에 재귀함수를 호출하면, 반으로 분할된 블럭 2개에 대한 정렬을 수행해야하므로 **T(n/2) + T(n/2)**의 시간이 걸립니다. 두개의 정렬된 블럭을 merge할 때 두 블럭을 한번씩 비교하므로 merge 시간은 <strong>n</strong>입니다.<br>따라서, merge sort의 시간 복잡도는 <strong>T(n) = T(n/2) + T(n/2) + n</strong>이 됩니다.</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fl8mb4xm7oj30ta0g5q4q.jpg"></p>
<p>결국 분할을 반복하면 위와 같은 그림의 식을 도출할 수 있고, 이 식을 수학적으로 풀어보면 **<code>O(nlogn)</code>**이 됩니다.</p>
<h3 id="합병-정렬과-퀵-정렬-비교"><a href="#합병-정렬과-퀵-정렬-비교" class="headerlink" title="합병 정렬과 퀵 정렬 비교"></a>합병 정렬과 퀵 정렬 비교</h3><p>아직 퀵 정렬에 대해 다루지 않았지만 합병 정렬과 퀵 정렬 모두 시간 복잡도로 **<code>O(nlogn)</code>**을 갖습니다. 그러나 퀵 정렬과 합병 정렬에는 서로 다른 특징이 있습니다.</p>
<p>합병 정렬은 합병 과정에서 임시적인 저장공간으로 데이터를 담고 있는 배열과 같은 크기인 <strong>추가 배열</strong>을 사용하기 때문에 **<code>추가적인 메모리가 필요</code>**합니다. 그러나 퀵 정렬은 추가 메모리를 사용하지 않고 내부 교환만으로 수행되는 차이가 있습니다.</p>
<p>또한 합병 정렬은 어떤 상황이라도 항상 **O(nlogn)**의 시간 복잡도를 갖지만 퀵 정렬의 경우 아이러니하게도 정렬하기 위해 정렬이 되어 있는 데이터를 사용할 경우 **O(n^2)**의 시간복잡도를 갖게 됩니다. (이 경우는 다음에 퀵 정렬에 대해 포스팅하며 알아보겠습니다.) 그러나 최악의 경우가 아닐 경우 일반적으로 퀵 정렬이 합병 정렬에 비해 빠른 성능을 보입니다.</p>
<p>합병 정렬은 퀵 정렬보다 성능이 전반적으로 떨어지고, 데이터 크기만한 메모리가 더 필요하지만 최대의 장점은 **<code>stable sort</code>**라는 점입니다. 퀵 정렬의 경우 만약 배열 A[25] = 100, A[33] = 100 인 정수형 배열을 정렬한다고 할 때, 33번째에 있던 100이 25번째에 있던 100보다 앞으로 오는 경우가 생길 수 있습니다. 그에 반해서 합병 정렬은 이전의 순서를 유지하면서 정렬된 상태를 만들 수 있습니다.</p>
<p>출처 : 2015 봄학기 알고리즘 - 부경대 권오흠 교수님</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2017-11-06T04:20:00.000Z" title="11/6/2017, 1:20:00 PM">2017-11-06</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-03-21T11:02:45.974Z" title="3/21/2021, 8:02:45 PM">2021-03-21</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Concept/">Concept</a></span><span class="level-item">10분안에 읽기 (약 1440 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/11/06/Algorithm/Concept/basic-sort/">기본적인 정렬 알고리즘 (선택, 삽입, 버블)</a></h1><div class="content"><h2 id="정렬-알고리즘-종류와-특징"><a href="#정렬-알고리즘-종류와-특징" class="headerlink" title="정렬 알고리즘 종류와 특징"></a>정렬 알고리즘 종류와 특징</h2><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fl8gt30q6oj30k1093752.jpg"></p>
<h2 id="선택-정렬"><a href="#선택-정렬" class="headerlink" title="선택 정렬"></a>선택 정렬</h2><p><strong><code>선택 정렬</code>은 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택한다라고 생각하면 이해하기 쉽습니다.</strong></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fl89nsw0chj30rm0hsgni.jpg" alt="선택 정렬 과정"></p>
<p>현재 위의 예시에서는 각 순서마다 정렬되지 않은 범위에서 가장 큰 원소를 찾아 맨 마지막 값의 자리와 변경합니다. 가장 큰값을 찾아 맨 오른쪽 원소와 변경해 오름차순으로 정렬했지만, 매 순서마다 가장 작은 값을 찾아 맨 왼쪽의 원소와 변경해주어도 오름차순 정렬을 구현할 수 있습니다.</p>
<p>순서를 간략히 정리하면 다음과 같습니다<br><strong>각 루프마다</strong><br>1.최대 원소를 찾는다.<br>2.최대 원소와 맨 오른쪽 원소를 교환한다.<br>3.맨 오른쪽 원소를 제외한다.<br><strong>하나의 원소만 남을 때까지 위의 루프를 반복</strong></p>
<p>의사 코드는 다음과 같습니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">selectionSort</span>(A[], n) &#123;</span><br><span class="line">    <span class="keyword">for</span> last &lt;- downto <span class="number">2</span> &#123;</span><br><span class="line">        A[<span class="number">1.</span>..last] 중 가장 큰 수 A[k]를 찾는다</span><br><span class="line">        A[K] &lt;-&gt; A[last]; A[k]와 A[last]값을 교환</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>시간 복잡도를 계산한다면<br>1)for 루프는 n-1번 반복 되고<br>2)가장 큰 수를 찾기 위한 비교 횟수는 n-1, n-2, … , 2, 1<br>3)교환은 상수 시간 작업이므로</p>
<p><strong>T(n) = (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2  = O(n^2)</strong></p>
<p>시간 복잡도는 O(n^2)가 됩니다.</p>
<p>이제 마지막으로 c++ 코드로 작성하면 다음과 같습니다.<br>(위의 예시에서는 매 순서마다 가장 값이 큰 원소를 가장 오른쪽 원소와 변경함으로써 오름차순 정렬을 구현했지만, 아래의 코드에서는 매 순서마다 가장 값이 작은 원소를 가장 왼쪽의 원소와 변경함으로써 오름차순 정렬을 구현했습니다.)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min_idx, tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[min_idx]) &#123;</span><br><span class="line">                min_idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = a[min_idx];</span><br><span class="line">        a[min_idx] = a[i];</span><br><span class="line">        a[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">15</span>, <span class="number">2</span>, <span class="number">24</span>, <span class="number">18</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">21</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(a) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">print_arr</span>(a, size);</span><br><span class="line">    <span class="built_in">selection_sort</span>(a, size);</span><br><span class="line">    <span class="built_in">print_arr</span>(a, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="삽입-정렬"><a href="#삽입-정렬" class="headerlink" title="삽입 정렬"></a>삽입 정렬</h2><p><strong><code>삽입 정렬</code>은 매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다고 이해하면 쉽습니다.</strong><br>(선택 정렬은 위치가 정해져있고 이 위치에 어떤 원소를 넣을지 선택하는 것이었다면, 삽입 정렬은 원소는 정해져있고 이 원소를 어디에 넣을지 선택하는 것이라고 이해하면 될 것 같습니다.)</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fl8b6zjclzj30w00hgwgi.jpg" alt="삽입 정렬 과정"></p>
<p>위의 그림은 삽입 정렬의 전체적인 과정을 보여주는 것이고, 아래 사진은 삽입 정렬의 전체과정 중 한 과정을 상세하게 보여주고 있습니다.</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl8bcn4pz7j30nw0ib40g.jpg"></p>
<p>이번에 선택된 원소는 4이고, 이 원소를 어떤 자리에 삽입할지 탐색하는 과정을 보여줍니다.</p>
<p>삽입 정렬의 의사 코드는 다음과 같습니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insertionSort</span>(A[], n)&#123;</span><br><span class="line">    <span class="keyword">for</span> i&lt;- <span class="number">2</span> to n&#123;</span><br><span class="line">        A[<span class="number">1.</span>..i]의 적당한 자리에 A[i]를 삽입한다.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>시간 복잡도를 계산한다면<br>1)for 루프는 n-1번 반복 되고<br>2)최악의 경우 데이터 삽입을 위한 비교는 i-1번 비교</p>
<p>따라서 최악의 경우 <strong>T(n) = (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2  = O(n^2)</strong></p>
<p>시간 복잡도는 O(n^2)가 됩니다.</p>
<p>이제 마지막으로 c++ 코드로 작성하면 다음과 같습니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        tmp = a[i];</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; a[j - <span class="number">1</span>] &gt; tmp) &#123;</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">15</span>, <span class="number">2</span>, <span class="number">24</span>, <span class="number">18</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">21</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(a) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">print_arr</span>(a, size);</span><br><span class="line">    <span class="built_in">insert_sort</span>(a, size);</span><br><span class="line">    <span class="built_in">print_arr</span>(a, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="버블-정렬"><a href="#버블-정렬" class="headerlink" title="버블 정렬"></a>버블 정렬</h2><p><strong><code>버블 정렬</code>은 선택 정렬과 기본 개념이 비슷합니다. 버블 정렬에서도 선택 정렬과 같이 이미 해당 순서에 원소를 넣을 위치는 정해져 있고, 어떤 원소를 넣을지 선택한다라고 생각하면 됩니다. 다만 선택 정렬과는 다르게 최대값을 찾고, 그 최대값을 맨 마지막 원소와 교환하는 과정에서 차이가 있습니다.</strong></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl8bhflqlaj30rm0g9myd.jpg" alt="버블 정렬 과정"></p>
<p>버블 정렬의 의사 코드는 다음과 같습니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bubbleSort</span>(A[], n)&#123;</span><br><span class="line">    <span class="keyword">for</span> last &lt;- downto <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt;- <span class="number">1</span> to last - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[i+<span class="number">1</span>]) then A[i] &lt;-&gt; A[i+<span class="number">1</span>] <span class="comment">// 교환</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>시간 복잡도를 계산한다면<br>1)바깥 for 루프는 n-1번 반복 되고<br>2)안쪽 for 루프는 n-1, n-2, …, 2, 1번 반복<br>3)원소 교환은 상수시간 작업</p>
<p>따라서 T(n) = (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2  = O(n^2)**</p>
<p>시간 복잡도는 O(n^2)가 됩니다.</p>
<p>이제 마지막으로 c++ 코드로 작성하면 다음과 같습니다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buuble_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[j]) &#123;</span><br><span class="line">                tmp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">15</span>, <span class="number">2</span>, <span class="number">24</span>, <span class="number">18</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">21</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(a) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">print_arr</span>(a, size);</span><br><span class="line">    <span class="built_in">buuble_sort</span>(a, size);</span><br><span class="line">    <span class="built_in">print_arr</span>(a, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>출처 : 2015 봄학기 알고리즘 - 부경대 권오흠 교수님</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpeg" alt="JongMin"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">JongMin</p><p class="is-size-6 is-block">생각을 기록하자</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">125</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">205</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/jongmin92" target="_blank" rel="external nofollow noopener noreferrer">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/jongmin92"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Facebook" href="https://www.facebook.com/jongmin.kim.7796420"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/BOJ/"><span class="level-start"><span class="level-item">BOJ</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Concept/"><span class="level-start"><span class="level-item">Concept</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Book/"><span class="level-start"><span class="level-item">Book</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">95</span></span></a><ul><li><a class="level is-mobile" href="/categories/Programming/AWS/"><span class="level-start"><span class="level-item">AWS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Gradle/"><span class="level-start"><span class="level-item">Gradle</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/HTML/"><span class="level-start"><span class="level-item">HTML</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Linux-Ubuntu/"><span class="level-start"><span class="level-item">Linux &amp; Ubuntu</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Node/"><span class="level-start"><span class="level-item">Node</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/RaspberryPi/"><span class="level-start"><span class="level-item">RaspberryPi</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/React-Native/"><span class="level-start"><span class="level-item">React Native</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Project/"><span class="level-start"><span class="level-item">Project</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Project/Emily/"><span class="level-start"><span class="level-item">Emily</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Tip/"><span class="level-start"><span class="level-item">Tip</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-20T15:17:42.000Z">2021-03-21</time></p><p class="title"><a href="/2021/03/21/Kotlin/coroutines/">코루틴 이해하기</a></p><p class="categories"><a href="/categories/Kotlin/">Kotlin</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2020-03-30T15:44:27.000Z">2020-03-31</time></p><p class="title"><a href="/2020/03/31/Java/use-assertthat/">Unit Test에서 AssertThat을 사용하자</a></p><p class="categories"><a href="/categories/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2020-01-02T13:29:00.000Z">2020-01-02</time></p><p class="title"><a href="/2020/01/02/Java/rsa/">Encryption - RSA</a></p><p class="categories"><a href="/categories/Programming/">Programming</a> / <a href="/categories/Programming/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-12-26T13:23:00.000Z">2019-12-26</time></p><p class="title"><a href="/2019/12/26/Programming/2019-retrospect/">2년차 LINE 서버 개발자의 2019년 회고</a></p><p class="categories"><a href="/categories/Programming/">Programming</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-12-23T14:37:00.000Z">2019-12-23</time></p><p class="title"><a href="/2019/12/23/Programming/hmac/">HMAC을 이용한 무결성 보장</a></p><p class="categories"><a href="/categories/Programming/">Programming</a></p></div></article></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">광고</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-3921438651818825" data-ad-slot="3015269677" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="92Hz" height="28"></a><p class="is-size-7"><span>&copy; 2021 KimJongMin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>